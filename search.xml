<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1.1. Hello,World</title>
      <link href="/posts/86cfc706002e/"/>
      <url>/posts/86cfc706002e/</url>
      
        <content type="html"><![CDATA[<p>传统案例“hello world”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span><br></code></pre></td></tr></table></figure><p>毫无疑问，这个命令会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello, world<br></code></pre></td></tr></table></figure><p>Go语言原生支持Unicode, 可以处理全世界任何语言的文本。<br>如果不只是一次性实验，可以进行编译重新，并保留编译结果以备将来之用。<br>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span><br></code></pre></td></tr></table></figure><p>编译命令生成一个名为helloworld的可执行的二进制文件。<br>运行可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./helloworld</span><br>hello,world<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> Go语言圣经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.8. 本章要点</title>
      <link href="/posts/f529e3c31d9e/"/>
      <url>/posts/f529e3c31d9e/</url>
      
        <content type="html"><![CDATA[<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><ul><li>if</li><li>for</li><li>switch<ul><li>Go语言并不需要显式地在每一个<code>case</code>后写<code>break</code>，语言默认执行完<code>case</code>后的逻辑语句会自动退出。</li><li><code>fallthrough</code>可以<code>case</code>穿透。</li><li>Go语言里的<code>switch</code>还可以不带操作对象，默认用<code>true</code>值代替，然后将每个case的表达式和true值进行比较。这种形式叫无tag switch(tagless switch)，与switch true等价。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Signum</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> x &gt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> +<span class="hljs-number">1</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">case</span> x &lt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="命名类型"><a href="#命名类型" class="headerlink" title="命名类型"></a>命名类型</h1><p>给予类型一个新名称。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">var</span> p Point<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p> 指针是一种直接存储了变量的内存地址的数据类型。<br> 指针是可见的内存地址，<code>&amp;</code>操作符可以返回一个变量的内存地址，并且<code>*</code>操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p><h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><p> 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。<br> 接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p> 官方的标准库<br> <a href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a href="https://godoc.org/">https://godoc.org</a><br> <code>godoc</code>工具可以直接在本地命令行阅读标准库的文档，如：<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> $ </span><span class="language-bash">go doc http.ListenAndserve</span><br>package http // import &quot;net/http&quot;<br><br>func ListenAndServe(addr string, handler Handler) error<br>    ListenAndServe listens on the TCP network address addr and then calls<br>    Serve with handler to handle requests on incoming connections. Accepted<br>    connections are configured to enable TCP keep-alives.<br><br>    The handler is typically nil, in which case the DefaultServeMux is used.<br><br>    ListenAndServe always returns a non-nil error.<br></code></pre></td></tr></table></figure></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p> 多行注释<code>/* ... */</code></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.7. Web服务</title>
      <link href="/posts/94de4df7cd79/"/>
      <url>/posts/94de4df7cd79/</url>
      
        <content type="html"><![CDATA[<p>Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是URL.Path &#x3D; “hello”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler) <span class="hljs-comment">// each request calls handler</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the Path component of the request URL r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果操作系统为Mac OS X或者Linux，可以在运行命令的末尾加上一个&amp;符号，可以在后台运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ go <span class="hljs-keyword">run</span><span class="language-bash"> server1/main.go &amp;</span><br></code></pre></td></tr></table></figure><p>可以使用fetch进行发送客户端请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./fetch http://localhost:8000<br>URL.Path = <span class="hljs-string">&quot;/&quot;</span><br>$ ./fetch http://localhost:8000/help<br>URL.Path = <span class="hljs-string">&quot;/help&quot;</span><br></code></pre></td></tr></table></figure><p>也可以使用浏览器直接访问<code>http://localhost:8000</code>。<br>下面版本对请求次数继续计算，对URL的请求结果会包含各种URL被访问的总次数，直接对<code>/count</code>这个URL的访问要被排除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Server2 is a minimal &quot;echo&quot; and counter server.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>http.HandleFunc(<span class="hljs-string">&quot;/count&quot;</span>, counter)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// hanlder echoes the Path component of the requested URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>count++<br>mu.Unlock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br><br><span class="hljs-comment">// counter echoes the number of calls so far.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Count %d\n&quot;</span>, count)<br>mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个更为丰富的例子，<code>handler</code>函数会把请求的http头和请求的form数据都打印出来，更便于检查和调试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the HTTP request.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Host = %q\n&quot;</span>, r.Host)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)<br><span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Form[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后会输出以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">GET / HTTP/1.1<br>Header[&quot;User-Agent&quot;]=[&quot;Go-http-client/1.1&quot;]<br>Header[&quot;Accept-Encoding&quot;]=[&quot;gzip&quot;]<br>Host = &quot;localhost:8000&quot;<br>RemoteAddr = &quot;127.0.0.1:51006&quot;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.12：</strong> 修改Lissajour服务，从URL读取变量，比如你可以访问 <a href="http://localhost:8000/?cycles=20">http://localhost:8000/?cycles=20</a> 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whileIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>cycles, _ := strconv.Atoi(r.FormValue(<span class="hljs-string">&quot;cycles&quot;</span>))<br><span class="hljs-keyword">if</span> cycles &gt; <span class="hljs-number">50</span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;The number of cycles cannot be greater than 50&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>lissajous(w, cycles)<br>&#125;)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(w http.ResponseWriter, cycles <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">//cycles = 5 // number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; <span class="hljs-type">float64</span>(cycles)*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(w, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.6. 并发获取多个URL</title>
      <link href="/posts/c84dc5dd7597/"/>
      <url>/posts/c84dc5dd7597/</url>
      
        <content type="html"><![CDATA[<p>下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>nbytes, err := io.Copy(io.Discard, resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetchall.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetchall http://www.baidu.com http://qq.com http://gopl.io</span><br>0.03s  374152 http://www.baidu.com<br>0.05s     228 http://qq.com<br>1.42s    4154 http://gopl.io<br>1.42s elapsed<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.10：</strong> 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elased\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>buf := <span class="hljs-built_in">new</span>(strings.Builder)<br>nbytes, err := io.Copy(buf, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>resp.Body.Close()<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s\n %s&quot;</span>, secs, nbytes, url, buf)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.11：</strong> 在fatchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。<br>解：<br>将输出响应错误信息，但不影响其他网站的访问。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5. 获取URL</title>
      <link href="/posts/8855378318a6/"/>
      <url>/posts/8855378318a6/</url>
      
        <content type="html"><![CDATA[<p>为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Fetch prints the content found at a URL.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:reading %s: %v\n&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch http://gopl.io</span><br>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;<br>  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;<br>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;<br>...<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.7：</strong> 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。<br>解：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-keyword">for</span> _, url := range os<span class="hljs-selector-class">.Args</span><span class="hljs-selector-attr">[1:]</span> &#123;<br>resp, err := http<span class="hljs-selector-class">.Get</span>(url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io<span class="hljs-selector-class">.Copy</span>(os<span class="hljs-selector-class">.Stdout</span>, resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.8：</strong> 修改fetch这个范例，如果输入的url参数没有 http:&#x2F;&#x2F; 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;<br>url = <span class="hljs-string">&quot;http://&quot;</span> + url<br>&#125;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io.Copy(os.Stdout, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.9：</strong> 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Println(resp.Status)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4. GIF动画</title>
      <link href="/posts/d37e56e6ca24/"/>
      <url>/posts/d37e56e6ca24/</url>
      
        <content type="html"><![CDATA[<p>下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形(Lissajous figures)，这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lissajous generates GIF animations of random Lissajous figures.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span>     <span class="hljs-comment">// number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用以下命令生成一个GIF动画。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build lissajous</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./lissajous &gt;out.gif</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/./images/out.gif" alt="out"></p><p>练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。<br>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x1</span>&#125;, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/./images/out_1.gif" alt="out"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.6：</strong> 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x1</span>&#125;, color.White&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/./images/lissajous2.gif" alt="lissajous2"></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3. 查找重复的行</title>
      <link href="/posts/c749b9e4bafd/"/>
      <url>/posts/c749b9e4bafd/</url>
      
        <content type="html"><![CDATA[<p>对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。</p><p>dup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，<code>map</code>数据类型以及<code>bufio</code>包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup1 prints the text of each line that appears more than</span><br><span class="hljs-comment">// once in the standard input, preceded by its count.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> input.Text() == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。<br>if语句的else部分是可选的，在if的条件为false时执行。<br><code>map</code>存储了键&#x2F;值（key&#x2F;value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用<code>==</code>运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数<code>make</code>创建空<code>map</code>，此外，它还有别的作用。<br>从功能和实现上说，Go的<code>map</code>类似于Java语言中的<code>HashMap</code>，Python语言中的<code>dict</code>，Lua语言中的<code>table</code>，通常使用hash实现。遗憾的是，对于该词的翻译并不统一，数学界术语为映射，而计算机界众说纷纭莫衷一是。<br><code>counts[input.Text()]++</code>语句等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">line := input.Text()<br>counts[line] = counts[line] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>Printf</code>部分格式字符</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">%d          十进制整数<br>%x, %o, %b  十六进制，八进制，二进制整数。<br>%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00<br>%t          布尔：true或false<br>%c          字符（rune） (Unicode码点)<br>%s          字符串<br>%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;<br>%v          变量的自然形式（natural format）<br>%T          变量的类型<br>%%          字面上的百分号标志（无操作数）<br></code></pre></td></tr></table></figure><p>制表符<code>\t</code>和换行符<code>\n</code>,称为<code>转义字符</code>(escap sequences)。<br>按照惯例，以字母<code>f</code>结尾的格式化函数，如<code>log.Printf</code>和<code>fmt.Errof</code>,都采用了<code>fmt.Printf</code>的格式化准则。<br>以<code>ln</code>结尾的格式化函数，则遵循<code>Printlin</code>的方式，以跟<code>%v</code>差不多的方式格式化参数，并在最后添加一个换行符。<br>后缀<code>f</code>指<code>format</code>, <code>ln</code>指<code>line</code>。<br>很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。<code>dup</code>程序的下个版本读取标准输入或是使用<code>os.Open</code>打开各个具名文件，并操作它们。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup2 prints the count and text of lines that appear more than once</span><br><span class="hljs-comment">// in the input. It reads from stdin or from a list of named files.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>dup</code>的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。下面这个版本，dup3，就是这么操作的。这个例子引入了<code>ReadFile</code>函数（来自于<code>io/ioutil</code>包），其读取指定文件的全部内容，<code>strings.Split</code>函数把字符串分割成子串的切片。（<code>Split</code>的作用与前文提到的<code>strings.Join</code>相反。）<br>我们略微简化了dup3。首先，由于<code>ReadFile</code>函数需要文件名作为参数，因此只读指定文件，不读标准输入。其次，由于行计数代码只在一处用到，故将其移回<code>main</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args &#123;<br>data, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup3:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, line := <span class="hljs-keyword">range</span> strings.Split(<span class="hljs-type">string</span>(data), <span class="hljs-string">&quot;\n&quot;</span>) &#123;<br>counts[line]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.4：</strong> 修改dup2，出现重复的行时打印文件名称。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> counts[input.Text()] &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Println(f.Name())<br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2. 命令行参数</title>
      <link href="/posts/b7c6dc0a75aa/"/>
      <url>/posts/b7c6dc0a75aa/</url>
      
        <content type="html"><![CDATA[<p>大多数程序都是处理输入，产生输出，这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？<br>有以下几种获取输入数据：</p><ul><li>一些程序生成自己的数据</li><li>文件</li><li>网络连接</li><li>其它程序的输入</li><li>键盘，鼠标等</li><li>命令行参数</li><li>其它类似输入源</li></ul><p><code>os</code>包以跨平台的方式，提供了一些与操作系统交互的函数和变量。<br>程序的命令行参数可从<code>os</code>包的Args变量获取。<br><code>os</code>包外部使用<code>os.Args</code>访问该变量。</p><p><code>os.Args</code>变量是一个字符串切片（<code>string slice</code>）。<br><code>slice</code>是简化的动态数组。<br>可以把<code>slice</code>当做数组元素序列，序列的成长度动态变化，用<code>s[i]</code>访问单个元素，用<code>s[n:m]</code>获取子序列。<br>序列的元素数目为<code>len(s)</code>。<br>区间索引时，采用<code>左闭右开</code>形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。如<code>s[m:n]</code>这个切片，0 ≤ m ≤ n ≤ len(s)，包含n - m个元素。“比如a &#x3D; [1, 2, 3, 4, 5], a[0:3] &#x3D; [1, 2, 3]，不包含最后一个元素”</p><p><code>os.Args</code>的第一个元素，<code>os.Args[0]</code>是命令本身的名字。<br>其它元素则是程序启动时传给它的参数。即<code>os.Args[1:len(os.Args)]</code>,简化<code>os.Args[1:]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo1 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;<br>s += sep + os.Args[i]<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ go <span class="hljs-built_in">run</span> echo1 1 2 3 4 5<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12345<br></code></pre></td></tr></table></figure><p>Go语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post &#123;<br><span class="hljs-comment">// zero or more statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环三个部分不需括号包围。<br>大括号强制要求, 左大括号必须和post语句在同一行。<br><code>initialization</code>语句是可选的，在循环开始前执行。<br><code>initalization</code>如果存在，必须是一条简单语句（<code>simple statement</code>），即，短变量声明、自增语句、赋值语句或函数调用。<br><code>condition</code>是一个布尔表达式（<code>boolean expression</code>），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。<br><code>post</code>语句在循环体执行结束后执行，之后再次对<code>conditon</code>求值。<code>condition</code>值为false时，循环结束。</p><p>for循环的这三个部分每个都可以省略，如果省略<code>initialization</code>和<code>post</code>，分号也可以省略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional &quot;while&quot; loop</span><br><span class="hljs-keyword">for</span> condition &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果连<code>condition</code>也省略了，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional infinite loop</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条<code>break</code>或<code>return</code>语句。</p><p>for循环的另一种形式, 在某种数据类型的区间（<code>range</code>）上遍历，如字符串或切片。echo的第二版本展示了这种形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo2 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环迭代，range产生一对值: 索引以及在该索引处的元素值。<br>这个例子不需要索引，但range的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量, 如temp, 然后忽略它的值，但Go语言不允许使用无用的局部变量（<code>local variables</code>），因为这会导致编译错误。Go语言中这种情况的解决方法是用空标识符（blank identifier），即_（也就是下划线）。</p><p>echo的这个版本使用一条短变量声明来声明并初始化s和seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。<br>第二种形式依赖于字符串的默认初始化零值机制，被初始化为””。<br>第三种形式用得很少，除非同时声明多个变量。<br>第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。<br>实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p><p>如前文所述，每次循环迭代字符串s的内容都会更新。<code>+=</code>连接原字符串、空格和下个参数，产生新字符串, 并把它赋值给s。s原来的内容已经不再使用，将在适当时机对它进行垃圾回收。</p><p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(os.Args[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.1：</strong> 修改echo程序，使其能够打印os.Args[0]，即被执行命令本身的名字。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(os.Args[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.2：</strong> 修改echo程序，使其打印每个参数的索引和值，每个一行。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> idx, sep := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Print(idx)<br>fmt.Println(<span class="hljs-string">&quot;  &quot;</span> + sep)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.3：</strong> 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>startTime := time.Now()<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>secs := time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br><br>startTime = time.Now()<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>secs = time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1. Hello, World</title>
      <link href="/posts/02fc6779c7cd/"/>
      <url>/posts/02fc6779c7cd/</url>
      
        <content type="html"><![CDATA[<p>传统案例“hello world”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span><br></code></pre></td></tr></table></figure><p>毫无疑问，这个命令会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello, world<br></code></pre></td></tr></table></figure><p>Go语言原生支持Unicode, 可以处理全世界任何语言的文本。<br>如果不只是一次性实验，可以进行编译重新，并保留编译结果以备将来之用。<br>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span><br></code></pre></td></tr></table></figure><p>编译命令生成一个名为helloworld的可执行的二进制文件。<br>运行可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./helloworld</span><br>hello,world<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 入门</title>
      <link href="/posts/b721eb61c1a0/"/>
      <url>/posts/b721eb61c1a0/</url>
      
        <content type="html"><![CDATA[<p>本章主要为Go语言的基础组件，及其示例程序等。</p><p><a href="/posts/02fc6779c7cd/">1.1. Hello, World</a></p><p><a href="/posts/b7c6dc0a75aa/">1.2. 命令行参数</a></p><p><a href="/posts/c749b9e4bafd/">1.3. 查找重复的行</a></p><p><a href="/posts/d37e56e6ca24/">1.4. GIF动画</a></p><p><a href="/posts/8855378318a6/">1.5. 获取URL</a></p><p><a href="/posts/c84dc5dd7597/">1.6. 并发获取多个URL</a></p><p><a href="/posts/94de4df7cd79/">1.7. Web服务</a></p><p><a href="/posts/f529e3c31d9e/">1.8. 本章要点</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
