<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8.10. 示例：聊天服务</title>
      <link href="/posts/b4674e4b8337/"/>
      <url>/posts/b4674e4b8337/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>这个程序可以让用户通过服务器向其他用户广播文本信息。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>该程序可以分解为四个goroutine。</p><ul><li>main 主函数goroutine实例，用于创建连接。</li><li>broadcaster 用于处理不同类型的的消息。</li><li>handleConn 用于处理连接数据。</li><li>cientWriter 用于返回客户端信息。</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><p>main 主要用于处理（listen and accept）从客户端过来的连接。而对应每一个连接，都会创建相对应的handleConn goroutine用于处理连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="broadcaster"><a href="#broadcaster" class="headerlink" title="broadcaster"></a>broadcaster</h2><p>broadcater goroutine 中的内部变量<code>clients</code>是记录当前建立连接的客户端集合，其记录内容是每一个客户端的消息发送到channel的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> client <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span> <span class="hljs-comment">// an outgoing message channel</span><br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>message  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-comment">// all incoming  client message</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>) <span class="hljs-comment">// all connected clients</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg := &lt;-message:<br><span class="hljs-comment">// Broadcast incoming message to all</span><br><span class="hljs-comment">// clients&#x27; outgoing message channels.</span><br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br>cli &lt;- msg<br>&#125;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>broadcatser全局监听三个channel，entering，leaving和message。<br>entering和leaving分别是客户端登录和退出，以更新clients集合。<br>message为客户端发送到服务器的信息，服务器会广播信息到客户端。</p><h2 id="handleConn"><a href="#handleConn" class="headerlink" title="handleConn"></a>handleConn</h2><p>handleConn会为每一个到来的客户端创建一个发送信息的channel，并通过entering channel来通知新客户端的到来。<br>handleConn会读取客户端发送的文本信息，并处理，然后通过message channel发送出去，当客户端发送信息完毕时，handleConn会通过leaving channel来通知客户端的退出并关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-comment">// outgoing client messages</span><br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>who := conn.RemoteAddr().String()<br>ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + who<br>message &lt;- who + <span class="hljs-string">&quot; has arrived&quot;</span><br>entering &lt;- ch<br><br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>message &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><br><br>leaving &lt;- ch<br>message &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="clientWriter"><a href="#clientWriter" class="headerlink" title="clientWriter"></a>clientWriter</h2><p>handleConn为每一个到来的客户端创建了clientWriter goroutine用以接收向客户端发出的信息，并写入到客户端的网络连接中。clientWriter会一直读取信息，直到客户端退出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, msg) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring network errors.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Chat is a server that let clients chat with each other.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> client <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span> <span class="hljs-comment">// an outgoing message channel</span><br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>message  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-comment">// all incoming  client message</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>) <span class="hljs-comment">// all connected clients</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> msg := &lt;-message:<br><span class="hljs-comment">// Broadcast incoming message to all</span><br><span class="hljs-comment">// clients&#x27; outgoing message channels.</span><br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br>cli &lt;- msg<br>&#125;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>) <span class="hljs-comment">// outgoing client messages</span><br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>who := conn.RemoteAddr().String()<br>ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + who<br>message &lt;- who + <span class="hljs-string">&quot; has arrived&quot;</span><br>entering &lt;- ch<br><br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>message &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><br><br>leaving &lt;- ch<br>message &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, msg) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring network errors.</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当与n个客户端保持聊天session时，该程序有2n+2个并发的goroutine。<br>然而该程序并不需要显式锁来保证并发安全，因为全局变量clients被限制在boradcaster这个独立的协程中，所以它并不能被并发访问。<br>多个goroutine共享的变量只有channel和net.Conn的实例，这些类型的实例是并发安全的。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.12：</strong> 使broadcaster能够将arrival事件通知当前所有的客户端。为了达成这个目的，你需要有一个客户端的集合，并且在entering和leaving的channel中记录客户端的名字。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Chat is a server that lets clients chat with each other.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> client <span class="hljs-keyword">struct</span> &#123;<br>ch   <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span><br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> c, _ := <span class="hljs-keyword">range</span> clients &#123;<br>names = <span class="hljs-built_in">append</span>(names, c.name)<br>&#125;<br>cli.ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%d arrival: %v&quot;</span>, <span class="hljs-built_in">len</span>(names), names)<br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli.ch)<br><span class="hljs-keyword">case</span> msg := &lt;-messages:<br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br>cli.ch &lt;- msg<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>who := conn.RemoteAddr().String()<br>ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + who<br>messages &lt;- who + <span class="hljs-string">&quot; has arrived.&quot;</span><br>entering &lt;- client&#123;<br>ch:   ch,<br>name: who,<br>&#125;<br><br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>&#125;<br><br>leaving &lt;- client&#123;ch, who&#125;<br>messages &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, msg)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 8.13：</strong> 使聊天服务器能够断开空闲的客户端连接，比如最近五分钟之后没有发送任何消息的那些客户端。提示：可以在其它goroutine中调用conn.Close()来解除Read调用，就像input.Scanner()所做的那样。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> client <span class="hljs-keyword">struct</span> &#123;<br>ch   <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> clients &#123;<br>names = <span class="hljs-built_in">append</span>(names, c.name)<br>&#125;<br>cli.ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%d arrival. %v&quot;</span>, <span class="hljs-built_in">len</span>(names), names)<br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli.ch)<br><span class="hljs-keyword">case</span> msg := &lt;-messages:<br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br>cli.ch &lt;- msg<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">5</span> * time.Minute<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">func handleConn(conn net.Conn) &#123;</span><br><span class="hljs-comment">ch := make(chan string)</span><br><span class="hljs-comment">go clientWriter(conn, ch)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">who := conn.RemoteAddr().String()</span><br><span class="hljs-comment">ch &lt;- &quot;You are &quot; + who</span><br><span class="hljs-comment">entering &lt;- client&#123;ch, who&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">timer := time.NewTimer(timeout)</span><br><span class="hljs-comment">go func() &#123;</span><br><span class="hljs-comment">&lt;-timer.C</span><br><span class="hljs-comment">conn.Close()</span><br><span class="hljs-comment">&#125;()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">input := bufio.NewScanner(conn)</span><br><span class="hljs-comment">for input.Scan() &#123;</span><br><span class="hljs-comment">messages &lt;- who + &quot;: &quot; + input.Text()</span><br><span class="hljs-comment">timer.Reset(timeout)</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">leaving &lt;- client&#123;ch, who&#125;</span><br><span class="hljs-comment">messages &lt;- who + &quot; has left.&quot;</span><br><span class="hljs-comment">conn.Close()</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>who := conn.RemoteAddr().String()<br>ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + who<br>messages &lt;- who + <span class="hljs-string">&quot; has arrived.&quot;</span><br>entering &lt;- client&#123;ch, who&#125;<br><br>input := bufio.NewScanner(conn)<br>talking := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> input.Scan() &#123;<br>messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>talking &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>leaving &lt;- client&#123;ch, who&#125;<br>messages &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-talking:<br><span class="hljs-keyword">case</span> &lt;-time.After(timeout):<br>conn.Close()<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, msg)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 8.14：</strong> 修改聊天服务器的网络协议这样每一个客户端就可以在entering时可以提供它们的名字。将消息前缀由之前的网络地址改为这个名字。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Chat is a server that lets clients chat with each other.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> client <span class="hljs-keyword">struct</span> &#123;<br>ch   <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> clients &#123;<br>names = <span class="hljs-built_in">append</span>(names, c.name)<br>&#125;<br>cli.ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%d arrival. %v&quot;</span>, <span class="hljs-built_in">len</span>(names), names)<br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli.ch)<br><span class="hljs-keyword">case</span> msg := &lt;-messages:<br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br>cli.ch &lt;- msg<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">5</span> * time.Minute<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>ch &lt;- <span class="hljs-string">&quot;Your name:&quot;</span><br>input := bufio.NewScanner(conn)<br>input.Scan()<br>who := input.Text()<br><br>messages &lt;- who + <span class="hljs-string">&quot; has arrived.&quot;</span><br>entering &lt;- client&#123;ch, who&#125;<br><br>timer := time.NewTimer(timeout)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-timer.C<br>conn.Close()<br>&#125;()<br><br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>timer.Reset(timeout)<br>&#125;<br><br>leaving &lt;- client&#123;ch, who&#125;<br>messages &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, msg)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 8.15：</strong> 如果一个客户端没有及时地读取数据可能会导致所有的客户端被阻塞。修改broadcaster来跳过一条消息，而不是等待这个客户端一直到其准备好写。或者为每一个客户端的消息发出channel建立缓冲区，这样大部分的消息便不会被丢掉；broadcaster应该用一个非阻塞的send向这个channel中发消息。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> client <span class="hljs-keyword">struct</span> &#123;<br>ch   <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span><br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)<br>messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;<br>clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> cli := &lt;-entering:<br>clients[cli] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> c := <span class="hljs-keyword">range</span> clients &#123;<br>names = <span class="hljs-built_in">append</span>(names, c.name)<br>&#125;<br>cli.ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%d arrival. %v&quot;</span>, <span class="hljs-built_in">len</span>(names), names)<br><span class="hljs-keyword">case</span> cli := &lt;-leaving:<br><span class="hljs-built_in">delete</span>(clients, cli)<br><span class="hljs-built_in">close</span>(cli.ch)<br><span class="hljs-keyword">case</span> msg := &lt;-messages:<br><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> cli.ch &lt;- msg:<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">5</span> * time.Minute<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">20</span>)<br><span class="hljs-keyword">go</span> clientWriter(conn, ch)<br><br>ch &lt;- <span class="hljs-string">&quot;Your name:&quot;</span><br>input := bufio.NewScanner(conn)<br>input.Scan()<br>who := input.Text()<br><br>messages &lt;- who + <span class="hljs-string">&quot; has arrived.&quot;</span><br>entering &lt;- client&#123;ch, who&#125;<br><br>timer := time.NewTimer(timeout)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-timer.C<br>conn.Close()<br>&#125;()<br><br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()<br>timer.Reset(timeout)<br>&#125;<br><br>leaving &lt;- client&#123;ch, who&#125;<br>messages &lt;- who + <span class="hljs-string">&quot; has left.&quot;</span><br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch <span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;[&quot;</span>+time.Now().Format(<span class="hljs-string">&quot;15:04:05&quot;</span>)+<span class="hljs-string">&quot;] &quot;</span>+msg)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8080&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><br><span class="hljs-keyword">go</span> broadcaster()<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.5. 剖析</title>
      <link href="/posts/f5ef3e713f2a/"/>
      <url>/posts/f5ef3e713f2a/</url>
      
        <content type="html"><![CDATA[<h1 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h1><p>过早的优化是万恶之源！<br>自动化的剖析技术是基于程序执行期间一些抽样数据，然后推断后面的执行状态；最终产生一个运行时间的统计数据文件。</p><p>Go语言支持多种类型的剖析性能分析，内建的<code>go test</code>工具对几种分析方式都提供了支持：</p><ul><li><code>CPU分析</code>,CPU分析文件标识了函数执行时所需要的CPU时间。<br>  当前运行的系统线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个分析文件然后恢复正常的运行。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -cpuprofile=cpu.out <br></code></pre></td></tr></table></figure></li><li><code>堆分析</code>则记录了程序的内存使用情况。<br>  每个内存分配操作都会触发内部平均内存分配例程，每个512KB的内存申请都会触发一个事件。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -blockprofile=block.out<br></code></pre></td></tr></table></figure></li><li><code>阻塞分析</code>则记录了goroutine最大的阻塞操作，例如系统调用、管道发送和接收，还有获取锁等。<br>  分析库会记录每个goroutine被阻塞时的相关操作。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -memprofile=mem.out<br></code></pre></td></tr></table></figure></li></ul><p>在测试环境下只需要一个标志参数就可以生成各种分析文件。当一次使用多个标志参数时需要当心，因为分析操作本身也可能会影像程序的运行。</p><h1 id="pprof"><a href="#pprof" class="headerlink" title="pprof"></a>pprof</h1><p>一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。<br>为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。<br>启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对于测试包的名字。</p><p>下面的命令演示了如何生成一个CPU分析文件。我们选择net&#x2F;http包的一个基准测试为例。通常是基于一个已经确定了是关键代码的部分进行基准测试。基准测试会默认包含单元测试，这里我们用-run&#x3D;NONE参数禁止单元测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -run=NONE -bench=ClientServerParallelTLS64 -cpuprofile=cpu.log net/http</span><br>goos: darwin<br>goarch: amd64<br>pkg: net/http<br>cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz<br>BenchmarkClientServerParallelTLS64-8    2024/02/09 00:32:21 http: TLS handshake error from 127.0.0.1:60038: read tcp 127.0.0.1:60017-&gt;127.0.0.1:60038: use of closed network connection<br>...<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">$ go tool pprof -text -nodecount=10 ./http.test cpu.log</span><br>File: http.test<br>Type: cpu<br>Time: Feb 9, 2024 at 12:32am (CST)<br>Duration: 1.81s, Total samples = 8190ms (451.38%)<br>Showing nodes accounting for 7120ms, 86.94% of 8190ms total<br>Dropped 206 nodes (cum &lt;= 40.95ms)<br>Showing top 10 nodes out of 211<br>      flat  flat%   sum%        cum   cum%<br>    3610ms 44.08% 44.08%     3610ms 44.08%  syscall.syscall<br>     900ms 10.99% 55.07%      900ms 10.99%  runtime.madvise<br>     750ms  9.16% 64.22%      750ms  9.16%  math/big.addMulVVW<br>     660ms  8.06% 72.28%      660ms  8.06%  runtime.memclrNoHeapPointers<br>     450ms  5.49% 77.78%     1440ms 17.58%  math/big.nat.montgomery<br>     200ms  2.44% 80.22%      210ms  2.56%  syscall.rawSyscall<br>     170ms  2.08% 82.30%      170ms  2.08%  runtime.kevent<br>     150ms  1.83% 84.13%      150ms  1.83%  runtime.memmove<br>     130ms  1.59% 85.71%      130ms  1.59%  syscall.syscall6<br>     100ms  1.22% 86.94%      100ms  1.22%  runtime.pthread_kill<br></code></pre></td></tr></table></figure><p>参数<code>-text</code>用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。<br>其中<code>-nodecount=10</code>标志参数限制了只输出前10行的结果。<br>可以看出，HTTPS基准测试中<code>syscall.syscall</code>函数占用了将近一半的CPU资源。</p><p>可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 <a href="http://www.graphviz.org/">http://www.graphviz.org</a> 下载。参数<code>-web</code>用于生成一个有向图文件，包含了CPU的使用和最热点的函数等信息。</p><p>阅读Go官方博客的“Proﬁling Go Programs”一文，以了解更多。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.4. 基准测试</title>
      <link href="/posts/a1b71dd23f51/"/>
      <url>/posts/a1b71dd23f51/</url>
      
        <content type="html"><![CDATA[<p>基准测试是测量一个程序在固定工作负载下的性能。<br>以<code>Benchmark</code>为前缀名，并且带有一个<code>*testing.B</code>类型的参数；<code>*testing.B</code>参数除了提供和<code>*testing.T</code>类似的方法，还有额外一些和性能测量相关的方法。<br>它还提供了一个整数N，用于指定操作执行的循环次数。</p><p>下面是<code>IsPalindrome</code>的基准测试函数，将循环调用多次：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIsPalindrome</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>IsPalindrome(<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和普通测试不同的是，默认情况下不运行任何基准测试。<br>我们需要通过<code>-bench</code>命令行标志参数手工指定要运行的基准测试函数。<br>该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -bench=.</span><br>goos: darwin<br>goarch: amd64<br>pkg: go-learn-gopl/ch/ch11/word2<br>cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz<br>BenchmarkIsPalindrome-8          4016119               299.6 ns/op<br>PASS<br>ok      go-learn-gopl/ch/ch11/word2     1.918s<br></code></pre></td></tr></table></figure><p>可以看出，首先输出<code>goos</code>、<code>goarch</code>、<code>pkg</code>和<code>cpu</code>的信息，接着是基准测试函数的测试结果。<br><code>BenchmarkIsPalindrome-8</code>，其中<code>BenchmarkIsPalindrome</code>是基准测试函数名，<code>-8</code>指的是cpu核心数为8，数字<code>4016119</code>为运行<code>IsPalindrome</code>了多少次，每次运行的平均耗时为<code>299.6 ns/op</code>。</p><p>真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。</p><p>循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。<br>如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。</p><h1 id="优化代码"><a href="#优化代码" class="headerlink" title="优化代码"></a>优化代码</h1><p>有了基准测试，就可以尝试优化代码以降低耗能。<br>原代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> letters []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;<br>letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> letters &#123;<br><span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显然，可以将循环折半，避免重复的比较。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> letters []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;<br>letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))<br>&#125;<br>&#125;<br><br>n := <span class="hljs-built_in">len</span>(letters) / <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>再次进行基准测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -bench=.<br>goos: darwin<br>goarch: amd64<br>pkg: <span class="hljs-keyword">go</span>-learn-gopl/ch/ch11/word2<br>cpu: Intel(R) Core(TM) i7<span class="hljs-number">-7820</span>HQ CPU @ <span class="hljs-number">2.90</span>GHz<br>BenchmarkIsPalindrome<span class="hljs-number">-8</span>          <span class="hljs-number">4199281</span>               <span class="hljs-number">287.6</span> ns/op<br>PASS<br>ok      <span class="hljs-keyword">go</span>-learn-gopl/ch/ch11/word2     <span class="hljs-number">1.629</span>s<br></code></pre></td></tr></table></figure><p>性能提升了4%。<br>还有一个可以改进的地方，定额初始化数组letters，避免在append时过多分配内存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>letters := <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s))<br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;<br>letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))<br>&#125;<br>&#125;<br><br>n := <span class="hljs-built_in">len</span>(letters) / <span class="hljs-number">2</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br><span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>基准测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -bench=.</span><br>goos: darwin<br>goarch: amd64<br>pkg: go-learn-gopl/ch/ch11/word2<br>cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz<br>BenchmarkIsPalindrome-8          8410392               139.2 ns/op<br>PASS<br>ok      go-learn-gopl/ch/ch11/word2     1.843s<br></code></pre></td></tr></table></figure><p>显然，性能大大提高，高达54%。</p><p><code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计。<br>比较初始代码和优化后的内存分配情况：<br>初始：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -bench=. -benchmem</span><br>goos: darwin<br>goarch: amd64<br>pkg: go-learn-gopl/ch/ch11/word2<br>cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz<br>BenchmarkIsPalindrome-8          3963399               302.5 ns/op           248 B/op          5 allocs/op<br>PASS<br>ok      go-learn-gopl/ch/ch11/word2     2.072s<br></code></pre></td></tr></table></figure><p>优化后：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -bench=. -benchmem</span><br>goos: darwin<br>goarch: amd64<br>pkg: go-learn-gopl/ch/ch11/word2<br>cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz<br>BenchmarkIsPalindrome-8          8484489               140.1 ns/op           128 B/op          1 allocs/op<br>PASS<br>ok      go-learn-gopl/ch/ch11/word2     1.497s<br></code></pre></td></tr></table></figure><p>内存占用较初始代码，减少了近80%。</p><p>通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。<br>要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 11.6:</strong> 为2.6.2节的练习2.4和练习2.5的<code>PopCount</code>函数编写基准测试。看看基于表格算法在不同情况下对提升性能会有多大帮助。<br>解：<br>popcount.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">0</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">1</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">2</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">3</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">4</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">5</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">6</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">7</span>*<span class="hljs-number">8</span>)])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>n += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;i*<span class="hljs-number">8</span>)])<br>&#125;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitShift</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); i &lt; <span class="hljs-number">64</span>; i++ &#123;<br><span class="hljs-keyword">if</span> (x&gt;&gt;i)&amp;<span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitClear</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br>x &amp;= x - <span class="hljs-number">1</span><br>c++<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountSSS</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x = x - ((x &gt;&gt; <span class="hljs-number">1</span>) &amp; <span class="hljs-number">0x5555555555555555</span>)<br>x = (x &amp; <span class="hljs-number">0x3333333333333333</span>) + ((x &gt;&gt; <span class="hljs-number">2</span>) &amp; <span class="hljs-number">0x3333333333333333</span>)<br>x = (x + (x &gt;&gt; <span class="hljs-number">4</span>)) &amp; <span class="hljs-number">0x0f0f0f0f0f0f0f0f</span><br>x = x + (x &gt;&gt; <span class="hljs-number">8</span>)<br>x = x + (x &gt;&gt; <span class="hljs-number">16</span>)<br>x = x + (x &gt;&gt; <span class="hljs-number">32</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(x &amp; <span class="hljs-number">0x7f</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> x <span class="hljs-type">uint64</span> = <span class="hljs-number">0x123456789ABCDEF</span><br><br><span class="hljs-comment">// BenchmarkPopCount-8             1000000000         0.2781 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkPopCountByLoop-8       300207886         3.695 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkPopCountByBitShift-8   58636833        19.13 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitShift</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitShift(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkPopCountByBitClear-8           62708774                19.09 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitClear</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitClear(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// BenchmarkPopCountSSS-8          1000000000         0.2791 ns/op</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountSSS</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountSSS(x)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 11.7:</strong> 为<code>*IntSet</code>（§6.5）的<code>Add</code>、<code>UnionWith</code>和其他方法编写基准测试，使用大量随机输入。你可以让这些方法跑多快？选择字的大小对于性能的影响如何？IntSet和基于内建map的实现相比有多快？<br>解：<br>intset.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> uintSize = <span class="hljs-number">32</span> &gt;&gt; (^<span class="hljs-type">uint</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/uintSize, x%uintSize<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/uintSize, x%uintSize<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> AddAll(ints ...<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ints &#123;<br>s.Add(x)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Remove(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/uintSize, x%uintSize<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; word &#123;<br>s.words[word] &amp;^= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Clear() &#123;<br>s.words = <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Elems() []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> elems []<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mark := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mark &lt; uintSize; mark++ &#123;<br><span class="hljs-keyword">if</span> tword&amp;(<span class="hljs-number">1</span>&lt;&lt;mark) != <span class="hljs-number">0</span> &#123;<br>elems = <span class="hljs-built_in">append</span>(elems, <span class="hljs-type">int</span>(<span class="hljs-type">uint</span>(i)*uintSize+mark))<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> elems<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; uintSize; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;j) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, uintSize*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); j &lt; uintSize; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;j) != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Copy() *IntSet &#123;<br>nIntSet := &amp;IntSet&#123;&#125;<br>nIntSet.words = <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, <span class="hljs-built_in">len</span>(s.words))<br><span class="hljs-built_in">copy</span>(nIntSet.words, s.words)<br><span class="hljs-keyword">return</span> nIntSet<br>&#125;<br><br><span class="hljs-comment">// UnionWith 并集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// IntersectWith 交集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> IntersectWith(t *IntSet) &#123;<br>minLen := <span class="hljs-built_in">len</span>(s.words)<br><span class="hljs-keyword">if</span> minLen &gt; <span class="hljs-built_in">len</span>(t.words) &#123;<br>minLen = <span class="hljs-built_in">len</span>(t.words)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minLen; i++ &#123;<br>s.words[i] &amp;= t.words[i]<br>&#125;<br><br>l := <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := minLen - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[<span class="hljs-number">0</span>:l]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// DifferenceWith 差集 s有t没有 按t清除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> DifferenceWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(t.words) &#123;<br>s.words[i] &amp;^= t.words[i]<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> l <span class="hljs-type">int</span> = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// SymmetricDifference 并差集 即s有t没有和t有s没有的集合</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> SymmetricDifference(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] ^= t.words[i]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i++ &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Equal(t *IntSet) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) != <span class="hljs-built_in">len</span>(t.words) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s.words); i++ &#123;<br><span class="hljs-keyword">if</span> s.words[i] != t.words[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>intset_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>s1, s2 []<span class="hljs-type">int</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>n     = <span class="hljs-number">10000</span><br>scale = <span class="hljs-number">1000</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initRandomSet</span><span class="hljs-params">()</span></span> &#123;<br>seed := time.Now().UTC().UnixNano()<br>rng := rand.New(rand.NewSource(seed))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>s1 = <span class="hljs-built_in">append</span>(s1, rng.Intn(n*scale))<br>s2 = <span class="hljs-built_in">append</span>(s2, rng.Intn(n*scale))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIntSet_Add</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>s := &amp;IntSet&#123;&#125;<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> s1 &#123;<br>s.Add(k)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIntSet_Has</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>s := &amp;IntSet&#123;&#125;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>s.Add(k)<br>&#125;<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>s.Has(k)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIntSet_UnionWith</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>is1 := &amp;IntSet&#123;&#125;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>is1.Add(k)<br>&#125;<br>is2 := &amp;IntSet&#123;&#125;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s2 &#123;<br>is2.Add(k)<br>&#125;<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>is1.UnionWith(is2)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMap_Add</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>m[k] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMap_Has</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>_ = m[k]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMap_UnionWith</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>initRandomSet()<br>m1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s1 &#123;<br>m1[k] = <span class="hljs-literal">true</span><br>&#125;<br>m2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> _, k := <span class="hljs-keyword">range</span> s2 &#123;<br>m2[k] = <span class="hljs-literal">true</span><br>&#125;<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m2 &#123;<br>m1[k] = <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">$ go test -bench=. -benchmem</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex11/ex11.7</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkIntSet_Add-8              14942            102885 ns/op           60024 B/op         14 allocs/op</span><br><span class="hljs-comment">BenchmarkIntSet_Has-8              15846             87719 ns/op               0 B/op          0 allocs/op</span><br><span class="hljs-comment">BenchmarkIntSet_UnionWith-8         1641            665692 ns/op               0 B/op          0 allocs/op</span><br><span class="hljs-comment">BenchmarkMap_Add-8                   334           3787969 ns/op           20288 B/op         14 allocs/op</span><br><span class="hljs-comment">BenchmarkMap_Has-8                  3279            339227 ns/op               0 B/op          0 allocs/op</span><br><span class="hljs-comment">BenchmarkMap_UnionWith-8             109          11360623 ns/op           66691 B/op         69 allocs/op</span><br><span class="hljs-comment">PASS</span><br><span class="hljs-comment">ok      go-learn-gopl/ex/ex11/ex11.7    10.775s</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.3. 测试覆盖率</title>
      <link href="/posts/79be1aaa69b3/"/>
      <url>/posts/79be1aaa69b3/</url>
      
        <content type="html"><![CDATA[<p>由测试驱动触发运行到的被测试函数的代码数目称为测试的覆盖率。测试覆盖率并不能量化——甚至连最简单的动态程序也难以精确测量——但是可以启发并帮助我们编写的有效的测试代码。</p><p>语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用go test命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。</p><p>下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCoverage</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;<br>input <span class="hljs-type">string</span><br>env   Env<br>want  <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;x % 2&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;unexpected &#x27;%&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;math.Pi&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;unexpected &#x27;.&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;!true&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;unexpected &#x27;!&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;log(10)&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">`unknown function &quot;log&quot;`</span>&#125;,<br>&#123;<span class="hljs-string">&quot;sqrt(i, 2)&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;call to sqrt has 2 args, want 1&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">87616</span>, <span class="hljs-string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="hljs-string">&quot;167&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">10</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">-40</span>&#125;, <span class="hljs-string">&quot;-40&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;-x * -x&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">2</span>&#125;, <span class="hljs-string">&quot;4&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br>expr, err := Parse(test.input)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>err = expr.Check(<span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>&#123;&#125;)<br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> err.Error() != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%s: got %q, want %q&quot;</span>, test.input, err, test.want)<br>&#125;<br><span class="hljs-keyword">continue</span><br>&#125;<br><br>got := fmt.Sprintf(<span class="hljs-string">&quot;%.6g&quot;</span>, expr.Eval(test.env))<br><span class="hljs-keyword">if</span> got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%s: %v =&gt; %s, want %s&quot;</span>, test.input, test.env, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先确保测试通过:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -v -run=coverage</span><br>testing: warning: no tests to run<br>PASS<br>ok      go-learn-gopl/ch/ch11/eval      0.433s<br></code></pre></td></tr></table></figure><p>查看cover覆盖率工具的使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go tool cover</span><br>Usage of &#x27;go tool cover&#x27;:<br>Given a coverage profile produced by &#x27;go test&#x27;:<br>        go test -coverprofile=c.out<br><br>Open a web browser displaying annotated source code:<br>        go tool cover -html=c.out<br><br>...<br></code></pre></td></tr></table></figure><p><code>go tool</code>命令运行Go工具链的底层可执行程序。这些底层可执行程序放在<code>$GOROOT/pkg/tool/$&#123;GOOS&#125;_$&#123;GOARCH&#125;</code>目录。<br>可以用<code>-coverprofile</code>标志参数重新运行测试:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -run=Coverage -coverprofile=c.out</span><br>PASS<br>coverage: 69.3% of statements<br>ok      go-learn-gopl/ch/ch11/eval      0.360s<br></code></pre></td></tr></table></figure><p>该命令还会生成一个c.out的文件，存储代码块的是否调用的布尔值。<br>这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它会修改要测试代码的副本，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用<code>go test -cover</code>。）<br>如果使用了<code>-covermode=count</code>标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。</p><p>还可以生成html统计数据的网页：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go tool cover -html=c.out</span><br></code></pre></td></tr></table></figure><p>网页中绿色代码块指的是已被覆盖，红色指的是未覆盖的代码块。<br><img src="/11.3.%20%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87/1707221584554.png" alt="1707221584554"><br>所以，尽可能增加测试用例以覆盖代码块。</p><p>实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；</p><p>测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.2. 测试函数</title>
      <link href="/posts/0bc5b76177c6/"/>
      <url>/posts/0bc5b76177c6/</url>
      
        <content type="html"><![CDATA[<p>每个测试函数必须导入test包。<br>测试函数格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>测试函数必须以Test为前缀，可选的后缀名必须以大写开头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">(t *testing.T)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSin</span><span class="hljs-params">(t *testing.T)</span></span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCos</span><span class="hljs-params">(t *testing.T)</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>其中t参数用于报告错误或附加的测试信息。</p><p>下面定义了一个函数IsPalindrome，用于检测字符串从前往后和从后往前是否一样，即是否回文。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package word provides utilities for word games.</span><br><span class="hljs-keyword">package</span> word<br><br><span class="hljs-comment">// IsPalindrome reports whether s reads the same forward and backward.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> s[i] != s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>-i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接着就是word的测试文件，word_test.go。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> word<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;detartrated&quot;</span>) &#123;<br>t.Error(<span class="hljs-string">`IsPalindrome(&quot;detartrated&quot;&quot;)=false`</span>)<br>&#125;<br><span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;kayak&quot;</span>) &#123;<br>t.Error(<span class="hljs-string">`IsPalindrome(&quot;kayak&quot;&quot;)=false`</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNonPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> IsPalindrome(<span class="hljs-string">&quot;Palindrome&quot;</span>) &#123;<br>t.Error(<span class="hljs-string">`IsPalindrome(&quot;Palindrome&quot;&quot;)=true`</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>TestPalindrome</code>是测试字符串是回文，所以不是回文时报错。<br><code>TestNonPalindrome</code>是测试字符串不是回文，所以是回文时报错。<br>使用<code>go test</code>命令进行测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/go-learn-gopl/ch/ch11/word1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span></span><br>PASS<br>ok      go-learn-gopl/ch/ch11/word1     0.551s<br></code></pre></td></tr></table></figure><p>通过测试！</p><p>但当遇上这样的字符串呢？“été”、“A man, a plan, a canal: Panama.”<br>添加多2个测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFrenchPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;été&quot;</span>) &#123;<br>t.Error(<span class="hljs-string">`IsFrenchPalindrome(&quot;été&quot;)=false`</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCanalPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>input := <span class="hljs-string">&quot;A man, a plan, a canal: Panama.&quot;</span><br><span class="hljs-keyword">if</span> !IsPalindrome(input) &#123;<br>t.Errorf(<span class="hljs-string">&quot;IsCanalPalindrome(%q)=false&quot;</span>, input)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试用例返回了错误信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span></span><br>--- FAIL: TestFrenchPalindrome (0.00s)<br>    word_test.go:22: IsFrenchPalindrome(&quot;été&quot;)=false<br>--- FAIL: TestCanalPalindrome (0.00s)<br>    word_test.go:29: IsCanalPalindrome(&quot;A man, a plan, a canal: Panama.&quot;)=false<br>FAIL<br>exit status 1<br>FAIL    go-learn-gopl/ch/ch11/word1     0.699s<br></code></pre></td></tr></table></figure><p>参数<code>-v</code>可以用于打印每个测试函数的名字和运行时间。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -v</span><br>=== RUN   TestPalindrome<br>--- PASS: TestPalindrome (0.00s)<br>=== RUN   TestNonPalindrome<br>--- PASS: TestNonPalindrome (0.00s)<br>=== RUN   TestFrenchPalindrome<br>    word_test.go:22: IsFrenchPalindrome(&quot;été&quot;)=false<br>--- FAIL: TestFrenchPalindrome (0.00s)<br>=== RUN   TestCanalPalindrome<br>    word_test.go:29: IsCanalPalindrome(&quot;A man, a plan, a canal: Panama.&quot;)=false<br>--- FAIL: TestCanalPalindrome (0.00s)<br>FAIL<br>exit status 1<br>FAIL    go-learn-gopl/ch/ch11/word1     3.047s<br></code></pre></td></tr></table></figure><p>参数<code>-run</code>对应一个正则表达式，只有测试函数名和正则表达式匹配的测试函数可以被运行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span> -run=<span class="hljs-string">&quot;French|Canal&quot;</span></span><br>--- FAIL: TestFrenchPalindrome (0.00s)<br>    word_test.go:22: IsFrenchPalindrome(&quot;été&quot;)=false<br>--- FAIL: TestCanalPalindrome (0.00s)<br>    word_test.go:29: IsCanalPalindrome(&quot;A man, a plan, a canal: Panama.&quot;)=false<br>FAIL<br>exit status 1<br>FAIL    go-learn-gopl/ch/ch11/word1     0.251s<br></code></pre></td></tr></table></figure><p>一旦我们修复所有bug，应该以不带任何参数的go test命令进行测试。</p><p>显然，第一个bug的原因为使用的byte而不是rune，导致非ASCII编码的字符无法比较。<br>第二个bug是因为没有忽略空格和大小写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package word provides utilities for word games.</span><br><span class="hljs-keyword">package</span> word<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unicode&quot;</span><br><br><span class="hljs-comment">// IsPalindrome reports whether s reads same forward and backward.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> letters []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<br><span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;<br>letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> letters &#123;<br><span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="举例测试"><a href="#举例测试" class="headerlink" title="举例测试"></a>举例测试</h1><p>word_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> word<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIsPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;<br>input <span class="hljs-type">string</span><br>want  <span class="hljs-type">bool</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-literal">false</span>&#125;,<br>&#123;<span class="hljs-string">&quot;kayak&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;detartrated&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;A man, a plan, a canal: Panama.&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Evil I did dwell; lewd did I live.&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Able was I ere I saw Elba&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;été&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;Et se resservir, ivresse reste.&quot;</span>, <span class="hljs-literal">true</span>&#125;,<br>&#123;<span class="hljs-string">&quot;palindrome&quot;</span>, <span class="hljs-literal">false</span>&#125;, <span class="hljs-comment">// non-palindrome</span><br>&#123;<span class="hljs-string">&quot;desserts&quot;</span>, <span class="hljs-literal">false</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br><span class="hljs-keyword">if</span> got := IsPalindrome(test.input); got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;IsPalindrome(%q)=%v&quot;</span>, test.input, got)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试全部通过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">test</span></span><br>PASS<br>ok      go-learn-gopl/ch/ch11/word2     0.123s<br></code></pre></td></tr></table></figure><p>和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。<br>如果是发送错误，需要终止测试，可以使用t.Fatal或t.Fatalf停止当前测试函数。</p><p>测试失败的信息一般的形式是“f(x) &#x3D; y, want z”，其中f(x)解释了失败的操作和对应的输出，y是实际的运行结果，z是期望的正确的结果。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 11.1:</strong> 为4.3节中的charcount程序编写测试。<br>解：<br>count.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> count<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;unicode&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> count <span class="hljs-keyword">struct</span> &#123;<br>counts  <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>         <span class="hljs-comment">// counts of Unicode characters</span><br>utflen  [utf8.UTFMax + <span class="hljs-number">1</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// count of lengths of UTF-8 encodings</span><br>invalid <span class="hljs-type">int</span>                  <span class="hljs-comment">//count of invalid Unicode characters.</span><br>err     <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">charCount</span><span class="hljs-params">(r io.Reader)</span></span> count &#123;<br><span class="hljs-keyword">var</span> c count<br>c.counts = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>)<br>input := bufio.NewReader(r)<br><span class="hljs-keyword">for</span> &#123;<br>r, n, err := input.ReadRune()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>c.err = err<br>&#125;<br><span class="hljs-keyword">if</span> r == unicode.ReplacementChar &amp;&amp; n == <span class="hljs-number">1</span> &#123;<br>c.invalid++<br><span class="hljs-keyword">continue</span><br>&#125;<br>c.counts[r]++<br>c.utflen[n]++<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>count_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> count<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCharCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>r    io.Reader<br>want count<br>&#125;&#123;<br>&#123;strings.NewReader(<span class="hljs-string">&quot;abcd&quot;</span>),<br>count&#123;<br>counts:  <span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;d&#x27;</span>: <span class="hljs-number">1</span>&#125;,<br>utflen:  [utf8.UTFMax + <span class="hljs-number">1</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;,<br>invalid: <span class="hljs-number">0</span>,<br>err:     <span class="hljs-literal">nil</span>,<br>&#125;&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, test := <span class="hljs-keyword">range</span> tests &#123;<br>got := charCount(test.r)<br><span class="hljs-keyword">if</span> !equal(test.want, got) &#123;<br>t.Errorf(<span class="hljs-string">&quot;%d. got %v, want %v&quot;</span>, i, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(c1, c2 count)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> !(c1.counts == <span class="hljs-literal">nil</span> &amp;&amp; c2.counts == <span class="hljs-literal">nil</span> ||<br>c1.counts != <span class="hljs-literal">nil</span> &amp;&amp; c2.counts != <span class="hljs-literal">nil</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> c, n := <span class="hljs-keyword">range</span> c1.counts &#123;<br><span class="hljs-keyword">if</span> n != c2.counts[c] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c1.counts) != <span class="hljs-built_in">len</span>(c2.counts) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> c1.utflen != c2.utflen &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> c1.invalid != c2.invalid &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">if</span> c1.err != c2.err &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 11.2:</strong> 为（§6.5）的IntSet编写一组测试，用于检查每个操作后的行为和基于内置map的集合等价，后面练习11.7将会用到。<br>解：<br>intset.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, x%<span class="hljs-number">64</span><br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= word<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, word)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br>&#125;<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><p>intset_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-keyword">type</span> interval <span class="hljs-keyword">struct</span> &#123;<br>begin, end <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initIntSet</span><span class="hljs-params">(i *interval)</span></span> *IntSet &#123;<br>s := &amp;IntSet&#123;&#125;<br><span class="hljs-keyword">for</span> x := i.begin; x &lt;= i.end; x++ &#123;<br>s.Add(x)<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">initMapIntSet</span><span class="hljs-params">(i *interval)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span> &#123;<br>s := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> x := i.begin; x &lt;= i.end; x++ &#123;<br>s[x] = <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(s1 *IntSet, s2 <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> s2 &#123;<br><span class="hljs-keyword">if</span> !s1.Has(k) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIntSet</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>i    interval<br>mi   interval<br>want <span class="hljs-type">bool</span><br>&#125;&#123;<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">50</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">50</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">100</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">100</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">50</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">49</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">for</span> i, test := <span class="hljs-keyword">range</span> tests &#123;<br>s1 := initIntSet(&amp;test.i)<br>s2 := initMapIntSet(&amp;test.mi)<br><span class="hljs-keyword">if</span> got := equal(s1, s2); got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%d. got %v, want %v&quot;</span>, i, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestUnionWith</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>ai, bi interval<br>ci     interval<br>want   <span class="hljs-type">bool</span><br>&#125;&#123;<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">10</span>&#125;, interval&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">20</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">20</span>&#125;, interval&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">20</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#123;interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">20</span>&#125;, interval&#123;<span class="hljs-number">10</span>, <span class="hljs-number">30</span>&#125;, interval&#123;<span class="hljs-number">0</span>, <span class="hljs-number">30</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#123;interval&#123;<span class="hljs-number">5</span>, <span class="hljs-number">15</span>&#125;, interval&#123;<span class="hljs-number">10</span>, <span class="hljs-number">20</span>&#125;, interval&#123;<span class="hljs-number">5</span>, <span class="hljs-number">20</span>&#125;, <span class="hljs-literal">true</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, test := <span class="hljs-keyword">range</span> tests &#123;<br>s1, s2 := initIntSet(&amp;test.ai), initIntSet(&amp;test.bi)<br>s1.UnionWith(s2)<br>m := initMapIntSet(&amp;test.ci)<br><span class="hljs-keyword">if</span> got := equal(s1, m); got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%d. got %v, want %v&quot;</span>, i, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="随机测试"><a href="#随机测试" class="headerlink" title="随机测试"></a>随机测试</h1><p>举例测试有一定的局限性，也就是构建更泛的随机输入来测试函数。<br>对于一个随机输入，如何得知希望的输出结果呢？<br>两种方法：</p><ul><li>编写一个对照函数，使用简单且有效的方法，虽然效率可以低，但是函数行为要一致，然后比较两者相同随机输入下的输出结果。<br>-遵循特定的模式，生成随机输入的数据。<br>下面是使用第二种方法，丰富我们的测试函数。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// randomPalindrome returns a palindrome whose length and contents</span><br><span class="hljs-comment">// are derived from the pseudo-random number generator rng.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomPalindrome</span><span class="hljs-params">(rng *rand.Rand)</span></span> <span class="hljs-type">string</span> &#123;<br>n := rng.Intn(<span class="hljs-number">25</span>) <span class="hljs-comment">// random length up to 24</span><br>runes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; i++ &#123;<br>r := <span class="hljs-type">rune</span>(rng.Intn(<span class="hljs-number">0x1000</span>)) <span class="hljs-comment">// random rune up to &#x27;\u0999&#x27;</span><br>runes[i] = r<br>runes[n<span class="hljs-number">-1</span>-i] = r<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(runes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRandomPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// Initialize a pseudo-random number generator.</span><br>seed := time.Now().UTC().UnixNano()<br>t.Logf(<span class="hljs-string">&quot;Random seed: %d&quot;</span>, seed)<br>rng := rand.New(rand.NewSource(seed))<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>p := randomPalindrome(rng)<br><span class="hljs-keyword">if</span> !IsPalindrome(p) &#123;<br>t.Errorf(<span class="hljs-string">&quot;IsPalindrome(%q)=false&quot;</span>, p)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>虽然使用随机测试有很多不确定因素，但是它是十分重要的，我们可以从错误信息中分析出程序的问题所在。<br>在定期运行的自动化测试集成系统中，随机测试非常重要。</li></ul><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 11.3:</strong> TestRandomPalindromes测试函数只测试了回文字符串。编写新的随机测试生成器，用于测试随机生成的非回文字符串。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> word<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomNonPalindrome</span><span class="hljs-params">(rng *rand.Rand)</span></span> <span class="hljs-type">string</span> &#123;<br>n := rand.Intn(<span class="hljs-number">25</span>) + <span class="hljs-number">2</span> <span class="hljs-comment">// 至少2位起</span><br>runes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">rune</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>r := <span class="hljs-type">rune</span>(rand.Intn(<span class="hljs-number">0x1000</span>)) <span class="hljs-comment">// 0~/u0999</span><br>runes[i] = r<br>&#125;<br><span class="hljs-comment">// 如果首尾相同，可以替换首位，直到不相同</span><br><span class="hljs-keyword">for</span> runes[<span class="hljs-number">0</span>] == runes[n<span class="hljs-number">-1</span>] &#123;<br>runes[<span class="hljs-number">0</span>] = <span class="hljs-type">rune</span>(rand.Intn(<span class="hljs-number">0x1000</span>))<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(runes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRandomNonPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>seed := time.Now().UTC().UnixNano()<br>rng := rand.New(rand.NewSource(seed))<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>p := randomNonPalindrome(rng)<br><span class="hljs-keyword">if</span> IsPalindrome(p) &#123;<br>t.Errorf(<span class="hljs-string">&quot;IsPalindrome(%v)=true&quot;</span>, p)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 11.4:</strong> 修改randomPalindrome函数，以探索IsPalindrome是否对标点和空格做了正确处理。<br>解：<br>randomPalindrome函数实则对空格和标点符号做了正确的处理。<br>rune(0x0<del>0x999) 其实上包含了空格（0x0020） 和 标点符号（0x0020</del>0x0040）。</p><h1 id="测试命令程序"><a href="#测试命令程序" class="headerlink" title="测试命令程序"></a>测试命令程序</h1><p><code>go test</code>还可以测试main包的程序。<br>下面以输出命令程序做例子：<br>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>n = flag.Bool(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;omit trailing newline&quot;</span>)<br>s = flag.String(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;separator&quot;</span>)<br>)<br><br><span class="hljs-keyword">var</span> out io.Writer = os.Stdout<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> err := echo(*n, *s, os.Args[<span class="hljs-number">1</span>:]); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;echo:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(newline <span class="hljs-type">bool</span>, sep <span class="hljs-type">string</span>, args []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>fmt.Fprintf(out, strings.Join(args, sep))<br><span class="hljs-keyword">if</span> newline &#123;<br>fmt.Fprintln(out)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>echo_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEcho</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>newline <span class="hljs-type">bool</span><br>sep     <span class="hljs-type">string</span><br>args    []<span class="hljs-type">string</span><br>want    <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;&quot;</span>, []<span class="hljs-type">string</span>&#123;&#125;, <span class="hljs-string">&quot;\n&quot;</span>&#125;,<br>&#123;<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>, []<span class="hljs-type">string</span>&#123;&#125;, <span class="hljs-string">&quot;&quot;</span>&#125;,<br>&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;\t&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;, <span class="hljs-string">&quot;one\ttwo\tthree\n&quot;</span>&#125;,<br>&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;,&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;, <span class="hljs-string">&quot;a,b,c\n&quot;</span>&#125;,<br>&#123;<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;:&quot;</span>, []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;, <span class="hljs-string">&quot;1:2:3&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, test := <span class="hljs-keyword">range</span> tests &#123;<br>descr := fmt.Sprintf(<span class="hljs-string">&quot;encho(%v, %q, %q)&quot;</span>, test.newline, test.sep, test.args)<br>out = <span class="hljs-built_in">new</span>(bytes.Buffer)<br><span class="hljs-keyword">if</span> err := echo(test.newline, test.sep, test.args); err != <span class="hljs-literal">nil</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;%s failed: %v&quot;</span>, descr, err)<br>&#125;<br>got := out.(*bytes.Buffer).String()<br><span class="hljs-keyword">if</span> got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%d. %s = %q, want %q&quot;</span>, i, descr, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>要注意的是，测试文件要与main文件放在同一个包内。<br>该测试中，使用了内部包级变量out，在测试中，可以将out替换，以达到测试的效果。</p><h1 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h1><p>一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。<br><code>黑盒测试</code>只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。<br><code>白盒测试</code>有访问包内部函数和数据结构的权限，因此可以做到一下普通客户端无法实现的测试。<br>白盒测试也叫做<code>clear box test</code>。</p><p>黑盒和白盒这两种测试方法是互补的。<br>黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。<br>    - 它们可以帮助测试者了解真是客户的需求，<br>    - 帮助发现API设计的一些不足之处。<br>白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。</p><p><code>TestIsPalindrome</code> 测试仅使用了导出的<code>IsPalindrome</code>函数，所以是黑盒测试。<br><code>TestEcho</code>测试则调用了内部的<code>echo</code>函数，还更新内部包级变量<code>out</code>，所以这是白盒测试。</p><p>可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。</p><p>下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> storage<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/smtp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytesInUse</span><span class="hljs-params">(username <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-keyword">const</span> sender = <span class="hljs-string">&quot;notifications@example.com&quot;</span><br><span class="hljs-keyword">const</span> password = <span class="hljs-string">&quot;correchorsebatterysaple&quot;</span><br><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">&quot;smtp.example.com&quot;</span><br><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;Warning: you are using %d bytes of storage, %d%% of your quota&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckQuota</span><span class="hljs-params">(username <span class="hljs-type">string</span>)</span></span> &#123;<br>used := bytesInUse(username)<br><span class="hljs-keyword">const</span> quota = <span class="hljs-number">1000000000</span> <span class="hljs-comment">// 1GB</span><br>percent := <span class="hljs-number">100</span> * used<br><span class="hljs-keyword">if</span> percent &lt; <span class="hljs-number">90</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>msg := fmt.Sprintf(template, used, percent)<br>auth := smtp.PlainAuth(<span class="hljs-string">&quot;&quot;</span>, sender, password, hostname)<br>err := smtp.SendMail(hostname+<span class="hljs-string">&quot;:587&quot;</span>, auth, sender, []<span class="hljs-type">string</span>&#123;username&#125;, []<span class="hljs-type">byte</span>(msg))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;smtp.SendMail(%s) failed: %s&quot;</span>, username, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在我们想测试该函数，但是不想发送邮件，可以将发送邮件逻辑抽取出来，然后进行替换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> storage<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/smtp&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytesInUse</span><span class="hljs-params">(username <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">999999999</span><br>&#125;<br><br><span class="hljs-keyword">const</span> sender = <span class="hljs-string">&quot;notifications@example.com&quot;</span><br><span class="hljs-keyword">const</span> password = <span class="hljs-string">&quot;correchorsebatterysaple&quot;</span><br><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">&quot;smtp.example.com&quot;</span><br><br><span class="hljs-keyword">const</span> template = <span class="hljs-string">&quot;Warning: you are using %d bytes of storage, %d%% of your quota&quot;</span><br><br><span class="hljs-keyword">var</span> notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(username, msg <span class="hljs-type">string</span>)</span></span> &#123;<br>auth := smtp.PlainAuth(<span class="hljs-string">&quot;&quot;</span>, sender, password, hostname)<br>err := smtp.SendMail(hostname+<span class="hljs-string">&quot;:587&quot;</span>, auth, sender, []<span class="hljs-type">string</span>&#123;username&#125;, []<span class="hljs-type">byte</span>(msg))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;smtp.SendMail(%s) failed: %s&quot;</span>, username, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckQuota</span><span class="hljs-params">(username <span class="hljs-type">string</span>)</span></span> &#123;<br>used := bytesInUse(username)<br><span class="hljs-keyword">const</span> quota = <span class="hljs-number">1000000000</span> <span class="hljs-comment">// 1GB</span><br>percent := <span class="hljs-number">100</span> * used / quota<br><span class="hljs-keyword">if</span> percent &lt; <span class="hljs-number">90</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>msg := fmt.Sprintf(template, used, percent)<br>notifyUser(username, msg)<br>&#125;<br></code></pre></td></tr></table></figure><p>storage_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> storage<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCheckQuota</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> notifiedUser, notifiedMsg <span class="hljs-type">string</span><br>notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(username, msg <span class="hljs-type">string</span>)</span></span> &#123;<br>notifiedUser, notifiedMsg = username, msg<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-string">&quot;job@example.org&quot;</span><br>CheckQuota(user)<br><span class="hljs-keyword">if</span> notifiedUser == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; notifiedMsg == <span class="hljs-string">&quot;&quot;</span> &#123;<br>t.Fatal(<span class="hljs-string">&quot;notifyUser not called&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> notifiedUser != user &#123;<br>t.Errorf(<span class="hljs-string">&quot;wrong user (%s) notified, want %s&quot;</span>, notifiedUser, user)<br>&#125;<br><br><span class="hljs-keyword">const</span> wantSubstring = <span class="hljs-string">&quot;98% of your quota&quot;</span><br><span class="hljs-keyword">if</span> !strings.Contains(notifiedMsg, wantSubstring) &#123;<br>t.Errorf(<span class="hljs-string">&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, want substring %q&quot;</span>, notifiedMsg, wantSubstring)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里有个问题：当测试函数完成后，<code>CheckQuota</code>将不能正常工作，因为notifiedUser仍然使用的是测试函数中伪发送邮件函数，因为更新的是全局变量。所以必须恢复成原先的路径，保证不会错乱。<br>可以使用defer语句进行恢复。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCheckQuotaNotifiedUser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// Save and restore origin notifyUser</span><br>saved := notifyUser<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; notifyUser = saved &#125;()<br><br><span class="hljs-keyword">var</span> notifiedUser, notifiedMsg <span class="hljs-type">string</span><br>notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(username, msg <span class="hljs-type">string</span>)</span></span> &#123;<br>notifiedUser, notifiedMsg = username, msg<br>&#125;<br><br><span class="hljs-keyword">const</span> user = <span class="hljs-string">&quot;job@example.org&quot;</span><br>CheckQuota(user)<br><span class="hljs-keyword">if</span> notifiedUser == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; notifiedMsg == <span class="hljs-string">&quot;&quot;</span> &#123;<br>t.Fatal(<span class="hljs-string">&quot;notifyUser not called&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> notifiedUser != user &#123;<br>t.Errorf(<span class="hljs-string">&quot;wrong user (%s) notified, want %s&quot;</span>, notifiedUser, user)<br>&#125;<br><br><span class="hljs-keyword">const</span> wantSubstring = <span class="hljs-string">&quot;98% of your quota&quot;</span><br><span class="hljs-keyword">if</span> !strings.Contains(notifiedMsg, wantSubstring) &#123;<br>t.Errorf(<span class="hljs-string">&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, want substring %q&quot;</span>, notifiedMsg, wantSubstring)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。</p><p><code>go test</code>并不会并发执行测试函数，所以这样修改全局变量是安全的。</p><h1 id="拓展测试包"><a href="#拓展测试包" class="headerlink" title="拓展测试包"></a>拓展测试包</h1><p>有这么一个例子：<br><code>net/url</code>包，提供了URL解析的功能；<br><code>net/http</code>包，提供了web服务和HTTP客户端的功能；<br><code>net/http</code>包依赖于<code>net/url</code>;<br>现在需要写一个<code>net/url</code>测试，需要测试不同url与HTTP客户端的交互行为。<br>相当于<code>net/url</code>反过来依赖<code>net/http</code>，岂不是依赖依赖。<br>我们知道，Go语言是禁止循环依赖的。<br>怎么解决？</p><p>可以引入拓展测试包来解决这个问题，也就是在<code>net/url</code>所在的目录创建一个<code>url_test</code>的测试包。<br>测试包的后缀为<code>_test</code>，它会告诉<code>go test</code>工具，应该创建一个额外的包进行测试。<br>测试拓展包不会被其他包导入。<br>因为测试拓展包是一个独立的包，是导入测试代码的辅助包。<br><code>url_test</code>测试拓展包依赖于<code>net/url</code>，<code>net/http</code>包。</p><p>在集成测试中，测试拓展包可以灵活得导入其他包。</p><p>可以使用<code>go list</code>查询哪些包是测试拓展包，哪些是源码，哪些是包内测试。<br>以fmt包为例，<code>GoFiles</code>表示源码源文件，也是<code>go build</code>构建的那部分代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> list -f=&#123;&#123;.GoFiles&#125;&#125; fmt<br>[doc.<span class="hljs-keyword">go</span> format.<span class="hljs-keyword">go</span> <span class="hljs-built_in">print</span>.<span class="hljs-keyword">go</span> scan.<span class="hljs-keyword">go</span>]<br></code></pre></td></tr></table></figure><p><code>TestGoFiles</code>表示的是fmt包内部测试测试代码，以<code>_test.go</code>为后缀文件名，不过只在测试时被构建：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> list -f=&#123;&#123;.TestGoFiles&#125;&#125; fmt<br>[export_test.<span class="hljs-keyword">go</span>]<br></code></pre></td></tr></table></figure><p><code>XTestGoFiles</code>表示的是属于测试扩展包的测试代码，也就是<code>fmt_test</code>包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> list -f=&#123;&#123;.XTestGoFiles&#125;&#125; fmt<br>[errors_test.<span class="hljs-keyword">go</span> example_test.<span class="hljs-keyword">go</span> fmt_test.<span class="hljs-keyword">go</span> gostringer_example_test.<span class="hljs-keyword">go</span> scan_test.<span class="hljs-keyword">go</span> stringer_example_test.<span class="hljs-keyword">go</span> stringer_test.<span class="hljs-keyword">go</span>]<br></code></pre></td></tr></table></figure><p>有时候测试扩展包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试扩展包的白盒测试。<br>在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给测试扩展包。因为这些代码只有在测试时才需要，因此一般会放在<code>export_test.go</code>文件中。</p><p>例如，fmt包的<code>fmt.Scanf</code>函数需要<code>unicode.IsSpace</code>函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫<code>isSpace</code>内部的简易实现。<br>为了确保<code>fmt.isSpace</code>和<code>unicode.IsSpace</code>函数的行为一致，fmt包谨慎地包含了一个测试。是一个在测试扩展包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个秘密出口导出了isSpace函数。export_test.go文件就是专门用于测试扩展包的秘密出口。<br>export_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><br><span class="hljs-keyword">var</span> IsSpace = isSpace<br><span class="hljs-keyword">var</span> Parsenum = parsenum<br></code></pre></td></tr></table></figure><p>fmt_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt_test<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIsSpace</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// This tests the internal isSpace function.</span><br><span class="hljs-comment">// IsSpace = isSpace is defined in export_test.go.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">rune</span>(<span class="hljs-number">0</span>); i &lt;= unicode.MaxRune; i++ &#123;<br><span class="hljs-keyword">if</span> IsSpace(i) != unicode.IsSpace(i) &#123;<br>t.Errorf(<span class="hljs-string">&quot;isSpace(%U) = %v, want %v&quot;</span>, i, IsSpace(i), unicode.IsSpace(i))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个测试文件并没有定义测试代码；它只是通过<code>fmt.IsSpace</code>简单导出了内部的<code>isSpace</code>函数，提供给测试扩展包使用。这个技巧可以广泛用于位于测试扩展包的白盒测试。</p><h1 id="编写有效的测试"><a href="#编写有效的测试" class="headerlink" title="编写有效的测试"></a>编写有效的测试</h1><p>相对于其它语言，Go语言的测试框架非常非常简洁。<br>其它语言测试函数的机制，包括反射，元数据，钩子函数，assert断言，值比较函数，格式化输出错误信息和停止一个识别的测试等辅助函数。<br>虽然这些辅助函数使得测试是否简洁，但是导致输出日志十分之长，定位和查找费劲。<br>Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。</p><p>一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。</p><p>下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很方便使用也确实有效果，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。<br>split_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> split<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertEqual</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> x != y &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;%d!=%d&quot;</span>, x, y))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit_Assert</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>words := strings.Split(<span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>)<br>assertEqual(<span class="hljs-built_in">len</span>(words), <span class="hljs-number">3</span>)<br><span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而放弃了根据上下文提供更有意义的错误信息的做法。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。测试在只有一次重复的模式出现时引入抽象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    s, sep := <span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span><br>    words := strings.Split(s, sep)<br>    <span class="hljs-keyword">if</span> got, want := <span class="hljs-built_in">len</span>(words), <span class="hljs-number">3</span>; got != want &#123;<br>        t.Errorf(<span class="hljs-string">&quot;Split(%q, %q) returned %d words, want %d&quot;</span>,<br>            s, sep, got, want)<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。</p><p>如果有可以使测试代码更简单的方法我们也乐意接受。开始一个好的测试的关键是通过实现你真正想要的具体行为，然后才是考虑然后简化测试代码。最好的接口是直接从库的抽象接口开始，针对公共接口编写一些测试函数。</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p><strong>练习11.5:</strong> 用表格驱动的技术扩展TestSplit测试，并打印期望的输出结果。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> split<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>s    <span class="hljs-type">string</span><br>sep  <span class="hljs-type">string</span><br>want <span class="hljs-type">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>, <span class="hljs-number">3</span>&#125;,<br>&#123;<span class="hljs-string">&quot;q1w1e1r&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">4</span>&#125;,<br>&#123;<span class="hljs-string">&quot;p-o-i-n-t&quot;</span>, <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-number">5</span>&#125;,<br>&#123;<span class="hljs-string">&quot;never give up&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-number">3</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, test := <span class="hljs-keyword">range</span> tests &#123;<br>words := strings.Split(test.s, test.sep)<br><span class="hljs-keyword">if</span> got := <span class="hljs-built_in">len</span>(words); got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%d. split(%q, %q) returns %d words, want %d.&quot;</span>, i, test.s, test.sep, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="避免不稳定的测试"><a href="#避免不稳定的测试" class="headerlink" title="避免不稳定的测试"></a>避免不稳定的测试</h1><p>如果一个应用程序对于新出现的但有效的输入经常失败说明程序不够稳健；<br>同样如果一个测试仅仅因为输入变化就会导致失败也是不合逻辑的。</p><p>避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要检查字符串的全匹配，但是寻找相关的子字符串，因为某些子字符串在项目的发展中是比较稳定不变的。通常编写一个重复杂的输出中提取必要精华信息以用于断言是值得的，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.1 go test</title>
      <link href="/posts/84a75b89cf5a/"/>
      <url>/posts/84a75b89cf5a/</url>
      
        <content type="html"><![CDATA[<p>Go语言关于测试的命令为<code>go test</code>。<br>在包目录范围内，所有以_test.go结尾的源代码文件，并非属于<code>go build</code>框架，而是属于<code>go test</code>测试的一部分。</p><p>在<code>*_test.go</code>文件中，一共有三种函数：</p><ul><li>测试函数<ul><li>测试函数以Test为前缀，用于测试函数的逻辑是否正确。</li></ul></li><li>基准测试函数<ul><li>基准测试函数以Benchmark为前缀，用于衡量函数的性能。</li></ul></li><li>示例函数<ul><li>示例函数以Example为前缀，提供一个由编译器保证正确的示例文档。</li></ul></li></ul><p><code>go test</code>命令会遍历所有以<code>*_test.go</code>结尾的源文件符合规则的测试函数，然后生成临时的main包以调用所有的测试函数，紧接着构建并运行、报告测试结果，最后清理测试中产生的临时文件。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十一章 测试</title>
      <link href="/posts/2b3895c22904/"/>
      <url>/posts/2b3895c22904/</url>
      
        <content type="html"><![CDATA[<p>Go语言的测试技术是相对低级的。它依赖一个<code>go test</code>测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。</p><p><a href="">11.1. go test</a></p><p><a href="/posts/0bc5b76177c6/">11.2. 测试函数</a></p><p><a href="/posts/79be1aaa69b3/">11.3. 测试覆盖率</a></p><p><a href="/posts/a1b71dd23f51/">11.4. 基准测试</a></p><p><a href="/posts/f5ef3e713f2a/">11.5. 剖析</a></p><p><a href="">11.6. 示例函数</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.7. 工具</title>
      <link href="/posts/c1eef8565635/"/>
      <url>/posts/c1eef8565635/</url>
      
        <content type="html"><![CDATA[<p>可以使用<code>go</code>或<code>go help</code>获取内置的帮助文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go</span><br>Go is a tool for managing Go source code.<br><br>Usage:<br><br>go &lt;command&gt; [arguments]<br><br>The commands are:<br><br>bug         start a bug report<br>build       compile packages and dependencies<br>clean       remove object files and cached files<br>doc         show documentation for package or symbol<br>env         print Go environment information<br>fix         update packages to use new APIs<br>fmt         gofmt (reformat) package sources<br>generate    generate Go files by processing source<br>get         download and install packages and dependencies<br>install     compile and install packages and dependencies<br>list        list packages or modules<br>mod         module maintenance<br>work        workspace maintenance<br>run         compile and run Go program<br>test        test packages<br>tool        run specified go tool<br>version     print Go version<br>vet         report likely mistakes in packages<br><br>Use &quot;go help &lt;command&gt;&quot; for more information about a command.<br><br>Additional help topics:<br><br>buildconstraint build constraints<br>buildmode       build modes<br>c               calling between Go and C<br>cache           build and test caching<br>environment     environment variables<br>filetype        file types<br>go.mod          the go.mod file<br>gopath          GOPATH environment variable<br>gopath-get      legacy GOPATH go get<br>goproxy         module proxy protocol<br>importpath      import path syntax<br>modules         modules, module versions, and more<br>module-get      module-aware go get<br>module-auth     module authentication using go.sum<br>packages        package lists and patterns<br>private         configuration for downloading non-public code<br>testflag        testing flags<br>testfunc        testing functions<br>vcs             controlling version control with GOVCS<br><br>Use &quot;go help &lt;topic&gt;&quot; for more information about that topic.<br></code></pre></td></tr></table></figure><h1 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h1><p><code>GOPATH</code>: 指定工作区目录的环境变量。<br>设置命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$HOME</span>/gobook</span><br></code></pre></td></tr></table></figure><p>工作区目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs shell">GOPATH/<br>    src/<br>        gopl.io/<br>            .git/<br>            ch1/<br>                helloworld/<br>                    main.go<br>                dup/<br>                    main.go<br>                ...<br>        golang.org/x/net/<br>            .git/<br>            html/<br>                parse.go<br>                node.go<br>                ...<br>    bin/<br>        helloworld<br>        dup<br>    pkg/<br>        darwin_amd64/<br>        ...<br></code></pre></td></tr></table></figure><p><code>GOPATH</code>下有三个指定的目录：<br><code>src</code>目录用于存储源码。<br><code>pkg</code>目录用于保存编译后的包的目标文件。<br><code>bin</code>目录是保存编译后的可执行文件。</p><h1 id="GOROOT"><a href="#GOROOT" class="headerlink" title="GOROOT"></a>GOROOT</h1><p>环境变量<code>GOROOT</code>:用来指定Go的安装目录，还有它自带的标准库包的位置。<br>GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT&#x2F;src&#x2F;fmt。<br>用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。</p><h1 id="GOOS"><a href="#GOOS" class="headerlink" title="GOOS"></a>GOOS</h1><p>环境变量<code>GOOS</code>: 指定目标的操作系统。<br>android、linux、darwin和windows。</p><h1 id="GOARCH"><a href="#GOARCH" class="headerlink" title="GOARCH"></a>GOARCH</h1><p>环境变量<code>GOARCH</code>：用于指定处理器类型。<br>amd64、386或arm。</p><h1 id="go-env-命令"><a href="#go-env-命令" class="headerlink" title="go env 命令"></a>go env 命令</h1><p><code>go env</code>:  用于查看Go语言工具索涉及的所有环境变量，包括未设置环境变量的默认值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">env</span></span><br>GO111MODULE=&quot;off&quot;<br>GOARCH=&quot;amd64&quot;<br>GOBIN=&quot;&quot;<br>GOCACHE=&quot;/Users/***/Library/Caches/go-build&quot;<br>GOENV=&quot;/Users/***/Library/Application Support/go/env&quot;<br>GOEXE=&quot;&quot;<br>GOEXPERIMENT=&quot;&quot;<br>GOFLAGS=&quot;-buildvcs=true&quot;<br>GOHOSTARCH=&quot;amd64&quot;<br>GOHOSTOS=&quot;darwin&quot;<br>GOINSECURE=&quot;**.com&quot;<br>GOMODCACHE=&quot;/Users/***/go/pkg/mod&quot;<br>GONOPROXY=&quot;&quot;<br>GONOSUMDB=&quot;&quot;<br>GOOS=&quot;darwin&quot;<br>GOPATH=&quot;/Users/***/go&quot;<br>GOPRIVATE=&quot;&quot;<br>GOPROXY=&quot;https://goproxy.cn,direct&quot;<br>GOROOT=&quot;/usr/local/go&quot;<br>GOSUMDB=&quot;sum.golang.org&quot;<br>GOTMPDIR=&quot;&quot;<br>GOTOOLDIR=&quot;/usr/local/go/pkg/tool/darwin_amd64&quot;<br>GOVCS=&quot;&quot;<br>GOVERSION=&quot;go1.19.2&quot;<br>GCCGO=&quot;gccgo&quot;<br>GOAMD64=&quot;v1&quot;<br>AR=&quot;ar&quot;<br>CC=&quot;clang&quot;<br>CXX=&quot;clang++&quot;<br>CGO_ENABLED=&quot;1&quot;<br>GOMOD=&quot;&quot;<br>GOWORK=&quot;&quot;<br>CGO_CFLAGS=&quot;-g -O2&quot;<br>CGO_CPPFLAGS=&quot;&quot;<br>CGO_CXXFLAGS=&quot;-g -O2&quot;<br>CGO_FFLAGS=&quot;-g -O2&quot;<br>CGO_LDFLAGS=&quot;-g -O2&quot;<br>PKG_CONFIG=&quot;pkg-config&quot;<br>GOGCCFLAGS=&quot;-fPIC -arch x86_64 -m64 -pthread -fno-caret-diagnostics -Qunused-arguments -fmessage-length=0 -fdebug-prefix-map=/var/folders/mp/zjw7t9hn7zg7ntbghwqk7f1r0000gn/T/go-build1417725864=/tmp/go-build -gno-record-gcc-switches -fno-common&quot;<br></code></pre></td></tr></table></figure><h1 id="go-get"><a href="#go-get" class="headerlink" title="go get"></a>go get</h1><p><code>go get</code>：下载一个单一的包或者用…下载整个子目录里面的每个包。<br>使用<code>go get</code>命令下载<code>golint</code>包。<br><code>golint</code>包是用于检测Go语言源码编程风格是否有问题。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go get github.com/golang/lint/golint</span><br></code></pre></td></tr></table></figure><p>包下载目录为GOPATH。</p><p><code>go get</code>命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。<br>对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行go help importpath获取相关的信息。</p><p><code>go get</code>命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。<br>例如<code>golang.org/x/net</code>包目录对应一个Git仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> <span class="hljs-variable">$GOPATH</span>/src/golang.org/x/net</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git remote -v</span><br>origin  https://go.googlesource.com/net (fetch)<br>origin  https://go.googlesource.com/net (push)<br></code></pre></td></tr></table></figure><p>需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供。<br>其git仓库真实托管路径是由html网页中的meta元素提供，如“ <a href="https://golang.org/x/net/html%22%E3%80%82">https://golang.org/x/net/html&quot;。</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch1/fetch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch https://golang.org/x/net/html | grep go-import</span><br>&lt;meta name=&quot;go-import&quot;<br>      content=&quot;golang.org/x/net git https://go.googlesource.com/net&quot;&gt;<br></code></pre></td></tr></table></figure><p><code>-u</code> 命令行标志参数，表示<code>go get</code>获取所有的包和依赖包都是最新的。<br>如果不包含该参数，且本地存在该包，那么包将不会被更新。</p><p><code>go get -u</code>命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较很方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。</p><p>GO1.5版本后，可以使用Vendor可以做包的依赖管理。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 10.3:</strong> 从 <a href="http://gopl.io/ch1/helloworld?go-get=1">http://gopl.io/ch1/helloworld?go-get=1</a> 获取内容，查看本书的代码的真实托管的网址（go get请求HTML页面时包含了go-get参数，以区别普通的浏览器请求）。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">/*</span><br><span class="hljs-comment">./fetch http://gopl.io/ch1/helloworld?go-get=1 | grep go-import</span><br><span class="hljs-comment">&lt;meta name=&quot;go-import&quot; content=&quot;gopl.io git https://github.com/adonovan/gopl.io&quot;&gt;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// real git address: https://github.com/adonovan/gopl.io</span><br></code></pre></td></tr></table></figure><h1 id="go-build"><a href="#go-build" class="headerlink" title="go build"></a>go build</h1><p><code>go build</code>命令编译命令行参数指定的每个包。<br>如果包是一个库，则忽略输出结果；这可以用于检测包的可以正确编译的。<br>如果包的名字是main，go build将调用连接器在当前目录创建一个可执行程序；<br>以导入路径的最后一段作为可执行程序的名字。</p><p>当包编译创建可执行程序后，如果是类似Unix命令，可以把可以执行程序放在<code>cmd</code>子目录下。<br>例如用于提供Go文档服务的<code>golang.org/x/tools/cmd/godoc</code>命令就是放在cmd子目录。</p><p>默认情况下，<code>go build</code>命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> quoteargs.go</span><br>package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;os&quot;<br>)<br><br>func main() &#123;<br>    fmt.Printf(&quot;%q\n&quot;, os.Args[1:])<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build quoteargs.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./quoteargs one <span class="hljs-string">&quot;two three&quot;</span> four\ five</span><br>[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]<br></code></pre></td></tr></table></figure><h1 id="go-run"><a href="#go-run" class="headerlink" title="go run"></a>go run</h1><p><code>go run</code>命令实际上是结合了构建和运行的两个步骤。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> quoteargs.go</span><br>package main<br><br>import (<br>    &quot;fmt&quot;<br>    &quot;os&quot;<br>)<br><br>func main() &#123;<br>    fmt.Printf(&quot;%q\n&quot;, os.Args[1:])<br>&#125;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run quoteargs.go one <span class="hljs-string">&quot;two three&quot;</span> four\ five</span><br>[&quot;one&quot; &quot;two three&quot; &quot;four five&quot;]<br></code></pre></td></tr></table></figure><h1 id="go-install"><a href="#go-install" class="headerlink" title="go install"></a>go install</h1><p><code>go install</code>和<code>go build</code>命令类似，但是<code>go install</code>会保存所有包的编译结果，而不是丢弃。<br>被编译的包会被保存到<code>$GOPATH/pkg</code>目录下，目录路径和<code>src</code>目录路径对应，可执行程序被保存到<code>$GOPATH/bin</code>目录。</p><p><code>go install</code>命令和<code>go build</code>命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，<code>go build -i</code>命令将安装每个目标所依赖的包。</p><p>因为编译对应不同的操作系统平台和CPU架构，<code>go install</code>命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，<code>golang.org/x/net/html</code>包将“被安装到<code>$GOPATH/pkg/darwin_amd64</code>目录下的<code>golang.org/x/net/html.a</code>文件。</p><p>如果需要不同操作系统和CPU的交叉编译，改变<code>GOOS</code>和<code>GOARCH</code>即可达成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    fmt.Println(runtime.GOOS, runtime.GOARCH)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面以64位和32位环境分别执行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build gopl.io/ch10/cross</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./cross</span><br>darwin amd64<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">GOARCH=386 go build gopl.io/ch10/cross</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./cross</span><br>darwin 386<br></code></pre></td></tr></table></figure><p>有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或提供为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释注释可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build linux darwin</span><br></code></pre></td></tr></table></figure><p>在包声明和包注释的前面，该构建注释参数告诉go build只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。<br>下面的构建注释则表示不编译这个文件：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build ignore</span><br></code></pre></td></tr></table></figure><p>详细细节参考go&#x2F;build包的构建约束部分的文档。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc go/build</span><br></code></pre></td></tr></table></figure><h1 id="包文档"><a href="#包文档" class="headerlink" title="包文档"></a>包文档</h1><p>包的第一行，应该是包的摘要说明，紧接着应该是包的声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Copyright 2018 The Go Authors. All rights reserved.</span><br><span class="hljs-comment">// Use of this source code is governed by a BSD-style</span><br><span class="hljs-comment">// license that can be found in the LICENSE file.</span><br><br><span class="hljs-keyword">package</span> fmt<br></code></pre></td></tr></table></figure><p>这里是fmt包的其中一个注释，第一个是版权说明，接下来是包注释。</p><p>如果包注释过于长，可以另起一个doc文件，专门写包注释，如fmt包中的doc.go。<br>通常保存包注释的文件，命名为doc.go。</p><h2 id="go-doc"><a href="#go-doc" class="headerlink" title="go doc"></a>go doc</h2><p><code>go doc</code>命令是打印包注释以及每个成员的注释。<br>下面是time包的注释：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc time</span><br>package time // import &quot;time&quot;<br><br>Package time provides functionality for measuring and displaying time.<br><br>The calendrical calculations always assume a Gregorian calendar, with no leap<br>seconds.<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Monotonic Clocks</span><br><br>Operating systems provide both a “wall clock,” which is subject to changes<br>for clock synchronization, and a “monotonic clock,” which is not. The general<br>rule is that the wall clock is for telling time and the monotonic clock is for<br>measuring time. Rather than split the API, in this package the Time returned by<br>time.Now contains both a wall clock reading and a monotonic clock reading; later<br>time-telling operations use the wall clock reading, but later time-measuring<br>operations, specifically comparisons and subtractions, use the monotonic clock<br>reading.<br><br>For example, this code always computes a positive elapsed time of approximately<br>20 milliseconds, even if the wall clock is changed during the operation being<br>timed:<br><br>    start := time.Now()<br>    ... operation that takes 20 milliseconds ...<br>    t := time.Now()<br>    elapsed := t.Sub(start)<br><br>Other idioms, such as time.Since(start), time.Until(deadline), and<br>time.Now().Before(deadline), are similarly robust against wall clock resets.<br><br>The rest of this section gives the precise details of how operations use<br>monotonic clocks, but understanding those details is not required to use this<br>package.<br><br>The Time returned by time.Now contains a monotonic clock reading. If Time t<br>has a monotonic clock reading, t.Add adds the same duration to both the wall<br>clock and monotonic clock readings to compute the result. Because t.AddDate(y,<br>m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always<br>strip any monotonic clock reading from their results. Because t.In, t.Local,<br>and t.UTC are used for their effect on the interpretation of the wall time,<br>they also strip any monotonic clock reading from their results. The canonical<br>way to strip a monotonic clock reading is to use t = t.Round(0).<br><br>If Times t and u both contain monotonic clock readings, the operations<br>t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out using the<br>monotonic clock readings alone, ignoring the wall clock readings. If either t or<br>u contains no monotonic clock reading, these operations fall back to using the<br>wall clock readings.<br><br>On some systems the monotonic clock will stop if the computer goes to sleep.<br>On such a system, t.Sub(u) may not accurately reflect the actual time that<br>passed between t and u.<br><br>Because the monotonic clock reading has no meaning outside the current process,<br>the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON,<br>and t.MarshalText omit the monotonic clock reading, and t.Format provides<br>no format for it. Similarly, the constructors time.Date, time.Parse,<br>time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode,<br>t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with<br>no monotonic clock reading.<br><br>The monotonic clock reading exists only in Time values. It is not a part of<br>Duration values or the Unix times returned by t.Unix and friends.<br><br>Note that the Go == operator compares not just the time instant but also the<br>Location and the monotonic clock reading. See the documentation for the Time<br>type for a discussion of equality testing for Time values.<br><br>For debugging, the result of t.String does include the monotonic clock<br>reading if present. If t != u because of different monotonic clock readings,<br>that difference will be visible when printing t.String() and u.String().<br><br>const Layout = &quot;01/02 03:04:05PM &#x27;06 -0700&quot; ...<br>const Nanosecond Duration = 1 ...<br>func After(d Duration) &lt;-chan Time<br>func Sleep(d Duration)<br>func Tick(d Duration) &lt;-chan Time<br>type Duration int64<br>    func ParseDuration(s string) (Duration, error)<br>    func Since(t Time) Duration<br>    func Until(t Time) Duration<br>type Location struct&#123; ... &#125;<br>    var Local *Location = &amp;localLoc<br>    var UTC *Location = &amp;utcLoc<br>    func FixedZone(name string, offset int) *Location<br>    func LoadLocation(name string) (*Location, error)<br>    func LoadLocationFromTZData(name string, data []byte) (*Location, error)<br>type Month int<br>    const January Month = 1 + iota ...<br>type ParseError struct&#123; ... &#125;<br>type Ticker struct&#123; ... &#125;<br>    func NewTicker(d Duration) *Ticker<br>type Time struct&#123; ... &#125;<br>    func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time<br>    func Now() Time<br>    func Parse(layout, value string) (Time, error)<br>    func ParseInLocation(layout, value string, loc *Location) (Time, error)<br>    func Unix(sec int64, nsec int64) Time<br>    func UnixMicro(usec int64) Time<br>    func UnixMilli(msec int64) Time<br>type Timer struct&#123; ... &#125;<br>    func AfterFunc(d Duration, f func()) *Timer<br>    func NewTimer(d Duration) *Timer<br>type Weekday int<br>    const Sunday Weekday = iota ...<br></code></pre></td></tr></table></figure><p>以及单独查看某个成员的注释文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc time.since</span><br>package time // import &quot;time&quot;<br><br>func Since(t Time) Duration<br>    Since returns the time elapsed since t. It is shorthand for<br>    time.Now().Sub(t).<br></code></pre></td></tr></table></figure><p>还可以查看成员的方法的注释文档：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc time.Duration.Seconds</span><br>package time // import &quot;time&quot;<br><br>func (d Duration) Seconds() float64<br>    Seconds returns the duration as a floating point number of seconds.<br></code></pre></td></tr></table></figure><p>该命令不需要输入完整的包导入路径和正确的大小写。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go doc time.since</span><br>package time // import &quot;time&quot;<br><br>func Since(t Time) Duration<br>    Since returns the time elapsed since t. It is shorthand for<br>    time.Now().Sub(t).<br><br>wer:~ huangfuwang$ go doc json.decode<br>package json // import &quot;encoding/json&quot;<br><br>func (dec *Decoder) Decode(v any) error<br>    Decode reads the next JSON-encoded value from its input and stores it in the<br>    value pointed to by v.<br><br>    See the documentation for Unmarshal for details about the conversion of JSON<br>    into a Go value.<br></code></pre></td></tr></table></figure><h2 id="godoc"><a href="#godoc" class="headerlink" title="godoc"></a>godoc</h2><p><code>godoc</code>命令提供可以相互交叉引用的HTML页面，但是包含和go doc命令相同以及更多的信息。<br><code>godoc</code>的在线服务 <a href="https://godoc.org/">https://godoc.org</a> ，包含了成千上万开源包的检索工具。<br><code>godoc</code>支持<code>-play</code>命令行选项，可以启动playground功能，极大方便了对接口的调试。<br>从go1.13开始，<code>godoc</code>将不再内置。<br>下面是安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go install golang.org/x/tools/cmd/godoc@latest</span><br></code></pre></td></tr></table></figure><p>2021年末，godoc工具也被标记为deprecated了。<br>可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 <a href="http://localhost:8000/pkg">http://localhost:8000/pkg</a> 页面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">godoc -http :8000</span><br></code></pre></td></tr></table></figure><p><code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果。</p><h1 id="内部包"><a href="#内部包" class="headerlink" title="内部包"></a>内部包</h1><p>我们已知，没有导出标志符的只能在包内访问，有导出标志符的对任意可见。<br>但是，中间状态也是很有用的，即可见又不可见，对信任的包可见，对其它不可见。<br>例如，将包拆分成大小不一更容易维护的子包，不想暴露所有的子包，又想子包内共享通用的处理包。<br>或者新写的包某个不太成熟的接口，只想暴露给某些特定的用户。</p><p>为了满足这种需求，Go语言的构建工具对包含<code>internal</code>的包导入路径进行了特殊处理，这种包叫<code>internal</code>包。<br><code>internal</code>包只能被和<code>internal</code>包共同父目录的包所导入。<br>例如，net&#x2F;http&#x2F;internal&#x2F;chunked内部包只能被net&#x2F;http&#x2F;httputil或net&#x2F;http包导入，但是不能被net&#x2F;url包导入。不过net&#x2F;url包却可以导入net&#x2F;http&#x2F;httputil包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">net/http<br>net/http/internal/chunked<br>net/http/httputil<br>net/url<br></code></pre></td></tr></table></figure><h1 id="go-list"><a href="#go-list" class="headerlink" title="go list"></a>go list</h1><p><code>go list</code>命令可以查询可用包的信息。<br>最简单的用法是验证包是否在工作区：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list github.com/go-sql-driver/mysql</span><br>github.com/go-sql-driver/mysql<br></code></pre></td></tr></table></figure><p>存在，则打印出导入路径。<br>打印出工作区所有包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list ...</span><br>archive/tar<br>archive/zip<br>bufio<br>bytes<br>cmd/addr2line<br>cmd/api<br>cmd/asm<br>...<br></code></pre></td></tr></table></figure><p>打印出工作区特定目录下的所有包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list cmd/...</span><br>cmd/addr2line<br>cmd/api<br>cmd/asm<br></code></pre></td></tr></table></figure><p>与某一字符串相关的包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list ...xml...</span><br>encoding/xml<br></code></pre></td></tr></table></figure><p><code>go list -json</code>可以以json格式打印出包的元信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list -json <span class="hljs-built_in">hash</span></span><br>&#123;<br>&quot;Dir&quot;: &quot;/usr/local/go/src/hash&quot;,<br>&quot;ImportPath&quot;: &quot;hash&quot;,<br>&quot;Name&quot;: &quot;hash&quot;,<br>&quot;Doc&quot;: &quot;Package hash provides interfaces for hash functions.&quot;,<br>&quot;Target&quot;: &quot;/usr/local/go/pkg/darwin_amd64/hash.a&quot;,<br>&quot;Root&quot;: &quot;/usr/local/go&quot;,<br>&quot;Match&quot;: [<br>&quot;hash&quot;<br>],<br>&quot;Goroot&quot;: true,<br>&quot;Standard&quot;: true,<br>&quot;GoFiles&quot;: [<br>&quot;hash.go&quot;<br>],<br>&quot;Imports&quot;: [<br>&quot;io&quot;<br>],<br>&quot;Deps&quot;: [<br>&quot;errors&quot;,<br>&quot;internal/abi&quot;,<br>&quot;internal/bytealg&quot;,<br>&quot;internal/cpu&quot;,<br>&quot;internal/goarch&quot;,<br>&quot;internal/goexperiment&quot;,<br>&quot;internal/goos&quot;,<br>&quot;internal/race&quot;,<br>&quot;internal/reflectlite&quot;,<br>&quot;internal/unsafeheader&quot;,<br>&quot;io&quot;,<br>&quot;runtime&quot;,<br>&quot;runtime/internal/atomic&quot;,<br>&quot;runtime/internal/math&quot;,<br>&quot;runtime/internal/sys&quot;,<br>&quot;sync&quot;,<br>&quot;sync/atomic&quot;,<br>&quot;unsafe&quot;<br>],<br>&quot;XTestGoFiles&quot;: [<br>&quot;example_test.go&quot;,<br>&quot;marshal_test.go&quot;<br>],<br>&quot;XTestImports&quot;: [<br>&quot;bytes&quot;,<br>&quot;crypto/md5&quot;,<br>&quot;crypto/sha1&quot;,<br>&quot;crypto/sha256&quot;,<br>&quot;crypto/sha512&quot;,<br>&quot;encoding&quot;,<br>&quot;encoding/hex&quot;,<br>&quot;fmt&quot;,<br>&quot;hash&quot;,<br>&quot;hash/adler32&quot;,<br>&quot;hash/crc32&quot;,<br>&quot;hash/crc64&quot;,<br>&quot;hash/fnv&quot;,<br>&quot;log&quot;,<br>&quot;testing&quot;<br>]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>go list  -f </code> 可以按模版打印出包：<br>下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list -f <span class="hljs-string">&#x27;&#123;&#123;join .Deps &quot; &quot;&#125;&#125;&#x27;</span> strconv</span><br>errors internal/abi internal/bytealg internal/cpu internal/goarch internal/goexperiment internal/goos internal/reflectlite internal/unsafeheader math math/bits runtime runtime/internal/atomic runtime/internal/math runtime/internal/sys unicode/utf8 unsafe<br></code></pre></td></tr></table></figure><p>如果是在windows，注意增加转义字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list -f <span class="hljs-string">&quot;&#123;&#123;join .Deps \&quot; \&quot;&#125;&#125;&quot;</span> strconv</span><br></code></pre></td></tr></table></figure><p>打印compress子目录下所有包的依赖包列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list -f <span class="hljs-string">&#x27;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#x27;</span> compress/...</span><br>compress/bzip2 -&gt; bufio io sort<br>compress/flate -&gt; bufio errors fmt io math math/bits sort strconv sync<br>compress/gzip -&gt; bufio compress/flate encoding/binary errors fmt hash/crc32 io time<br>compress/lzw -&gt; bufio errors fmt io<br>compress/zlib -&gt; bufio compress/flate encoding/binary errors fmt hash hash/adler32 io<br></code></pre></td></tr></table></figure><p>同样的，在windows下，增加转义字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go list -f <span class="hljs-string">&quot;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports \&quot; \&quot;&#125;&#125;&quot;</span> compress/...</span><br></code></pre></td></tr></table></figure><h1 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 10.4：</strong> 创建一个工具，根据命令行指定的参数，报告工作区所有依赖指定包的其它包集合。提示：你需要运行go list命令两次，一次用于初始化包，一次用于所有包。你可能需要用encoding&#x2F;json（§4.5）包来分析输出的JSON格式的信息。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> pkg <span class="hljs-keyword">struct</span> &#123;<br>ImportPath <span class="hljs-type">string</span><br>Deps       []<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pkgs</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> ([]pkg, <span class="hljs-type">error</span>) &#123;<br>output, err := exec.Command(<span class="hljs-string">&quot;go&quot;</span>, <span class="hljs-built_in">append</span>([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;-json&quot;</span>&#125;, args...)...).Output()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">var</span> pkgs []pkg<br>dec := json.NewDecoder(bytes.NewReader(output))<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> pkg pkg<br><span class="hljs-keyword">if</span> err := dec.Decode(&amp;pkg); err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>pkgs = <span class="hljs-built_in">append</span>(pkgs, pkg)<br>&#125;<br><span class="hljs-keyword">return</span> pkgs, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ips, err := pkgs(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>deps, err := pkgs([]<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;all&quot;</span>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> _, dep := <span class="hljs-keyword">range</span> deps &#123;<br><span class="hljs-keyword">for</span> _, depip := <span class="hljs-keyword">range</span> dep.Deps &#123;<br><span class="hljs-keyword">for</span> _, ip := <span class="hljs-keyword">range</span> ips &#123;<br><span class="hljs-keyword">if</span> ip.ImportPath == depip &#123;<br>fmt.Println(dep.ImportPath)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.6. 包的命名</title>
      <link href="/posts/26ffbeb103e4/"/>
      <url>/posts/26ffbeb103e4/</url>
      
        <content type="html"><![CDATA[<p>包的命名规则：</p><ul><li>命名尽量短小</li><li>要尽量避免与常用的局部变量重复</li><li>尽量使用单数形式</li><li>避免与预定义类型冲突，可以复数形式</li><li>避免与关键字冲突，可以复数形式</li><li>避免包名歧义</li></ul><p>当设计一个包时，要考虑包名与方法&#x2F;函数&#x2F;成员变量名配合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">flag.Intbytes.Equalhttp.Get<br></code></pre></td></tr></table></figure><p>也有可能包名与方法、函数和成员名重复。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">rand.Rand<br></code></pre></td></tr></table></figure><p>所以，包名要尽量简洁短小。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.5. 包的匿名导入</title>
      <link href="/posts/85c6d629ce42/"/>
      <url>/posts/85c6d629ce42/</url>
      
        <content type="html"><![CDATA[<p>如果导入一个包而不去使用这个包，那么就会导致编译错误。<br>但是只想使用导入包的而产生的副作用，如“计算包级变量的初始化表达式和执行导入包的init初始化函数”。<br>这时候，需要抑制该编译错误，可以 使用<code>—</code>下划线空白标识符，重命名导入的包。<br>空白标识符表示，不能被访问。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">improt _ <span class="hljs-string">&quot;image/png&quot;</span><br></code></pre></td></tr></table></figure><p>这种行为被称为<code>包的匿名导入</code>。<br>它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。</p><p>下面是使用匿名导入该特性的例子。<br>标准库的image图像包包含了一个Decode函数，用于从io.Reader接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用image.Decode很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/jpeg&quot;</span><br>_ <span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> err := toJPEG(os.Stdin, os.Stdout); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;jpeg:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toJPEG</span><span class="hljs-params">(in io.Reader, out io.Writer)</span></span> <span class="hljs-type">error</span> &#123;<br>img, kind, err := image.Decode(in)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;input format=%v\n&quot;</span>, kind)<br><span class="hljs-keyword">return</span> jpeg.Encode(out, img, &amp;jpeg.Options&#123;Quality: <span class="hljs-number">95</span>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>对之前mandelbrot进行打印：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> build <span class="hljs-keyword">go</span>-learn-gopl/ch/ch3/mandelbrot<br>$ <span class="hljs-keyword">go</span> build <span class="hljs-keyword">go</span>-learn-gopl/ch/ch10/jpeg<br>$ ./mandelbrot | ./jpeg &gt; mandelbrot.jpeg<br>input format=png<br></code></pre></td></tr></table></figure><p>如果在导入包路径中没有<code>_ &quot;image/png&quot;</code>，虽然程序可以编译和运行， 但代码执行就会报错。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> build <span class="hljs-keyword">go</span>-learn-gopl/ch/ch10/jpeg<br>$ ./mandelbrot | ./jpeg &gt; mandelbrot.jpeg<br>jpeg:image: unknown format<br></code></pre></td></tr></table></figure><p>标准库还提供了GIF、PNG和JPEG等格式图像的解码器，但为了保持程序不至于太大，很多解码器并未包含，需要根据需求明确支持的格式。<br>image.Decode函数在解码时会依次查询支持的格式列表。<br>每个格式驱动列表的每个入口指定了四件事情：<br>格式的名称；<br>一个用于描述这种图像数据开头部分模式的字符串，用于解码器检测识别；<br>一个Decode函数用于完成解码图像工作；<br>一个DecodeConfig函数用于解码图像的大小和颜色空间的信息。</p><p>每个驱动入口是通过调用image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如image&#x2F;png包是这样注册的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> png <span class="hljs-comment">// image/png</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decode</span><span class="hljs-params">(r io.Reader)</span></span> (image.Image, <span class="hljs-type">error</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DecodeConfig</span><span class="hljs-params">(r io.Reader)</span></span> (image.Config, <span class="hljs-type">error</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">const</span> pngHeader = <span class="hljs-string">&quot;\x89PNG\r\n\x1a\n&quot;</span><br>    image.RegisterFormat(<span class="hljs-string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)<br>&#125;<br></code></pre></td></tr></table></figure><p>所以主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。</p><p>数据库包database&#x2F;sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;database/sql&quot;</span><br>    _ <span class="hljs-string">&quot;github.com/lib/pq&quot;</span>              <span class="hljs-comment">// enable support for Postgres</span><br>    _ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span> <span class="hljs-comment">// enable support for MySQL</span><br>)<br><br>db, err = sql.Open(<span class="hljs-string">&quot;postgres&quot;</span>, dbname) <span class="hljs-comment">// OK</span><br>db, err = sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, dbname)    <span class="hljs-comment">// OK</span><br>db, err = sql.Open(<span class="hljs-string">&quot;sqlite3&quot;</span>, dbname)  <span class="hljs-comment">// returns error: unknown driver &quot;sqlite3”</span><br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 10.1：</strong> 扩展jpeg程序，以支持任意图像格式之间的相互转换，使用image.Decode检测支持的格式类型，然后通过flag命令行标志参数选择输出的格式。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;image/jpeg&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> formatFlag = flag.String(<span class="hljs-string">&quot;format&quot;</span>, <span class="hljs-string">&quot;jpeg&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>img, king, err := image.Decode(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;input format=%v\n&quot;</span>, king)<br><span class="hljs-keyword">switch</span> *formatFlag &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;jpeg&quot;</span>:<br><span class="hljs-keyword">if</span> err := jpeg.Encode(os.Stdout, img, &amp;jpeg.Options&#123;Quality: <span class="hljs-number">100</span>&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;png&quot;</span>:<br><span class="hljs-keyword">if</span> err := png.Encode(os.Stdout, img); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gif&quot;</span>:<br><span class="hljs-keyword">if</span> err := gif.Encode(os.Stdout, img, &amp;gif.Options&#123;&#125;); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 10.2：</strong> 设计一个通用的压缩文件读取框架，用来读取ZIP（archive&#x2F;zip）和POSIX tar（archive&#x2F;tar）格式压缩的文档。使用类似上面的注册技术来扩展支持不同的压缩格式，然后根据需要通过匿名导入选择导入要支持的压缩格式的驱动包。<br>解：<br>archive&#x2F;archive.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> archive<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> FileHeader <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Size <span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">List</span><span class="hljs-params">(f *os.File)</span></span> ([]FileHeader, <span class="hljs-type">error</span>) &#123;<br>format, err := match(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> format.List(f)<br>&#125;<br><br><span class="hljs-keyword">type</span> Format <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-type">string</span><br>Str    <span class="hljs-type">string</span><br>Offset <span class="hljs-type">int</span><br>List   <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*os.File)</span></span> ([]FileHeader, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> formats []Format<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitFormats</span><span class="hljs-params">(format Format)</span></span> &#123;<br>formats = <span class="hljs-built_in">append</span>(formats, format)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">match</span><span class="hljs-params">(f *os.File)</span></span> (*Format, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">for</span> _, format := <span class="hljs-keyword">range</span> formats &#123;<br>f.Seek(<span class="hljs-number">0</span>, io.SeekStart)<br>r := bufio.NewReader(f)<br>b, err := r.Peek(format.Offset + <span class="hljs-built_in">len</span>(format.Str))<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &amp;&amp; bytes.Equal([]<span class="hljs-type">byte</span>(format.Str), b[format.Offset:]) &#123;<br>f.Seek(<span class="hljs-number">0</span>, io.SeekStart)<br><span class="hljs-keyword">return</span> &amp;format, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;unknown format&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>archive&#x2F;tar.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tar<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;archive/tar&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex10/ex10.2/archive&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>archive.InitFormats(archive.Format&#123;<br>Name:   <span class="hljs-string">&quot;tar&quot;</span>,<br>Str:    <span class="hljs-string">&quot;ustar\x0000&quot;</span>,<br>Offset: <span class="hljs-number">257</span>,<br>List:   list,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">list</span><span class="hljs-params">(f *os.File)</span></span> ([]archive.FileHeader, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> headers []archive.FileHeader<br>tr := tar.NewReader(f)<br><span class="hljs-keyword">for</span> &#123;<br>hdr, err := tr.Next()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>headers = <span class="hljs-built_in">append</span>(headers, archive.FileHeader&#123;<br>Name: hdr.Name,<br>Size: <span class="hljs-type">uint64</span>(hdr.Size),<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> headers, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>archive&#x2F;zip.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> zip<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;archive/zip&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex10/ex10.2/archive&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>archive.InitFormats(archive.Format&#123;<br>Name:   <span class="hljs-string">&quot;zip&quot;</span>,<br>Str:    <span class="hljs-string">&quot;PK\x03\x04&quot;</span>,<br>Offset: <span class="hljs-number">0</span>,<br>List:   list,<br>&#125;)<br>archive.InitFormats(archive.Format&#123;<br>Name:   <span class="hljs-string">&quot;zip&quot;</span>,<br>Str:    <span class="hljs-string">&quot;PK\x05\x06&quot;</span>,<br>Offset: <span class="hljs-number">0</span>,<br>List:   list,<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">list</span><span class="hljs-params">(f *os.File)</span></span> ([]archive.FileHeader, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> headers []archive.FileHeader<br>r, err := zip.OpenReader(f.Name())<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> r.Close()<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> r.File &#123;<br>headers = <span class="hljs-built_in">append</span>(headers, archive.FileHeader&#123;<br>Name: f.Name,<br>Size: f.UncompressedSize64,<br>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> headers, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>cmd&#x2F;main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;archive/tar&quot;</span><br><span class="hljs-string">&quot;archive/zip&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> tbuf bytes.Buffer<br><span class="hljs-keyword">var</span> zbuf bytes.Buffer<br>tw := tar.NewWriter(&amp;tbuf)<br>zw := zip.NewWriter(&amp;zbuf)<br><br><span class="hljs-keyword">var</span> files = []<span class="hljs-keyword">struct</span> &#123;<br>Name, Body <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;readme.txt&quot;</span>, <span class="hljs-string">&quot;This archive contains some text files.&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;gopher.txt&quot;</span>, <span class="hljs-string">&quot;Gopher names:\nGeorge\nGeoffrey\nGonzo&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;todo.txt&quot;</span>, <span class="hljs-string">&quot;Get animal handling license.&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br><span class="hljs-comment">// tar</span><br>hdr := &amp;tar.Header&#123;<br>Name: file.Name,<br>Mode: <span class="hljs-number">0600</span>,<br>Size: <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(file.Body)),<br>&#125;<br><span class="hljs-keyword">if</span> err := tw.WriteHeader(hdr); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> _, err := tw.Write([]<span class="hljs-type">byte</span>(file.Body)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// zip</span><br>f, err := zw.Create(file.Name)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>_, err = f.Write([]<span class="hljs-type">byte</span>(file.Body))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Close</span><br><span class="hljs-keyword">if</span> err := tw.Close(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := zw.Close(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// tar</span><br>tf, err := os.Create(<span class="hljs-string">&quot;./ex/ex10/ex10.2/cmd/tar.tar&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> tf.Close()<br>_, err = io.Copy(tf, &amp;tbuf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// zip</span><br>zf, err := os.Create(<span class="hljs-string">&quot;./ex/ex10/ex10.2/cmd/zip.zip&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> zf.Close()<br>_, err = io.Copy(zf, &amp;zbuf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>archive_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> archive_test<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ex/ex10/ex10.2/archive&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><br>_ <span class="hljs-string">&quot;go-learn-gopl/ex/ex10/ex10.2/archive/tar&quot;</span><br>_ <span class="hljs-string">&quot;go-learn-gopl/ex/ex10/ex10.2/archive/zip&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-comment">// tar</span><br>tf, err := os.Open(<span class="hljs-string">&quot;cmd/tar.tar&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> tf.Close()<br>theaders, err := archive.List(tf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">var</span> tgot []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, h := <span class="hljs-keyword">range</span> theaders &#123;<br>tgot = <span class="hljs-built_in">append</span>(tgot, h.Name)<br>&#125;<br>sort.Strings(tgot)<br><br><span class="hljs-comment">// zip</span><br>zf, err := os.Open(<span class="hljs-string">&quot;cmd/zip.zip&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> zf.Close()<br>zheaders, err := archive.List(zf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">var</span> zgot []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, h := <span class="hljs-keyword">range</span> zheaders &#123;<br>zgot = <span class="hljs-built_in">append</span>(zgot, h.Name)<br>&#125;<br>sort.Strings(zgot)<br><br><span class="hljs-comment">// test</span><br>want := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;readme.txt&quot;</span>, <span class="hljs-string">&quot;gopher.txt&quot;</span>, <span class="hljs-string">&quot;todo.txt&quot;</span>&#125;<br>sort.Strings(want)<br><br><span class="hljs-keyword">if</span> !equal(tgot, want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;tar reading err&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> !equal(zgot, want) &#123;<br>t.Errorf(<span class="hljs-string">&quot;zip reading err&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(a, b []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(a) != <span class="hljs-built_in">len</span>(b) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br><span class="hljs-keyword">if</span> v != b[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.4. 导入声明</title>
      <link href="/posts/7c1cbb35e653/"/>
      <url>/posts/7c1cbb35e653/</url>
      
        <content type="html"><![CDATA[<p>每个导入声明可以单独指定导入路径，也可以通过圆括号同时导入多个导入路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><br><br>improt (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>导入的包之间可以通过添加空行来分组。通常将来自不同组织的包进行独立分组。</p><p>包的导入顺序无关紧要，但是每个分组中一般会根据字符串顺序排序。<br>（goimports和gofmt工具可以将不同分组导入的包进行独立排序。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;html/template&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br><br>    <span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br>    <span class="hljs-string">&quot;golang.org/x/net/ipv4&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>如果要导入包名相同的两个包，可以给其中的一个包重命名（别名）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;orypto/rand&quot;</span><br>mrand <span class="hljs-string">&quot;math/rand&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>导入包的重命名只影响当前的源文件。</p><p>导入包的重命名不单是解决包名冲突，还可以简化包名，也可以避免与源码中常量命名重复。</p><p>每个导入声明语句都明确指定了当前包与被导入包之间的依赖关系。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.3. 包声明</title>
      <link href="/posts/376c63460620/"/>
      <url>/posts/376c63460620/</url>
      
        <content type="html"><![CDATA[<p>每个go语言源码文件开头必须是包声明语句。<br>包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。</p><p>如 math&#x2F;rand包的每个源码文件开头都是package rand。</p><p>通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。</p><p>关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。</p><ul><li><p>第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。</p><ul><li>名字为main的包是给go build构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</li></ul></li><li><p>第二个例外，包所在的目录中可能有一些文件名是以test.go为后缀的Go源文件，并且这些源文件声明的包名也是以_test为后缀名。</p><ul><li>一种是普通包，另外一种测试的外部拓展包。</li><li>所有以_test为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖。</li></ul></li><li><p>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如”gopkg.in&#x2F;yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.2. 导入路径</title>
      <link href="/posts/ce5416f3abff/"/>
      <url>/posts/ce5416f3abff/</url>
      
        <content type="html"><![CDATA[<p>每个包是由一个全局唯一的字符串所标识的导入路径定位。</p><p>import语句中的字符串就是导入路径。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br><br>    <span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><br>    <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。</p><p>为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10.1. 包简介</title>
      <link href="/posts/a912c21440d0/"/>
      <url>/posts/a912c21440d0/</url>
      
        <content type="html"><![CDATA[<p>任何包系统的设计目的离不开，抽象，封装和复用。<br>为了简化大型程序的设计和维护工作，通过将一系列相关的特性放入一个独立的单元以理解和更新。<br>在每个单元更新时也同时保持和程序中其它单元的相对独立性。<br>这种模块化的特性允许每个包可以被其它不同的项目共享和重用，在项目范围内，甚至全世界范围内统一分发和复用。</p><p>包还通过控制包内名字的可见性和是否导出来实现封装特性。</p><p>Go语言的闪电般的编译速度主要得益于三个语言特性。</p><ul><li>所有导入的包必须在每个文件的开头显式声明<br>  这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li><li>禁止包的环状依赖<br>  因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li><li>编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。</li></ul><p>因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第十章 包和工具</title>
      <link href="/posts/94532dfae374/"/>
      <url>/posts/94532dfae374/</url>
      
        <content type="html"><![CDATA[<p>本章主要讲go语言的包及其工具。<br>查询Go语言下的包数量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> list std | wc -l<br><span class="hljs-number">240</span><br></code></pre></td></tr></table></figure><p><a href="/posts/a912c21440d0/">10.1. 包简介</a><br><a href="/posts/ce5416f3abff/">10.2. 导入路径</a><br><a href="/posts/376c63460620/">10.3. 包声明</a><br><a href="/posts/7c1cbb35e653/">10.4. 导入声明</a><br><a href="/posts/85c6d629ce42/">10.5. 包的匿名导入</a><br><a href="">10.6. 包和命名</a><br><a href="/posts/c1eef8565635/">10.7. 工具</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.8. Goroutine和线程</title>
      <link href="/posts/85a231e79892/"/>
      <url>/posts/85a231e79892/</url>
      
        <content type="html"><![CDATA[<p>本章主要内容：Goroutine和线程的区别。</p><h1 id="9-8-1-动态栈"><a href="#9-8-1-动态栈" class="headerlink" title="9.8.1 动态栈"></a>9.8.1 动态栈</h1><p>每个OS线程都拥有一个固定大小的内存块（一般为2MB）作为栈，该栈用于存储函数调用或挂起（调用其它函数时）的函数内部变量。<br>Goroutine的栈大小并不是固定的，可以根据需要动态伸缩的。</p><p>Goroutine会以很小的栈开始生命周期，一般为2KB。</p><p>与OS线程一样，Goroutine的栈同样存储其活跃或挂起的函数内部变量。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 9.4:</strong> 创建一个流水线程序，支持用channel连接任意数量的goroutine，在跑爆内存之前，可以创建多少流水线阶段？一个变量通过整个流水线需要用多久？<br>解：<br>pipeline.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> pipeline<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pipeline</span><span class="hljs-params">(stage <span class="hljs-type">int</span>)</span></span> (<span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">interface</span>&#123;&#125;, &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;) &#123;<br><span class="hljs-keyword">if</span> stage &lt; <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br>in := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br>out := in<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; stage; i++ &#123;<br>prev := out<br>next := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(prev, next <span class="hljs-keyword">chan</span> <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">range</span> prev &#123;<br>next &lt;- n<br>&#125;<br><span class="hljs-built_in">close</span>(next)<br>&#125;(prev, next)<br>out = next<br>&#125;<br><span class="hljs-keyword">return</span> in, out<br>&#125;<br></code></pre></td></tr></table></figure><p>pipeline_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> pipeline<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPipeline</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>in, out := pipeline(<span class="hljs-number">3</span>)<br>in &lt;- <span class="hljs-number">1</span><br>fmt.Println(&lt;-out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bench</span><span class="hljs-params">(b *testing.B, stages <span class="hljs-type">int</span>)</span></span> &#123;<br>in, out := pipeline(stages)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>in &lt;- <span class="hljs-number">1</span><br>&#125;()<br>&lt;-out<br>&#125;<br><span class="hljs-built_in">close</span>(in)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPipeline1</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPipeline1024</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, <span class="hljs-number">1024</span>)<br>&#125;<br><br><span class="hljs-comment">// 1G</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPipeline1048576</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, <span class="hljs-number">1048576</span>)<br>&#125;<br><br><span class="hljs-comment">// 5G</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPipeline2097152</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, <span class="hljs-number">2097152</span>)<br>&#125;<br><br><span class="hljs-comment">// 10G</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPipeline4194304</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, <span class="hljs-number">4194304</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex9/ex9.4</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkPipeline1</span><br><span class="hljs-comment">BenchmarkPipeline1-8          1467734       821.2 ns/op</span><br><span class="hljs-comment">BenchmarkPipeline1024</span><br><span class="hljs-comment">BenchmarkPipeline1024-8          2932    419134 ns/op</span><br><span class="hljs-comment">BenchmarkPipeline1048576</span><br><span class="hljs-comment">BenchmarkPipeline1048576-8          13241682720 ns/op</span><br><span class="hljs-comment">BenchmarkPipeline2097152</span><br><span class="hljs-comment">BenchmarkPipeline2097152-8          14608015112 ns/op</span><br><span class="hljs-comment">BenchmarkPipeline4194304</span><br><span class="hljs-comment">BenchmarkPipeline4194304-8          127193923912 ns/op</span><br><span class="hljs-comment">PASS</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><h1 id="9-8-2-Goroutine调度"><a href="#9-8-2-Goroutine调度" class="headerlink" title="9.8.2 Goroutine调度"></a>9.8.2 Goroutine调度</h1><p><strong>OS线程调度：</strong><br>OS线程会被操作系统内核调度。<br>每过几毫秒，一个硬件计时器会中断处理器，会调用一个叫作scheduler的内核函数。<br>该内核函数会挂起当前执行的线程，并保存该线程的寄存器内容，检查线程列表并决定下次那些被挂起的线程可以运行，并从内存中恢复该线程的寄存器内容，然后恢复线程的执行。</p><p>也就是说保存用户线程的状态到内存中，恢复另一个线程到寄存器，然后更新调度器的数据。<br>这几步相对很慢，需要反复内存访问，并且会增加运行的cpu周期。</p><p><strong>Goroutine调度：</strong><br>Go的运行时包中有其自己的调度器，而非内核调度器，该调度器可以继续m:n的调度。<br>即可以在n个OS线程可以调度m个Goroutine。<br>Go调度器按程序独立，即只调度当前程序的Goroutine。</p><p>Go调度器工作内容与内核调度器类似的。</p><p>与OS线程调度不同的是，Go调度器并非使用硬件计时器，而是由Go语言编写的计时器。</p><p>Goroutine的调度方式不需要进入内核上下文，重新调度（唤醒）一个Goroutine的代价比调度一个线程要低得多。</p><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 9.5:</strong> 写一个有两个goroutine的程序，两个goroutine会向两个无buffer channel反复地发送ping-pong消息。这样的程序每秒可以支持多少次通信？<br>解：<br>pingpong.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> pingpong<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Pingpong</span><span class="hljs-params">(count <span class="hljs-type">int</span>)</span></span> &#123;<br>ping := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>pong := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>ping &lt;- <span class="hljs-string">&quot;ping&quot;</span><br>&lt;-pong<br>&#125;<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; count; i++ &#123;<br>&lt;-ping<br>pong &lt;- <span class="hljs-string">&quot;pong&quot;</span><br>&#125;<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><br>&lt;-done<br>&lt;-done<br><br><span class="hljs-built_in">close</span>(ping)<br><span class="hljs-built_in">close</span>(pong)<br><span class="hljs-built_in">close</span>(done)<br>&#125;<br></code></pre></td></tr></table></figure><p>pingpong_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> pingpong<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPingpong</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>Pingpong(b.N)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex9/ex9.5</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkPingpong</span><br><span class="hljs-comment">BenchmarkPingpong-8    2698485       432.1 ns/op</span><br><span class="hljs-comment">PASS</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="9-8-3-GOMAXPROCS"><a href="#9-8-3-GOMAXPROCS" class="headerlink" title="9.8.3 GOMAXPROCS"></a>9.8.3 GOMAXPROCS</h1><p>Go的调度器使用GOMAXPROCS的变量决定会有多少个OS线程来同时执行。<br>GOMAXPROCS为m:n中的n。<br>GOMAXPROCS的默认值为CPU的核心数。<br>如果程序在核心数为8的机器上运行，那么调度器一次会使用8个线程去调度程序。</p><p>在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。<br>在I&#x2F;O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计数在内。</p><p>可以使用GOMAXPROCS环境变量显式修改，或在运行时中用runtime.GOMAXPROCS函数修改。</p><p>下面是“黑客”程序，无限打印0和1。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">go</span> fmt.Print(<span class="hljs-number">0</span>)<br>fmt.Print(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">$ GOMAXPROCS=<span class="hljs-number">1</span> <span class="hljs-keyword">go</span> run hacker.<span class="hljs-keyword">go</span><br><span class="hljs-number">11111111111111111111111111111111111111111111110000000000000000000000000000111.</span>..<br>$ GOMAXPROCS=<span class="hljs-number">2</span> <span class="hljs-keyword">go</span> run hacker.<span class="hljs-keyword">go</span><br><span class="hljs-number">010101010100101010010101011010101001010110010101010100101010101010101001.</span>...<br></code></pre></td></tr></table></figure><p>第一次执行时，最多同时只有一个Goroutine被执行。<br>最开始只有main goroutine执行，会一直打印1，过一段时间后，GO调度器会将其设置为休眠，并唤醒另一个Goroutine，这时候开始打印很多0。在打印的时候，Goroutine是被调度到OS线程上执行的。<br>第二次执行时，最多同时有两个Goroutine被执行。<br>所以0和1会被相同频率打印，但是Goroutine的调度是受到很多因子影响的，如runtimed的不断发展演变，所以打印出的内容与理论上太相同，但是0和1的打印频率是差不多的。</p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><p><strong>练习9.6:</strong> 测试一下计算密集型的并发程序(练习8.5那样的)会被GOMAXPROCS怎样影响到。在你的电脑上最佳的值是多少？你的电脑CPU有多少个核心？<br>解：<br>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ex/ex9/ex9.6/mandelbrot&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>workers := runtime.GOMAXPROCS(<span class="hljs-number">-1</span>)<br>img := mandelbrot.ConcurrentRender(workers)<br>png.Encode(os.Stdout, img)<br>&#125;<br></code></pre></td></tr></table></figure><p>concurrent.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConcurrentRender</span><span class="hljs-params">(workers <span class="hljs-type">int</span>)</span></span> *image.RGBA &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><br>rows := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, height)<br><span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; height; row++ &#123;<br>rows &lt;- row<br>&#125;<br><span class="hljs-built_in">close</span>(rows)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; workers; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> py := <span class="hljs-keyword">range</span> rows &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br>img.Set(<br>px,<br>py,<br>mandelbrot(z),<br>)<br>&#125;<br>&#125;<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br><br><span class="hljs-keyword">return</span> img<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;<span class="hljs-number">255</span> - contrast*n&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br></code></pre></td></tr></table></figure><p>mandelbrot_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSerialRender</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>SerialRender()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">benchmarkConcurrentRender</span><span class="hljs-params">(b *testing.B, workers <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>ConcurrentRender(workers)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark1</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMaxProces</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, runtime.GOMAXPROCS(<span class="hljs-number">-1</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark8</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">8</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark16</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">16</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark32</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark64</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">64</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark128</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">128</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex8/ex8.5/mandelbrot</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkSerialRender</span><br><span class="hljs-comment">BenchmarkSerialRender-8          4 269136007 ns/op</span><br><span class="hljs-comment">Benchmark1</span><br><span class="hljs-comment">Benchmark1-8                     4 252338560 ns/op</span><br><span class="hljs-comment">BenchmarkMaxProces</span><br><span class="hljs-comment">BenchmarkMaxProces-8            12  88347559 ns/op</span><br><span class="hljs-comment">Benchmark8</span><br><span class="hljs-comment">Benchmark8-8                    13  85825956 ns/op</span><br><span class="hljs-comment">Benchmark16</span><br><span class="hljs-comment">Benchmark16-8                   18  90070427 ns/op</span><br><span class="hljs-comment">Benchmark32</span><br><span class="hljs-comment">Benchmark32-8                   15  99837822 ns/op</span><br><span class="hljs-comment">Benchmark64</span><br><span class="hljs-comment">Benchmark64-8                   12  93368396 ns/op</span><br><span class="hljs-comment">Benchmark128</span><br><span class="hljs-comment">Benchmark128-8                  12  93611058 ns/op</span><br><span class="hljs-comment">PASS</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="9-8-4-Goroutine没有ID号"><a href="#9-8-4-Goroutine没有ID号" class="headerlink" title="9.8.4 Goroutine没有ID号"></a>9.8.4 Goroutine没有ID号</h1><p>在大多数支持多线程的操作系统和程序语言中，每个线程都有自己特定的”id”，可以是interger值或内存地址。<br>有id的情况下，可以做线程本地存储，thread-local storage。</p><p>Goroutine是没有id号的。<br>我们也无法辨别goroutine。<br>这种设计是故意而为之的。<br>由于tls在大多数情况下会被滥用，如web server是使用支持tls的语言实现的，其很多函数会去寻找HTTP请求的信息，即它们会到其存储层（可能是tls）去查找。如同过于依赖全局变量的程序一样，会导致一种不健康的距离外的行为。<br>即函数行为不是由内部变量而决定，而是由其运行的线程决定的，导致函数行为并非能够预测的。</p><p>Go鼓励简单模式，这种模式使得函数行为的影响是显式的。使得程序是易读的，在给函数分配任务时，不用考虑Goroutine的身份信息影响到函数。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.7. 示例：并发的非阻塞缓存</title>
      <link href="/posts/582daaba3cd4/"/>
      <url>/posts/582daaba3cd4/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>本章节的例子为非阻塞缓存。<br>即缓存函数的返回结果，调用该函数时，只要返回已缓存的函数结果即可。</p><p>下面以httpGetBody函数做为缓存函数的样例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpGetBody</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">return</span> io.ReadAll(resp.Body)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>io.ReadAll</code>函数有两个返回值，一个为[]byte数组和一个错误结果。<br>这里使用interface{}接收[]byte，是为了通配各个函数的返回值。</p><h1 id="test工具包"><a href="#test工具包" class="headerlink" title="test工具包"></a>test工具包</h1><p>为了整合输入参数，进行串行和并发的需求，统一整合为memotest。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memotest<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpGetBody</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">return</span> io.ReadAll(resp.Body)<br>&#125;<br><br><span class="hljs-keyword">var</span> HTTPGetBody = httpGetBody<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incomingURLs</span><span class="hljs-params">()</span></span> &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> []<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;https://baidu.com&quot;</span>,<br><span class="hljs-string">&quot;https://jd.com&quot;</span>,<br><span class="hljs-string">&quot;https://taobao.com&quot;</span>,<br><span class="hljs-string">&quot;https://qq.com&quot;</span>,<br><span class="hljs-string">&quot;https://godoc.org&quot;</span>,<br><span class="hljs-string">&quot;https://baidu.com&quot;</span>,<br><span class="hljs-string">&quot;https://jd.com&quot;</span>,<br><span class="hljs-string">&quot;https://taobao.com&quot;</span>,<br><span class="hljs-string">&quot;https://qq.com&quot;</span>,<br><span class="hljs-string">&quot;https://godoc.org&quot;</span>,<br>&#125; &#123;<br>ch &lt;- url<br>&#125;<br><span class="hljs-built_in">close</span>(ch)<br>&#125;()<br><span class="hljs-keyword">return</span> ch<br>&#125;<br><br><span class="hljs-keyword">type</span> M <span class="hljs-keyword">interface</span> &#123;<br>Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sequential</span><span class="hljs-params">(t *testing.T, m M)</span></span> &#123;<br><span class="hljs-keyword">for</span> url := <span class="hljs-keyword">range</span> incomingURLs() &#123;<br>start := time.Now()<br>value, err := m.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s, %s, %d bytes\n&quot;</span>, url, time.Since(start), <span class="hljs-built_in">len</span>(value.([]<span class="hljs-type">byte</span>)))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Concurrent</span><span class="hljs-params">(t *testing.T, m M)</span></span> &#123;<br><span class="hljs-keyword">var</span> n sync.WaitGroup<br><span class="hljs-keyword">for</span> url := <span class="hljs-keyword">range</span> incomingURLs() &#123;<br>n.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> n.Done()<br>start := time.Now()<br>value, err := m.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s, %s, %d bytes\n&quot;</span>, url, time.Since(start), <span class="hljs-built_in">len</span>(value.([]<span class="hljs-type">byte</span>)))<br>&#125;(url)<br>&#125;<br>n.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>并为每个版本加入相同的test。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ch/ch9/memotest&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> httpGetBody = memotest.HTTPGetBody<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>m := New(httpGetBody)<br>memotest.Sequential(t, m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestConcurrent</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>m := New(httpGetBody)<br>memotest.Concurrent(t, m)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="初始版本"><a href="#初始版本" class="headerlink" title="初始版本"></a>初始版本</h1><p>下面为第一个“草稿”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package memo provides a concurrency-unsafe</span><br><span class="hljs-comment">// memoization of a function of type Func.</span><br><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>f     Func<br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result<br>&#125;<br><br><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>err   <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br><span class="hljs-keyword">return</span> &amp;Memo&#123;f, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>res, ok := memo.cache[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br>res.value, res.err = memo.f(key)<br>memo.cache[key] = res<br>&#125;<br><span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br></code></pre></td></tr></table></figure><p>串行测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> test -v -run=Test ./ch/ch9/memo1<br>=== RUN   Test<br>https:<span class="hljs-comment">//baidu.com, 405.543831ms, 2381 bytes</span><br>https:<span class="hljs-comment">//jd.com, 324.683787ms, 183679 bytes</span><br>https:<span class="hljs-comment">//taobao.com, 384.265799ms, 96082 bytes</span><br>https:<span class="hljs-comment">//qq.com, 209.840425ms, 327 bytes</span><br>https:<span class="hljs-comment">//godoc.org, 2.761245376s, 32378 bytes</span><br>https:<span class="hljs-comment">//baidu.com, 661ns, 2381 bytes</span><br>https:<span class="hljs-comment">//jd.com, 224ns, 183679 bytes</span><br>https:<span class="hljs-comment">//taobao.com, 188ns, 96082 bytes</span><br>https:<span class="hljs-comment">//qq.com, 474ns, 327 bytes</span><br>https:<span class="hljs-comment">//godoc.org, 323ns, 32378 bytes</span><br>--- PASS: Test (<span class="hljs-number">4.09</span>s)<br></code></pre></td></tr></table></figure><p>显然是无并发的，不存在数据竞争问题。 请求是一条接着一条，耗时长。</p><p>并行测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -run=TestConcurrent -v ./ch/ch9/memo1<br>=== RUN   TestConcurrent<br>https:<span class="hljs-comment">//qq.com, 33.114198ms, 327 bytes</span><br>https:<span class="hljs-comment">//qq.com, 46.830945ms, 327 bytes</span><br>https:<span class="hljs-comment">//jd.com, 68.843239ms, 183679 bytes</span><br>https:<span class="hljs-comment">//taobao.com, 94.846451ms, 96082 bytes</span><br>https:<span class="hljs-comment">//baidu.com, 106.973399ms, 2381 bytes</span><br>https:<span class="hljs-comment">//jd.com, 122.166527ms, 183679 bytes</span><br>https:<span class="hljs-comment">//baidu.com, 172.595417ms, 2381 bytes</span><br>https:<span class="hljs-comment">//taobao.com, 189.742852ms, 96082 bytes</span><br>https:<span class="hljs-comment">//godoc.org, 558.529384ms, 32378 bytes</span><br>https:<span class="hljs-comment">//godoc.org, 688.339219ms, 32378 bytes</span><br>--- PASS: TestConcurrent (<span class="hljs-number">0.69</span>s)<br></code></pre></td></tr></table></figure><p>显然，使用并行，无需要等待，耗时大大缩短。</p><p>但是呢，这并不是每次都能成功运行，有时候还会出现缓存为命中，或命中了缓存却返回错误的数据，甚至于直接崩溃。<br>我们可以使用-race这个flag进行运行程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> test -run=TestConcurrent -v -race ./ch/ch9/memo1<br>=== RUN   TestConcurrent<br>https:<span class="hljs-comment">//qq.com, 203.543501ms, 327 bytes</span><br>https:<span class="hljs-comment">//qq.com, 210.605108ms, 327 bytes</span><br>https:<span class="hljs-comment">//jd.com, 311.075599ms, 182426 bytes</span><br>==================<br>WARNING: DATA RACE<br>Write at <span class="hljs-number">0x00c00010aed0</span> by goroutine <span class="hljs-number">18</span>:<br>  runtime.mapassign_faststr()<br>      /usr/local/<span class="hljs-keyword">go</span>/src/runtime/map_faststr.<span class="hljs-keyword">go</span>:<span class="hljs-number">203</span> +<span class="hljs-number">0x0</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memo1.(*Memo).Get()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memo1/memo.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span> +<span class="hljs-number">0x12c</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest.Concurrent.func1()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest/memotest.<span class="hljs-keyword">go</span>:<span class="hljs-number">69</span> +<span class="hljs-number">0xea</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest.Concurrent.func2()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest/memotest.<span class="hljs-keyword">go</span>:<span class="hljs-number">75</span> +<span class="hljs-number">0x58</span><br><br>Previous write at <span class="hljs-number">0x00c00010aed0</span> by goroutine <span class="hljs-number">10</span>:<br>  runtime.mapassign_faststr()<br>      /usr/local/<span class="hljs-keyword">go</span>/src/runtime/map_faststr.<span class="hljs-keyword">go</span>:<span class="hljs-number">203</span> +<span class="hljs-number">0x0</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memo1.(*Memo).Get()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memo1/memo.<span class="hljs-keyword">go</span>:<span class="hljs-number">25</span> +<span class="hljs-number">0x12c</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest.Concurrent.func1()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest/memotest.<span class="hljs-keyword">go</span>:<span class="hljs-number">69</span> +<span class="hljs-number">0xea</span><br>  <span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest.Concurrent.func2()<br>      /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch9/memotest/memotest.<span class="hljs-keyword">go</span>:<span class="hljs-number">75</span> +<span class="hljs-number">0x58</span><br>...<br></code></pre></td></tr></table></figure><p>ps：go test出现缓存（cached），可以加上-count&#x3D;1禁止使用缓存。</p><p>显然，程序出现数据竞争，代码的第25行出现了2次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">21</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-number">22</span>res, ok := memo.cache[key]<br><span class="hljs-number">23</span><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-number">24</span>res.value, res.err = memo.f(key)<br><span class="hljs-number">25</span>memo.cache[key] = res<br><span class="hljs-number">26</span> &#125;<br><span class="hljs-number">27</span><span class="hljs-keyword">return</span> res.value, res.err<br><span class="hljs-number">28</span>&#125;<br></code></pre></td></tr></table></figure><p>说明这个两个goroutine在没有并发干预下更新了cache map。 表明Get函数非并发安全的，存在数据竞争。</p><h1 id="第二个版本-加锁"><a href="#第二个版本-加锁" class="headerlink" title="第二个版本-加锁"></a>第二个版本-加锁</h1><p>为了解决初始版本的并发问题，可以对Get函数进行加锁处理。<br>在函数开始时，进行获取锁，return的时候释放锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>f     Func<br>mu    sync.Mutex<br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result<br>&#125;<br><br><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>err   <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br><span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>memo.mu.Lock()<br>res, ok := memo.cache[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br>res.value, res.err = memo.f(key)<br>memo.cache[key] = res<br>&#125;<br>memo.mu.Unlock()<br><span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br></code></pre></td></tr></table></figure><p>再次进行测试，显然是没问题的。<br>但是该版本失去并发，性能大大下降。<br>每次对f进行调用期间都获取锁，Get将本来可以并行运行的I&#x2F;O操作串行化了。<br>以至于，不符合本章的目的。</p><h1 id="第三个版本-两个锁"><a href="#第三个版本-两个锁" class="headerlink" title="第三个版本-两个锁"></a>第三个版本-两个锁</h1><p>这个版本，Get函数的goroutine会获取两次锁，在查找缓存阶段一次，在存储缓存阶段一次。<br>这样可以解决第二版本串行化的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>f     Func<br>mu    sync.Mutex<br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result<br>&#125;<br><br><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>err   <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br><span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]result)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>memo.mu.Lock()<br>res, ok := memo.cache[key]<br>memo.mu.Unlock()<br><span class="hljs-keyword">if</span> !ok &#123;<br>res.value, res.err = memo.f(key)<br><br><span class="hljs-comment">// Between the two critical sections,several goroutines</span><br><span class="hljs-comment">// may race to compute f(key) and update the map.</span><br>memo.mu.Lock()<br>memo.cache[key] = res<br>memo.mu.Unlock()<br>&#125;<br><span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本性能较第二个版本大大提升，但是也带了一个问题。<br>但多个goroutine进入到Get函数，并在查找阶段，找不到缓存，进入到调用f的阶段。<br>那么就会发生多次请求相同f, 以及后一个goroutine获取到f的返回值会在存储缓存阶段覆盖先前相同的返回值。<br>显然，这样不符合本章的设计目的。</p><h1 id="第四个版本-ready-channel"><a href="#第四个版本-ready-channel" class="headerlink" title="第四个版本-ready channel"></a>第四个版本-ready channel</h1><p>对于第三个版本来说，理想的情况是去除重复多余的工作。<br>这种“避免”工作一般被称为<code>duplicate suppression(重复抑制/避免)</code>。<br>在entry结构体里加入read channel，用于当数据存储完成后广播其他goroutine告知读取数据是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>f     Func<br>mu    sync.Mutex<br>cache <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry<br>&#125;<br><br><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>err   <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>res   result<br>ready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br><span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>memo.mu.Lock()<br>e := memo.cache[key]<br><span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the first request for this key.</span><br><span class="hljs-comment">// This goroutine becomes responsible for computing</span><br><span class="hljs-comment">// the value and broadcasting the ready condition.</span><br>e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>memo.cache[key] = e<br>memo.mu.Unlock()<br><br>e.res.value, e.res.err = memo.f(key)<br><span class="hljs-built_in">close</span>(e.ready)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// This is a repeat request for this key.</span><br>memo.mu.Unlock()<br>&lt;-e.ready <span class="hljs-comment">// Waiting for ready condition.</span><br>&#125;<br><span class="hljs-keyword">return</span> e.res.value, e.res.err<br>&#125;<br></code></pre></td></tr></table></figure><p>Get函数的步骤如下：</p><ul><li><ol><li>获取互斥锁保护共享变量cache map。</li></ol></li><li><ol start="2"><li>查询map中是存在指定数据。</li></ol><ul><li>2.1 如果map没有指定数据。<ul><li>2.1.1 构建含有ready channel的新数据，并存储，然后释放锁。</li><li>2.1.2 释放锁之后，进行对f函数的调用，获取完成后，关闭ready channel，广播数据获取完成的信息。</li></ul></li><li>2.2 如果map有指定数据。<ul><li>2.2.1 释放锁。</li><li>2.2.2 等待接收ready channel的值。</li></ul></li></ul></li><li><ol start="3"><li>当ready channel进行广播后，就可以返回数据。</li></ol></li></ul><p>可以明确知道，entry中的e.res.value和e.res.err是在多个goroutine之间共享的。<br>在goroutine创建entry时，也设置了值（e &#x3D; &amp;entry{ready: make(chan struct{})}），当其它goroutine获取到广播信息（close(e.ready)）后，立即去获取了entry的值。<br>尽管有多个goroutine同时访问，但是也不需要互斥锁。<br>ready channel的关闭一定是在其它goroutine获取到广播之前，因此第一个goroutine的写操作发生在读操作之前，所以不会产生数据竞争。</p><h1 id="第五个版本-monitor-goroutine"><a href="#第五个版本-monitor-goroutine" class="headerlink" title="第五个版本-monitor goroutine"></a>第五个版本-monitor goroutine</h1><p>与第四个互斥量版本对比，该版本引用了monitor goroutine <code>监控协程</code>。<br>该版本对Memo结构进行了修改，Memo类型只有requests channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>requests <span class="hljs-keyword">chan</span> request<br>&#125;<br><span class="hljs-comment">// A request is a message requesting that the Func be applied to key.</span><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>key      <span class="hljs-type">string</span><br>response <span class="hljs-keyword">chan</span>&lt;- result <span class="hljs-comment">// the client wants a single result</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Get的调用方用这个channel来和monitor goroutine来通信。<br>requests channel中的元素类型是request。Get的调用方会把这个结构中的两组key都填充好，实际上用这两个变量来对函数进行缓存的。<br>另一个叫response的channel会被拿来发送响应结果。这个channel只会传回一个单独的值。<br>Get方法，会创建一个response channel，把它放进request结构中，然后发送给monitor goroutine （server），然后马上又会接收到它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br>memo.requests &lt;- request&#123;key: key, response: response&#125;<br>res := &lt;-response<br><span class="hljs-keyword">return</span> res.value, res.err<br>&#125;<br></code></pre></td></tr></table></figure><p>cache变量被限制在了monitor goroutine (*Memo).server中。<br>monitor会在循环中一直读取请求，直到request channel被Close方法关闭。<br>每一个请求都会去查询cache，如果没有找到entry的话，那么就会创建&#x2F;插入一个新的entry。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> server(f Func) &#123;<br>cache := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)<br><span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> memo.requests &#123;<br>e := cache[req.key]<br><span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// This is the first request for this key.</span><br>e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>cache[req.key] = e<br><span class="hljs-keyword">go</span> e.call(f, req.key)<br>&#125;<br><span class="hljs-keyword">go</span> e.deliver(req.response)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> call(f Func, key <span class="hljs-type">string</span>) &#123;<br><span class="hljs-comment">// Evaluate the function.</span><br>e.res.value, e.res.err = f(key)<br><span class="hljs-comment">// Broadcast the ready condition.</span><br><span class="hljs-built_in">close</span>(e.ready)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> deliver(response <span class="hljs-keyword">chan</span>&lt;- result) &#123;<br><span class="hljs-comment">// Wait for the ready condition.</span><br>&lt;-e.ready<br><span class="hljs-comment">// Send the result to the client.</span><br>response &lt;- e.res<br>&#125;<br></code></pre></td></tr></table></figure><p>与第四个互斥量版本类似，都是通过预存entry，然后请求数据，请求完成后，通过close(ready)进行广播。<br>只是在第五版本中，用call函数代替了调用并广播，用deliver函数代替了分发数据。<br>call和deliver的调用必须保证在自己的goroutine中进行，以确保不会阻塞monitor channel。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>第四种互斥量版本和第五种监控协程版本都是可行的，该如何选择呢？<br>其实各有各的优点，只能根据特定环境下进行选择。<br>Go语言其实更推荐通信并发，即第五种版本。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><em>练习 9.3：</em> 扩展Func类型和(*Memo).Get方法，支持调用方提供一个可选的done channel，使其具备通过该channel来取消整个操作的能力(§8.9)。一个被取消了的Func的调用结果不应该被缓存。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> memo<br><br><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">string</span>, &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>value <span class="hljs-keyword">interface</span>&#123;&#125;<br>err   <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;<br>res   result<br>ready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> call(f Func, key <span class="hljs-type">string</span>, done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) &#123;<br>e.res.value, e.res.err = f(key, done)<br><span class="hljs-built_in">close</span>(e.ready)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span></span> deliver(response <span class="hljs-keyword">chan</span>&lt;- result) &#123;<br>&lt;-e.ready<br>response &lt;- e.res<br>&#125;<br><br><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;<br>key      <span class="hljs-type">string</span><br>response <span class="hljs-keyword">chan</span>&lt;- result<br>done     &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;<br>requests <span class="hljs-keyword">chan</span> request<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> server(f Func) &#123;<br>cache := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]*entry)<br><span class="hljs-keyword">for</span> &#123;<br>LOOP:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> key := &lt;-canceledKeys:<br><span class="hljs-built_in">delete</span>(cache, key)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span> LOOP<br>&#125;<br>&#125;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> req, ok := &lt;-memo.requests:<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>e := cache[req.key]<br><span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;<br>cache[req.key] = e<br><span class="hljs-keyword">go</span> e.call(f, req.key, req.done)<br>&#125;<br><span class="hljs-keyword">go</span> e.deliver(req.response)<br><span class="hljs-keyword">default</span>:<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> canceledKeys = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Get(key <span class="hljs-type">string</span>, done &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;) (<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-type">error</span>) &#123;<br>response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)<br>memo.requests &lt;- request&#123;key: key, response: response, done: done&#125;<br>resp := &lt;-response<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br>canceledKeys &lt;- key<br><span class="hljs-keyword">default</span>:<br>&#125;<br><span class="hljs-keyword">return</span> resp.value, resp.err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span></span> Close() &#123;<br><span class="hljs-built_in">close</span>(memo.requests)<br><span class="hljs-built_in">close</span>(canceledKeys)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span></span> *Memo &#123;<br>memo := &amp;Memo&#123;requests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> request)&#125;<br><span class="hljs-keyword">go</span> memo.server(f)<br><span class="hljs-keyword">return</span> memo<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.6. 竞争条件检测</title>
      <link href="/posts/d92837fb26ef/"/>
      <url>/posts/d92837fb26ef/</url>
      
        <content type="html"><![CDATA[<p>程序并发发生问题实在无可避免，但是Go的runtime和工具链提供了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。</p><p>用法：<br>只要在go build、go run 或 go test 后面加上-race 的flag即可。<br>编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。<br>“修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对(*sync.Mutex).Lock，(*sync.WaitGroup).Wait等等的调用。</p><p>详细可见文档（<a href="https://golang.org/ref/mem%EF%BC%89">https://golang.org/ref/mem）</a></p><p>这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。</p><p>竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你到包。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.5. sync.Once初始化</title>
      <link href="/posts/76eb94f5fa7d/"/>
      <url>/posts/76eb94f5fa7d/</url>
      
        <content type="html"><![CDATA[<p>下面是一个懒加载的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>    icons = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image&#123;<br>        <span class="hljs-string">&quot;spades.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>),<br>        <span class="hljs-string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>),<br>        <span class="hljs-string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>),<br>        <span class="hljs-string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>),<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not concurrency-safe!</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>    <span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;<br>        loadIcons() <span class="hljs-comment">// one-time initialization</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> icons[name]<br>&#125;<br></code></pre></td></tr></table></figure><p>如果icons被单独goroutine访问的话，是安全的，如果处于并发环境，该例子则为并发不安全。</p><p>当多个goroutine访问Icon时，就会数据竞争。当第一个goroutine在忙着loading这些icon时，另一个goroutine进入Icon函数，发现icons&#x3D;&#x3D;nil，然后也会调用loadIcons。</p><p>上面的直觉其实是不准确的。<code>对并发的直觉总不能被信任。</code><br><code>因为缺少显式的同步，编译器和CPU是可以更改访问内存的指令顺序。</code><br>无论什么形式，只要保证每一个goroutine自己的执行顺序一致。</p><p>下面是loadIcons重排的一种可能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>    icons = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image)<br>    icons[<span class="hljs-string">&quot;spades.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>)<br>    icons[<span class="hljs-string">&quot;hearts.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>)<br>    icons[<span class="hljs-string">&quot;diamonds.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>)<br>    icons[<span class="hljs-string">&quot;clubs.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>它会先初始化一个空的map, 然后进行赋值。</p><p>所以goroutine在检查icons非空时，并不能确定icons已经装填完数据。</p><p>所以最有效的方法，是增加显式的同步方式mutex。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex <span class="hljs-comment">// guards icons</span><br><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image<br><br><span class="hljs-comment">// Concurrency-safe.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>    mu.Lock()<br>    <span class="hljs-keyword">defer</span> mu.Unlock()<br>    <span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;<br>        loadIcons()<br>    &#125;<br>    <span class="hljs-keyword">return</span> icons[name]<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，<code>使用互斥访问共享变量的代价是没办法并发访问共享变量，即使变量已经被初始化且再也不变动。</code><br>我们可以用多读单写锁sync.RWMutex进行优化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> icon<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> mu sync.RWMutex<br><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icons</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>mu.RLock()<br><span class="hljs-keyword">if</span> icons != <span class="hljs-literal">nil</span> &#123;<br>icon := icons[name]<br>mu.RUnlock()<br><span class="hljs-keyword">return</span> icon<br>&#125;<br><br>mu.Lock()<br><span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;<br>loadIcons()<br><br>&#125;<br>icon := icons[name]<br>mu.Unlock()<br><span class="hljs-keyword">return</span> icon<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;<br>icons = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image&#123;<br><span class="hljs-string">&quot;spades.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>),<br><span class="hljs-string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>),<br><span class="hljs-string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>),<br><span class="hljs-string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>),<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码有两个临界区。<br>goroutine先获取一个写锁，如果map !&#x3D; nil，获取icon, 然后释放锁，返回icon。<br>如果icons&#x3D;&#x3D;nil，先获取一个写锁，不释放共享锁的话，没有任何办法将共享锁升级为互斥锁，所以要再一次验证icons是否为nil，以防止在执行该代码时，有另外goroutine已经初始化icons。</p><p>虽然上面可以解决初始化的并发问题，但是过于繁杂。<br>Go语言提供sync.Once的方法来简化。<br>从概念上，一次性初始化只需要一个互斥值mutex和一个记录初始化是否完成的布尔值。<br>互斥量mutex保护布尔变量和初始化的数据结构。<br>sync.Once唯一的方法：Do<br>该方法只接收初始化函数作为参数。</p><p>下面是使用sync.Once简化的程序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> icon<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> loadIconsOnce sync.Once<br><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>loadIconsOnce.Do(loadIcons)<br><span class="hljs-keyword">return</span> icons[name]<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用Do时，都会获取锁，并且检查boolean变量。<br>第一次调用时，boolean变量的值为false，Do会调用loadIcons并且将boolean变量设置为true，接着mutex保证loadIcons的内存对所有访问的goroutine可见。<br>使用sync.Once初始化，可以避免在变量被构建之前和其他goroutine共享。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 9.2：</strong>  重写2.6.2节中的PopCount的例子，使用sync.Once，只在第一次需要用到的时候进行初始化。(虽然实际上，对PopCount这样很小且高度优化的函数进行同步可能代价没法接受)<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadPopCount</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> loadPopCountOnce sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>loadPopCountOnce.Do(loadPopCount)<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">1</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">2</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">3</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">4</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">5</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">6</span>*<span class="hljs-number">8</span>)] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;<span class="hljs-number">7</span>*<span class="hljs-number">8</span>)])<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.4. 内存同步</title>
      <link href="/posts/e115a072f817/"/>
      <url>/posts/e115a072f817/</url>
      
        <content type="html"><![CDATA[<p>在9.2，9.3章节中，我们对Balance方法使用了互斥锁mutex，在此有两方面的考虑。</p><ul><li>Balance方法不会在其他操作（如Withdraw）中执行。</li><li>更重要的是不单是一堆goroutine的执行顺序问题，而是内存同步问题。</li></ul><p>何为内存同步？<br>在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存(local cache)。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。</p><p>下面是说明例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x = <span class="hljs-number">1</span>                   <span class="hljs-comment">// A1</span><br>fmt.Print(<span class="hljs-string">&quot;y:&quot;</span>, y, <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// A2</span><br>&#125;()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>y = <span class="hljs-number">1</span>                   <span class="hljs-comment">// B1</span><br>fmt.Print(<span class="hljs-string">&quot;x:&quot;</span>, x, <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// B2</span><br>&#125;()<br><br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>尝试给出输出结果：<br>y:0 x:1<br>x:0 y:1<br>y:1 x:1<br>x:1 y:1  A1B1B2A2 &#x2F; B1A1B2A2</p><p>嗯，很合理。<br>但是有两种可能也有是会出现的。<br>x:0 y:0<br>y:0 x:0</p><p>为什么？<br>在一个独立的goroutine中，语句的执行顺序是固定。<br>但是在不使用互斥锁和channel这样的显式同步操作时，没有办法保证不同的goroutine的语句执行顺序是一致的。<br>如上例中，goroutine A中一定会在执行x &#x3D; 1成功后才会执行y的打印，但它无法保证自己能观察到goroutine B中对y的写入，所以goroutine A还可能打印出y的一个旧值。</p><p>上面那句话可以理解成goroutine的语句交错执行，但是却不适合当代的编译器。<br>在现代的编译器中，编译器断定两条语句的顺序不影响执行结果，并且交换两个语句的执行顺序。<br>因为赋值和打印语句指向不同变量，即不影响执行结果，就会交换执行顺序。</p><p>如果两个goroutine分别在不同的CPU中执行，每个核心拥有其缓存，在主存同步之前，一个goroutine的写入对于其他goroutine来说，是不可见的。</p><p>如何规避并发可能导致的问题呢？<br>所有并发问题都可以使用简单，一致的既定模式来规避。</p><ul><li>有可能的话，将变量限定在goroutine内。</li><li>多个goroutine都需要访问共享变量的话，使用互斥条件。（channel&#x2F;互斥锁）</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.3. sync.RWMutex读写锁</title>
      <link href="/posts/1294ae8bb0f7/"/>
      <url>/posts/1294ae8bb0f7/</url>
      
        <content type="html"><![CDATA[<p>允许多个只读操作并发执行，但写操作完全互斥，这样的锁叫<code>多读单写锁</code>（multipe readers, single writer lock）， 在go语言中，sync.RWMutex是这样的锁。</p><p>调用了<code>RLock</code>和<code>RUnlock</code>方法来获取和释放一个读取或者共享锁。</p><p><code>RLock</code>只能在临界区共享变量没有任何写入操作可用。<br>不应该在只读函数&#x2F;方法内更新共享变量。</p><p>RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。</p><p>下面是修改bank的查询余额的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.RWMutex<br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    mu.RLock() <span class="hljs-comment">// readers lock</span><br>    <span class="hljs-keyword">defer</span> mu.RUnlock()<br>    <span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><p>Deposit函数没有变化，会调用mu.Lock和mu.Unlock方法来获取和释放一个写或互斥锁。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.2. sync.Mutex互斥锁</title>
      <link href="/posts/da8e0d3d1c07/"/>
      <url>/posts/da8e0d3d1c07/</url>
      
        <content type="html"><![CDATA[<h1 id="channel互斥"><a href="#channel互斥" class="headerlink" title="channel互斥"></a>channel互斥</h1><p>在前面例子中，我们用buffered channel来设计sema信号量，来保证至多20个goroutine同时执行http请求。<br>如果使用容量只有1的channel来保证至多1个goroutine同一时刻来访问一个共享变量，这样也能达成互斥。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bank<br><br><span class="hljs-keyword">var</span> (<br>sema    = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>)<br>balance <span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>balance -= amount<br>&lt;-sema<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;()<br><span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h1><p>sync包支持互斥锁，可以直接使用。<br>Lock方法可以获取token，即锁。<br>Unlock方法可以释放该token。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bank<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><br><br><span class="hljs-keyword">var</span> (<br>mu      sync.Mutex<br>balance <span class="hljs-type">int</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>mu.Lock()<br>balance -= amount<br>mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><p>按照惯例，被mutex所保护的共享变量应该在mutex变量声明后立即声明。否则，应该做文档说明。</p><p>在Lock和Unlock之间的代码段中的内容goroutine可以随便读取或者修改，这个代码段叫做临界区。<br>互斥锁无论什么时候都应该在结束时释放，即使在处理错误。</p><p>可以使用defer机制，调用Unlock，即可保证无论返回还是错误都会调用Unlock.</p><p>这种函数、互斥锁和变量的编排叫作<code>监控monitor</code>。</p><p>调用defer语句会比显式Unlock成本会高一点，但是可以保持代码整洁性。</p><p>go语言没有可重入锁。</p><p>互斥量的目的是为了确保共享变量在程序执行时的关键点上能够保证不变性。不变性的其中之一是“没有goroutine访问共享变量”。</p><p>对已经上锁的mutex锁上锁，将会导致程序死锁，程序会一直阻塞下去。</p><p><code>当你使用mutex时，确保mutex和其保护的变量没有被导出(在go里也就是小写，且不要被大写字母开头的函数访问啦)，无论这些变量是包级的变量还是一个struct的字段。</code></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.1. 竞争条件</title>
      <link href="/posts/df4edc666b3d/"/>
      <url>/posts/df4edc666b3d/</url>
      
        <content type="html"><![CDATA[<p>在线性的程序中，即只有一个goroutine，程序的执行顺序由程序逻辑决定。<br>当我们无法确认两个事件之间执行的先后顺序时，说明这两个事件是并发的。</p><p>在并发的情况下，函数能够正确并正常运行，那么可以说这个函数是并发安全的。<br>并发安全的函数不需要额外进行同步。<br>同样的，不但适用于函数，还可以适用于类型的函数和方法，如果这个类型是并发安全的，那么类型的方法和函数同样是并发安全的。</p><p>导出包级别的函数一般情况下是并发安全的。<br>由于包级别的变量没法限制在单一个goroutine内，所以修改这些变量必须要使用互斥条件。</p><p>一个函数在并发调用可能达不到预期的结果，原因有<code>死锁（deadlock）</code>、<code>活锁（livelock）</code>和 <code>资源匮乏（resourse starvation）</code>等等。<br>本章主要讨论竞争条件，何为竞争条件？<br><code>竞争条件</code>指的是程序在多个goroutine交叉执行操作时，没有得到正确的结果。这种情况往往难以察觉，可能只会在某特定条件下才会触发，如负载大、或在某编译器、某平台下或某架构下。这种问题往往难以复现和难以分析判断。</p><p>下面是一段简单的银行账户程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> 错误示范</span><br><span class="hljs-keyword">package</span> bank<br><br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>balance = balance + amount<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> balance<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Deposit</code>函数是存钱，<code>Balance</code>函数是获取余额。<br>如果顺序执行存钱，获取余额操作没有问题。<br>但在并发条件下，<code>Balance</code>获取余额可能就达不到预期了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// zhansan</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>bank.Desposit(<span class="hljs-number">200</span>)         <span class="hljs-comment">// A1</span><br>fmt.Println(<span class="hljs-string">&quot;-&quot;</span>, Balance())<span class="hljs-comment">// A2</span><br>&#125;<br><br><span class="hljs-comment">// lisi</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>bank.Desposit(<span class="hljs-number">100</span>) <span class="hljs-comment">// B</span><br>&#125;<br></code></pre></td></tr></table></figure><p>zhansan存了200（A1），然后查询余额（A2）。<br>lisi存了100（B）。</p><p>这些操作时并发执行的，我们无法确定先后顺序。<br>以下是先后顺序的可能性：<br>zhansan先<br>lisi先<br>zhansan&#x2F;lisi&#x2F;zhansan交替执行</p><p>下面是三个可能性的结果：</p><table><thead><tr><th align="center">zhansan 先</th><th align="center">lisi 先</th><th align="center">zhansan&#x2F;lisi&#x2F;zhansan</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">A1 200</td><td align="center">B 100</td><td align="center">A1 200</td></tr><tr><td align="center">A2 “&#x3D;200”</td><td align="center">A1 300</td><td align="center">B 300</td></tr><tr><td align="center">B 300</td><td align="center">A2 “&#x3D;300”</td><td align="center">A2 “&#x3D;300”</td></tr></tbody></table><p>所有的最终结果都是300，感觉没有问题呢。<br>但是往往这种直觉是致命的，第四种情况是存在的。<br>当lisi的存款在zhansan存款操作中间，即在A1操作中的读取余额后（balance+amount），在余额更新前(balance&#x3D;…)，这样子将导致lisi的存款丢失。可以将上述的操作，改成A1r, A1w。</p><table><thead><tr><th>Data race</th><th></th><th></th></tr></thead><tbody><tr><td></td><td>0</td><td></td></tr><tr><td>A1r</td><td>0</td><td>…&#x3D;balance+amount</td></tr><tr><td>B</td><td>100</td><td></td></tr><tr><td>A1w</td><td>200</td><td>balance&#x3D;…</td></tr><tr><td>A2</td><td>200</td><td></td></tr></tbody></table><p>这种情况下，存款只有200，即lisi的存款丢失了。</p><p><code>无论什么时候，只要有两个或两个以上的goroutine并发访问同一变量，且至少一个goroutine对变量进行写操作，都会发生数据竞争。</code></p><p>下面还有一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x []<span class="hljs-type">int</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; x = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">10</span>)&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; x = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">1000000</span>)&#125;<br>x[<span class="hljs-number">999999</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> panic: runtime error: index out of range [999999] with length 10</span><br></code></pre></td></tr></table></figure><p>最后一个语句x的值是未定义的，可能是nil，也可能是长度为10的slice，还有可能是长度为1000000的slice。</p><p><code>数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。</code><br>有三种方法可以避免数据竞争。</p><ul><li>不要写变量。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image<br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not concurrency-safe!</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123;<br>icon, ok := icons[name]<br><span class="hljs-keyword">if</span> !ok &#123;<br>icon = loadIcon(name)<br>icons[name] = icon<br>&#125;<br><span class="hljs-keyword">return</span> icon<br>&#125;<br></code></pre></td></tr></table></figure>  上面例子中，使用懒加载Icon，并发情况下，这不是并发安全的，如果初始化并赋值icons且不在修改，就能够并发安全了。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]image.Image&#123;<br><span class="hljs-string">&quot;spades.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>),<br><span class="hljs-string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>),<br><span class="hljs-string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>),<br><span class="hljs-string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>),<br>&#125;<br><span class="hljs-comment">// Concurrency-safe.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> image.Image &#123; <span class="hljs-keyword">return</span> icons[name] &#125;<br></code></pre></td></tr></table></figure></li><li>避免多个goroutine访问变量。<br>  <code>不要使用共享数据来通信；使用通信来共享数据。</code><br>  <code>一个提供对一个指定的变量通过cahnnel来请求的goroutine叫做这个变量的监控(monitor)goroutine。</code><br>   如在8.10的聊天服务器中，broadcaster goroutine会监控(monitor)clients map的全部访问。<br>   下面是对bank的修改。   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">package</span> bank<br><br><span class="hljs-keyword">var</span> deposits = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">var</span> balances = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposits</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>deposits &lt;- amount<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> &lt;-balances<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teller</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> amount := &lt;-deposits:<br>balance += amount<br><span class="hljs-keyword">case</span> balances &lt;- balance:<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> teller()<br>&#125;<br></code></pre></td></tr></table></figure>   即使当一个变量无法在其整个生命周期内被绑定到一个独立的goroutine，绑定依然是并发问题的一个解决方案。例如在一条流水线上的goroutine之间共享变量是很普遍的行为，在这两者间会通过channel来传输地址信息。如果流水线的每一个阶段都能够避免在将变量传送到下一阶段时再去访问它，那么对这个变量的所有访问就是线性的。其效果是变量会被绑定到流水线的一个阶段，传送完之后被绑定到下一个，以此类推。这种规则有时被称为串行绑定。<br>   下面是串行绑定的例子，Cakes会被严格地顺序访问，先是baker gorouine，然后是icer gorouine。   <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> Cake <span class="hljs-keyword">struct</span>&#123; state <span class="hljs-type">string</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">baker</span><span class="hljs-params">(cooked <span class="hljs-keyword">chan</span>&lt;- *Cake)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>cake := <span class="hljs-built_in">new</span>(Cake)<br>cake.state = <span class="hljs-string">&quot;cooked&quot;</span><br>cooked &lt;- cake <span class="hljs-comment">// baker never touches this cake again</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">icer</span><span class="hljs-params">(iced <span class="hljs-keyword">chan</span>&lt;- *Cake, cooked &lt;-<span class="hljs-keyword">chan</span> *Cake)</span></span> &#123;<br><span class="hljs-keyword">for</span> cake := <span class="hljs-keyword">range</span> cooked &#123;<br>cake.state = <span class="hljs-string">&quot;iced&quot;</span><br>iced &lt;- cake <span class="hljs-comment">// icer never touches this cake again</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>允许多个goroutine访问变量，但同一时间最多只有一个goroutine访问，即“互斥”。</li></ul><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 9.1：</strong> 给gopl.io&#x2F;ch9&#x2F;bank1程序添加一个Withdraw(amount int)取款函数。其返回结果应该要表明事务是成功了还是因为没有足够资金失败了。这条消息会被发送给monitor的goroutine，且消息需要包含取款的额度和一个新的channel，这个新channel会被monitor goroutine来把boolean结果发回给Withdraw。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bank<br><br><span class="hljs-keyword">type</span> draw <span class="hljs-keyword">struct</span> &#123;<br>amount  <span class="hljs-type">int</span><br>succeed <span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-keyword">var</span> deposits = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">var</span> withdraws = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> draw)<br><span class="hljs-keyword">var</span> balances = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> &#123;<br>deposits &lt;- amount<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>succeed := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>)<br>withdraws &lt;- draw&#123;amount, succeed&#125;<br><span class="hljs-keyword">return</span> &lt;-succeed<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> &lt;-balances<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teller</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> balance <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> balances &lt;- balance:<br><span class="hljs-keyword">case</span> amount := &lt;-deposits:<br>balance += amount<br><span class="hljs-keyword">case</span> draw := &lt;-withdraws:<br><span class="hljs-keyword">if</span> balance &lt; draw.amount &#123;<br>draw.succeed &lt;- <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>balance -= draw.amount<br>draw.succeed &lt;- <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> teller()<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第九章 基于共享变量的并发</title>
      <link href="/posts/261f973145a5/"/>
      <url>/posts/261f973145a5/</url>
      
        <content type="html"><![CDATA[<p>在未引入锁机制前，我们可以使用<code>不要用共享数据来通信，使用通信来共享数据</code>，即单独goroutine访问局部变量。<br>本章主要为Go语言的锁机制。</p><p><a href="/posts/df4edc666b3d/">9.1. 竞争条件</a><br><a href="/posts/da8e0d3d1c07/">9.2. sync.Mutex互斥锁</a><br><a href="/posts/1294ae8bb0f7/">9.3. sync.RWMutex读写锁</a><br><a href="/posts/e115a072f817/">9.4. 内存同步</a><br><a href="/posts/76eb94f5fa7d/">9.5. sync.Once初始化</a><br><a href="/posts/d92837fb26ef/">9.6. 竞争条件检测</a><br><a href="">9.7. 并发的非阻塞缓存</a><br><a href="">9.8. Goroutines和线程</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.9. 并发的退出</title>
      <link href="/posts/92d779dbee59/"/>
      <url>/posts/92d779dbee59/</url>
      
        <content type="html"><![CDATA[<p>书接上回，话说上章节实现du工具，并做了进一步扩展，在本章节进行进一步的扩展。<br>如果du的文件目录下有很多很大的文件，那么时间就会增加，这时，用户等待到不耐烦了，就想退出但又不想通过<code>kill</code>程序。</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>众所周知，如果我们需要通知正在运行的goroutine停止它手头上的事时，如web服务器端要中断已经和服务器断开连接的客户端，go语言并没有提供这样的方法。<br>换个思路，在先前的章节中，我们有通过往channel中发送事件，提示接收它的goroutine来停止。好主意，但是如果要退出多个goroutine呢？<br>嗯，那么发送多个信息就好啦。事情没有那么简单，如果某个goroutine已经关闭了，就会产生错误，而且channel中的事件数比goroutine的数量多的话，就会发送阻塞。<br>如果goroutine又产生新的goroutine时，此时channel中的事件数量少于实际goroutine，那么就有一部分goroutine接收不到事件而无法退出。<br>一般情况下，我们很难知道有多少个goroutine在运行，所以我们需要一个策略，可以通过channel将信息广播出去，这样所有的goroutine能够看到该信息。<br>有一个channel的特性：<strong>关闭一个channel并且消费了所有已发送的值，channel之后的代码能够立即执行，并产生零值。</strong><br>广播机制：<strong>不要向channel发送值，而是关闭channel来进行广播。</strong></p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="退出channel"><a href="#退出channel" class="headerlink" title="退出channel"></a>退出channel</h2><p>首先创建退出channel，该channel不会被发送任何值。同时，要定义一个工具函数<code>cancelled()</code>，用于在被调用时轮询退出状态。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelled</span><span class="hljs-params">()</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="退出操作"><a href="#退出操作" class="headerlink" title="退出操作"></a>退出操作</h2><p>下面创建一个从标准输入流中读取内容的goroutine，每当有输入被读到（如按了回车），这个goroutine会将取消信息通过关闭done channel广播出去。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>&#123;<br>os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>))<br><span class="hljs-built_in">close</span>(done)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="响应done"><a href="#响应done" class="headerlink" title="响应done"></a>响应done</h2><p>下面是对done进行响应的goroutine。在main goroutine中，添加第三个case语句，尝试从done channel中读取信息。如果该case语句被满足时，那么可以直接return，但是在return前，要将fileSizes chanenl中的信息排空，在channel关闭前，要保证所有的值已被消费。这样可以保证walkDir的调用向fileSizes发送信息时不会被阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> fileSizes &#123;<br><span class="hljs-comment">// Do nothing.</span><br>&#125;<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> size, ok := fileSizes:<br> <span class="hljs-comment">// ...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改walkDir"><a href="#修改walkDir" class="headerlink" title="修改walkDir"></a>修改walkDir</h2><p>walkDir这个goroutine一启动就会轮询done状态，当done状态为true时，直接退出，不再做下面代码的无用操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-type">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span> &lt;- <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> n.Done()<br><span class="hljs-keyword">if</span> cancelled() &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="修改dirents"><a href="#修改dirents" class="headerlink" title="修改dirents"></a>修改dirents</h2><p>该程序的性能瓶颈为dirents函数中的获取信号量操作，下面select代码将该信号量取消并退出函数，把取消时的延迟从几百毫秒降低到几十毫秒。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-type">string</span>)</span></span> []os.FileInfo &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="hljs-comment">// acquire token</span><br><span class="hljs-keyword">case</span> &lt;- done: <span class="hljs-comment">// cancelled</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125; <span class="hljs-comment">// release token</span><br><span class="hljs-comment">// read directory</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里要注意一个问题，必须要将defer语句写在select语句后面，否则会无限阻塞。<br>为什么顺序反过来后，sema会进入阻塞?<br>因为&lt;-done接收到信号&#x3D;》return &#x3D;》defer &#x3D;》 &lt;-sema， 而此时sema协程在等待发送操作（sema&lt;-struct{}{}）。<br>反过来后，接收到done的信号后，就直接return了，根本没运行到defer语句，所以不存在阻塞。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.10：</strong> HTTP请求可能会因http.Request结构体中Cancel channel的关闭而取消。修改8.6节中的web crawler来支持取消http请求。（提示：http.Get并没有提供方便地定制一个请求的方法。你可以用http.NewRequest来取而代之，设置它的Cancel字段，然后用http.DefaultClient.Do(req)来进行这个http请求。）<br>解：<br>links.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> links<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-comment">// Extract make an HTTP GET request to the specified URL, parses</span><br><span class="hljs-comment">// the response as HTML, and return the links in the HML document.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Extract</span><span class="hljs-params">(url <span class="hljs-type">string</span>, cancelled <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(cancelFunc context.CancelFunc)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cancelled:<br>cancelFunc()<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>&#125;(cancelFunc)<br><br>req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;building request %s: %v&quot;</span>, url, err)<br>&#125;<br>resp, err := http.DefaultClient.Do(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;doing request %s: %v&quot;</span>, url, err)<br>&#125;<br><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %s&quot;</span>, url, resp.Status)<br>&#125;<br><br>doc, err := html.Parse(resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;paring %s as HTML: %v&quot;</span>, url, err)<br>&#125;<br><br><span class="hljs-keyword">var</span> links []<span class="hljs-type">string</span><br>visitNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key != <span class="hljs-string">&quot;href&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>link, err := resp.Request.URL.Parse(a.Val)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br>links = <span class="hljs-built_in">append</span>(links, link.String())<br>&#125;<br>&#125;<br>&#125;<br>forEachNode(doc, visitNode, visitNode)<br><span class="hljs-keyword">return</span> links, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>forEachNode(c, pre, post)<br>&#125;<br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex8/ex8.10/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br>unseenLinks := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>worklist &lt;- os.Args[<span class="hljs-number">1</span>:]<br>&#125;()<br><br><span class="hljs-keyword">var</span> n sync.WaitGroup<br>n.Add(<span class="hljs-number">1</span>)<br>cancelled := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>))<br>n.Done()<br><span class="hljs-built_in">close</span>(cancelled)<br>&#125;()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> link := <span class="hljs-keyword">range</span> unseenLinks &#123;<br>n.Add(<span class="hljs-number">1</span>)<br>foundLinks := crawl(link, cancelled, &amp;n)<br><span class="hljs-keyword">if</span> foundLinks != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- foundLinks &#125;()<br>&#125;<br>&#125;<br>&#125;()<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>n.Wait()<br><span class="hljs-built_in">close</span>(worklist)<br><span class="hljs-built_in">close</span>(unseenLinks)<br>&#125;()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br><span class="hljs-keyword">if</span> !seen[link] &#123;<br>seen[link] = <span class="hljs-literal">true</span><br>unseenLinks &lt;- link<br>&#125;<br>&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cancelled:<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> worklist &#123;<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> unseenLinks &#123;<br><br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-type">string</span>, cancelled <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, n *sync.WaitGroup)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">defer</span> n.Done()<br><br>fmt.Println(url)<br>list, err := links.Extract(url, cancelled)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 8.11：</strong> 紧接着8.4.4中的mirroredQuery流程，实现一个并发请求url的fetch的变种。当第一个请求返回时，直接取消其它的请求。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>cancelled := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br>resps := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-built_in">len</span>(os.Args[<span class="hljs-number">1</span>:]))<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>url := url<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>s, err := fetch(url, cancelled)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch %s: %v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>resps &lt;- s<br>&#125;()<br>&#125;<br>resp := &lt;-resps<br><span class="hljs-built_in">close</span>(cancelled)<br>fmt.Println(resp)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, cancelled &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>ctx, cancelFunc := context.WithCancel(context.Background())<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-cancelled:<br>cancelFunc()<br>&#125;<br>&#125;()<br>req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;building request %s: %v&quot;</span>, url, err)<br>&#125;<br><br>resp, err := http.DefaultClient.Do(req)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;doing request %s: %v&quot;</span>, url, err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %v&quot;</span>, url, resp.Status)<br>&#125;<br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;reading response %s: %v&quot;</span>, url, err)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s&quot;</span>, b), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.8. 示例：并发的字典遍历</title>
      <link href="/posts/dbf617f2750e/"/>
      <url>/posts/dbf617f2750e/</url>
      
        <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>创建一个程序来统计指定目录下的硬盘使用报告，即文件大小，与linux中的du命令类似。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>毫无疑问，这道题要使用递归去解决。</p><ul><li>创建<code>walkDir</code>递归函数，用于获取下层目录，并统计文件大小。</li><li>创建<code>dirents</code>函数用于读取目录下的文件目录。</li><li>使用<code>fileSize channel</code>去接受发送文件大小。</li><li>接收<code>fileSize channel</code>去累加文件大小。</li></ul><h1 id="第一个版本"><a href="#第一个版本" class="headerlink" title="第一个版本"></a>第一个版本</h1><p>该版本比较直白，下面是它的步骤。</p><ol><li>创建<code>flag</code>获取文件目录（可能是多个目录），并检查初始化目录。</li><li>创建<code>fileSize channel</code>用于接收文件大小，遍历文件目录参数，并创建goroutine来递归文件目录（<code>walkDir</code>）。</li><li>使用<code>range</code>接收<code>fileSize channel</code>， 统计并打印结果。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The du command computes the disk usage of the files in a directory.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// Determine the initial directories.</span><br>flag.Parse()<br>roots := flag.Args()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;<br>roots = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Traverse the file tree.</span><br>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;<br>walkDir(root, fileSizes)<br>&#125;<br><span class="hljs-built_in">close</span>(fileSizes)<br>&#125;()<br><br><span class="hljs-comment">// Print the results.</span><br><span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-type">int64</span><br><span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> fileSizes &#123;<br>nfiles++<br>nbytes += size<br>&#125;<br>printDickUage(nfiles, nbytes)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDickUage</span><span class="hljs-params">(nfiles <span class="hljs-type">int64</span>, nbytes <span class="hljs-type">int64</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d files, %.1fGB\n&quot;</span>, nfiles, <span class="hljs-type">float64</span>(nbytes)/<span class="hljs-number">1e9</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-type">string</span>, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<br><span class="hljs-keyword">if</span> entry.IsDir() &#123;<br>subDir := filepath.Join(dir, entry.Name())<br>walkDir(subDir, fileSizes)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fileInfo, err := entry.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fileSizes &lt;- fileInfo.Size()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-type">string</span>)</span></span> []os.DirEntry &#123;<br>entries, err := os.ReadDir(dir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> entries<br>&#125;<br></code></pre></td></tr></table></figure>很明显，该例子需要耗费更多时间才能统计完成。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go build -o du1 main.go <br>$ sudo ./du1 /usr /bin /etc<br>68755 files, 6.3GB<br></code></pre></td></tr></table></figure>注意是否有权限去读取文件，必要时使用<code>sudo</code>。</li></ol><h1 id="第二个版本"><a href="#第二个版本" class="headerlink" title="第二个版本"></a>第二个版本</h1><p>在第一个版本的基础上，加上统计进度，就更直白，而不至于程序运行时间过长，而导致以为程序卡。<br>第二个版本会间歇性打印内容，而且只在于使用了<code>-v</code>的flag才会显示程序进度信息。</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>在<code>roots</code>循环的goroutine保持不变，在<code>main goroutine</code>中使用<code>tick</code>计时器每500ms发送一次事件，取消<code>range</code>循环获取<code>fileSizes</code>，用<code>select</code>语句来等待<code>fileSizes</code>并统计文件大小和获取计时器的事件来打印进度信息，</p><p>如果命令没有<code>-v</code>，那么计时器<code>tick</code>为nil，<code>select</code>语句的<code>tick</code>一直为nil，即<code>tick</code>拥有的case语句被禁用。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> verbose = flag.Bool(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;show verbose progress massage.&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Determine the initial directory.</span><br>flag.Parse()<br>roots := flag.Args()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;<br>roots = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Traverse the file tree.</span><br>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;<br>walkDir(root, fileSizes)<br>&#125;<br><span class="hljs-built_in">close</span>(fileSizes)<br>&#125;()<br><br><span class="hljs-comment">// Prints the result periodically.</span><br><span class="hljs-keyword">var</span> ticker *time.Ticker<br><span class="hljs-keyword">var</span> tick &lt;-<span class="hljs-keyword">chan</span> time.Time<br><span class="hljs-keyword">if</span> *verbose &#123;<br>ticker = time.NewTicker(<span class="hljs-number">500</span> * time.Millisecond)<br>tick = ticker.C<br>&#125;<br><span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-type">int64</span><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tick:<br>printDiskUage(nfiles, nbytes)<br><span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br>nfiles++<br>nbytes += size<br>&#125;<br>&#125;<br>printDiskUage(nfiles, nbytes)<br><span class="hljs-keyword">if</span> *verbose &#123;<br>ticker.Stop()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDiskUage</span><span class="hljs-params">(nfiles, nbytes <span class="hljs-type">int64</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d files, %.1f GB\n&quot;</span>, nfiles, <span class="hljs-type">float64</span>(nbytes)/<span class="hljs-number">1e9</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-type">string</span>, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<br><span class="hljs-keyword">if</span> entry.IsDir() &#123;<br>subDir := filepath.Join(dir, entry.Name())<br>walkDir(subDir, fileSizes)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fileInfo, err := entry.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fileSizes &lt;- fileInfo.Size()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-type">string</span>)</span></span> []os.DirEntry &#123;<br>entries, err := os.ReadDir(dir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> entries<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build -o du2 main.go</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo ./du2 -v /usr /bin /etc</span><br>6507 files, 1.0 GB<br>18019 files, 1.2 GB<br>27294 files, 1.8 GB<br>37819 files, 2.3 GB<br>44133 files, 3.2 GB<br>51914 files, 3.5 GB<br>60538 files, 5.9 GB<br>68755 files, 6.3 GB<br></code></pre></td></tr></table></figure><h1 id="第三个版本"><a href="#第三个版本" class="headerlink" title="第三个版本"></a>第三个版本</h1><p>虽然有了进度信息，但是统计速度太慢了，第三个版本将使用<code>goroutine</code>并行统计文件大小。</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>统计慢，无非在于<code>walkDir</code>函数并不是并行的，那么可以创建<code>goroutine</code>来调用<code>walkDir</code>。<br>以及使用<code>sync.WaitGroup</code>来对活跃的<code>walkDir</code>函数进行计数，再创建一个<code>goroutine</code>用于计数器为0时关闭<code>fileSizes</code>。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> verbose = flag.Bool(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;show verbose progress massage.&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Determine the initial directory.</span><br>flag.Parse()<br>roots := flag.Args()<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;<br>roots = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Traverse the file tree.</span><br>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br><span class="hljs-keyword">var</span> n sync.WaitGroup<br><span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;<br>n.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> walkDir(root, &amp;n, fileSizes)<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>n.Wait()<br><span class="hljs-built_in">close</span>(fileSizes)<br>&#125;()<br><br><span class="hljs-comment">// Prints the result periodically.</span><br><span class="hljs-keyword">var</span> ticker *time.Ticker<br><span class="hljs-keyword">var</span> tick &lt;-<span class="hljs-keyword">chan</span> time.Time<br><span class="hljs-keyword">if</span> *verbose &#123;<br>ticker = time.NewTicker(<span class="hljs-number">500</span> * time.Millisecond)<br>tick = ticker.C<br>&#125;<br><span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-type">int64</span><br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tick:<br>printDiskUage(nfiles, nbytes)<br><span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br>nfiles++<br>nbytes += size<br>&#125;<br>&#125;<br>printDiskUage(nfiles, nbytes)<br><span class="hljs-keyword">if</span> *verbose &#123;<br>ticker.Stop()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDiskUage</span><span class="hljs-params">(nfiles, nbytes <span class="hljs-type">int64</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d files, %.1f GB.\n&quot;</span>, nfiles, <span class="hljs-type">float64</span>(nbytes)/<span class="hljs-number">1e9</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-type">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> n.Done()<br><span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<br><span class="hljs-keyword">if</span> entry.IsDir() &#123;<br>n.Add(<span class="hljs-number">1</span>)<br>subDir := filepath.Join(dir, entry.Name())<br><span class="hljs-keyword">go</span> walkDir(subDir, n, fileSizes)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fileInfo, err := entry.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du3: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fileSizes &lt;- fileInfo.Size()<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> sema = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-type">string</span>)</span></span> []os.DirEntry &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;()<br>sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>entries, err := os.ReadDir(dir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du3: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> entries<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果文件过多，程序会创建成千上万个<code>goroutine</code>，过于并行也不是一件好事情，那么可以使用带缓存的<code>sema channel</code>来对<code>dirents</code>函数进行限制，代码中同时存在的<code>goroutine</code>为20个。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.9：</strong> 编写一个du工具，每隔一段时间将root目录下的目录大小计算并显示出来。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> dir <span class="hljs-keyword">struct</span> &#123;<br>id   <span class="hljs-type">int</span><br>size <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Determine the initial directory.</span><br>roots := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;<br>roots = []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Traverse the file tree.</span><br>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> dir)<br><span class="hljs-keyword">var</span> n sync.WaitGroup<br><span class="hljs-keyword">for</span> id, root := <span class="hljs-keyword">range</span> roots &#123;<br>n.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> walkDir(root, id, &amp;n, fileSizes)<br>&#125;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>n.Wait()<br><span class="hljs-built_in">close</span>(fileSizes)<br>&#125;()<br><br><span class="hljs-comment">// Print the result periodically.</span><br>ticker := time.NewTicker(<span class="hljs-number">500</span> * time.Millisecond)<br>nfiles := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, <span class="hljs-built_in">len</span>(roots))<br>nbytes := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int64</span>, <span class="hljs-built_in">len</span>(roots))<br>loop:<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ticker.C:<br>printDiskUsage(roots, nfiles, nbytes)<br><span class="hljs-keyword">case</span> dir, ok := &lt;-fileSizes:<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span> loop<br>&#125;<br>nfiles[dir.id]++<br>nbytes[dir.id] += dir.size<br>&#125;<br>&#125;<br>printDiskUsage(roots, nfiles, nbytes)<br>ticker.Stop()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDiskUsage</span><span class="hljs-params">(roots []<span class="hljs-type">string</span>, nfiles, nbytes []<span class="hljs-type">int64</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> id, root := <span class="hljs-keyword">range</span> roots &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d files, %.1fGB in %s.\n&quot;</span>, nfiles[id], <span class="hljs-type">float64</span>(nbytes[id])/<span class="hljs-number">1e9</span>, root)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(d <span class="hljs-type">string</span>, id <span class="hljs-type">int</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- dir)</span></span> &#123;<br><span class="hljs-keyword">defer</span> n.Done()<br><span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(d) &#123;<br><span class="hljs-keyword">if</span> entry.IsDir() &#123;<br>n.Add(<span class="hljs-number">1</span>)<br>subDir := filepath.Join(d, entry.Name())<br><span class="hljs-keyword">go</span> walkDir(subDir, id, n, fileSizes)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fileInfo, err := entry.Info()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du: %v&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fileSizes &lt;- dir&#123;id, fileInfo.Size()&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// sema is a counting semaphore for limiting concurrency in dirents.</span><br><span class="hljs-keyword">var</span> sema = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<br><br><span class="hljs-comment">// dirents returns the entries of directory dir.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-type">string</span>)</span></span> []os.DirEntry &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;()<br>sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>entries, err := os.ReadDir(dir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du: %v\n&quot;</span>, err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> entries<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.7. 基于select的多路复用</title>
      <link href="/posts/866000668cee/"/>
      <url>/posts/866000668cee/</url>
      
        <content type="html"><![CDATA[<h1 id="select"><a href="#select" class="headerlink" title="select"></a>select</h1><p>下面以火箭发射倒计时为例，说明select的多路复用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Countdown implement the countdown for a rocket launch.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;commencing countdown.&quot;</span>)<br>tick := time.Tick(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;<br>fmt.Println(countdown)<br>&lt;-tick<br>&#125;<br>launch()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">launch</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Lift off!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>time.Tick(1 * time.Second)</code>函数返回的是类型为<code>&lt;-chan Time</code>的单向只接收的channel tick，每隔1秒，该channel接收一次。在10个倒计时<code>countdown</code>中，每一个循环接收一个值，即每一秒接收一次。倒数循环结束后，火箭发射！</p><p>但是如果在发射倒计时中，发生异常，则需要按return键终止(abort)发射。<br>首先创建一个新goroutine，这个goroutine尝试从标准输入中获取单个byte，如果获取成功则向abort channel发送值。<br>现在倒数循环中，每一次循环都要等待tick, abort这个两个channel中获取值。如果tick channel获取到值，则表示继续倒计时；如果是abort chanenl获取到值，则表示发生异常，需要终止发射。<br>无法同时从每个channel获取信息，因为如果第一个channel没有接收到信息，就会一直堵塞，这样就获取不到第二个channel发过来的信息。这里就需要多路复用(<code>multilex</code>)操作，<code>select</code>语句能够解决这个问题。<br><code>select</code>语句格式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br><span class="hljs-comment">// do something</span><br><span class="hljs-keyword">case</span> x :=&lt;-ch2:<br><span class="hljs-comment">// use x to do something</span><br><span class="hljs-keyword">case</span> ch3 &lt;- y:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br> <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>select</code>语句与<code>switch</code>语句类型，同样有<code>case</code>和<code>default</code>选择分支。<br>在<code>select</code>语句中，每一个<code>case</code>代表一个通信操作（某个channel的发送和接收操作）。<br>格式中的第一个<code>case</code>表示接收表达式，其只包含自身表达式。<br>第二个<code>case</code>也是表示接受表达式，并且获取channel得到的值并复制使用。<br>第三个<code>case</code>表达式表示发送操作，当ch3不阻塞并且能发送值时进行操作。<br><code>default</code>语句表示当所有<code>case</code>语句不符合执行条件时执行<code>default</code>语句。<br><code>select</code>语句会等待所有<code>case</code>语句中能够执行的时候去执行case语句，当条件满足时，<code>select</code>语句才会通信并执行<code>case</code>语句，这时其他通信则不会执行。<br><strong>一个没有任何case语句或default语句的select语句写作select{}，会一直阻塞等待下去。</strong></p><p>回归到火箭发射倒计时程序中，可以使用<code>time.After()</code>函数代替<code>time.tick()</code>，<code>time.After()</code>能够在时间结束后立即返回一个<code>channel</code>，并新起一个<code>goroutine</code>在经过特定的时间后向该<code>channel</code>发送一个独立的值。<br>下面的<code>select</code>语句会一直等待两个事件中的一个到达，abort事件或者10秒后应答的事件。<br>如果在10秒内无abort事件，则火箭发射。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span>&#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<br><span class="hljs-keyword">case</span> &lt;-abort:<br>fmt.Prinln(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="多个case同时就绪"><a href="#多个case同时就绪" class="headerlink" title="多个case同时就绪"></a>多个case同时就绪</h1><p>如果多个<code>case</code>语句同时就绪时，<code>select</code>语句会随机选择一个执行，以保证每个channel都有平等的被<code>select</code>选中的机会。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch:<br>fmt.Println(x) <span class="hljs-comment">// 0 2 4 6 8</span><br><span class="hljs-keyword">case</span> ch &lt;- i:<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子的ch channel的buffer大小是1，会交替地为空或者为满，所以只有一个case可以进行下去，无论i为奇数还是偶数，都会输出<code>0 2 4 6 8</code>。<br>如果增加buffer大小，则会导致输出极为不确定。</p><h1 id="第三个版本"><a href="#第三个版本" class="headerlink" title="第三个版本"></a>第三个版本</h1><p>上面火箭发射倒计时并没有打印出倒计时，下面则对此进行改进。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Countdown implement countdown for a rocket launch.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> the ticker goroutine never terminates if the launch is abort.</span><br><span class="hljs-comment">// This is a &quot;goroutine leak&quot;.</span><br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// create abort channel.</span><br>abort := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1</span>))<br>abort &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;Commencing countdown. Press return to abort.&quot;</span>)<br>tick := time.Tick(<span class="hljs-number">1</span> * time.Second)<br><span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;<br>fmt.Println(countdown)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-tick:<br><span class="hljs-comment">// do nothing.</span><br><span class="hljs-keyword">case</span> &lt;-abort:<br>fmt.Println(<span class="hljs-string">&quot;Launch abort!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br>launch()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">launch</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;Lift off!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，select会使得每次循环迭代时等待一秒来执行操作。<br><code>time.Tick</code>函数创建了一个在循环中调用<code>time.Sleep</code>的goroutine，每次唤醒时发送一个事件。<br>当<code>countdown</code>主函数返回后，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，并继续徒劳地尝试从channel中发送值，然而没有其他goroutine会从该channel中接收值了—-即<code>goroutine泄露</code>。</p><p><code>Tick</code>函数适用于程序全生命周期都使用该时间。<br>一般情况下，会使用<code>NewTicker</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ticker := time.NewTicker(<span class="hljs-number">1</span> * time.Second)<br>&lt;-ticker.C    <span class="hljs-comment">// receive from ticker&#x27;s channel.</span><br>ticker.Stop() <span class="hljs-comment">// cause the ticker&#x27;s goroutine terminate.</span><br></code></pre></td></tr></table></figure><h1 id="轮询channel"><a href="#轮询channel" class="headerlink" title="轮询channel"></a>轮询channel</h1><p>有些情况下，并不想<code>select</code>堵塞等待case通信操作，而导致不能继续进行，可以使用<code>default</code>语句，用于处理当其它操作不能及时处理时程序需要执行哪些逻辑。<br>下面例子中，select语句会在abort channel中有值时，从中获取值；无值时则执行default语句。该情况为非阻塞接收操作，即<code>轮询channel</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-abort:<br>    fmt.Printf(<span class="hljs-string">&quot;Launch aborted!\n&quot;</span>)<br>    <span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// do nothing</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="活用零值的channel"><a href="#活用零值的channel" class="headerlink" title="活用零值的channel"></a>活用零值的channel</h1><p>channel的零值为nil，零值的channel也是有用的。<br>对零值channel进行发送和接收操作，会永远阻塞。<br>在select语句中，零值的channel永远不会被选中。<br>利用该特性，可以用nil来激活或禁用case，用于达成处理输入或输出事件时超时和取消的逻辑。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.8：</strong> 使用select来改造8.3节中的echo服务器，为其增加超时，这样服务器可以在客户端10秒中没有任何喊话时自动断开连接。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br>input := bufio.NewScanner(conn)<br><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">case</span> &lt;-ch:<br><span class="hljs-keyword">go</span> echo(conn, input.Text(), <span class="hljs-number">1</span>*time.Second)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(conn net.Conn, shout <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToUpper(shout))<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, shout)<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToLower(shout))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.6. 示例：并发的Web爬虫</title>
      <link href="/posts/1258766bd2ef/"/>
      <url>/posts/1258766bd2ef/</url>
      
        <content type="html"><![CDATA[<p>在先前的学习中，学习过简单爬虫算法，用bfs(广度优先)算法来抓取整个网站。<br>下面对其进行优化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Crawl1 crawls web links starting with the command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>fmt.Println(url)<br>list, err := links.Extract(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br><br><span class="hljs-comment">// Start with the command-line arguments.</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<br><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br><span class="hljs-keyword">if</span> !seen[link] &#123;<br>seen[link] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> &#123;<br>worklist &lt;- crawl(link)<br>&#125;(link)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意得是，之前例子中使用worklist记录需要进行处理的队列，每个元素为需要抓取的URL列表。现在使用channel替换slice来处理，对每一cawl的调用都会在它们自己的goroutine中把抓到的链接发送到worklist。<br>另外，<code>go func(link string)&#123; worklist &lt;-crawl(link) &#125;(link)</code>中将link作为显式函数参数传入，这样可以避免<code>循环变量快照</code>问题。<br>最后，注意这里将命令行参数传入worklist是在另外的goroutine中进行，这是避免在main goroutine和cawl goroutine中同时向另一个goroutine通过channel发送内容时发生死锁（因为另一边的接收操作还没有准备好）。当然，可以使用bufferd channel来解决问题。<br>编译运行：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>go build findlink.go<br><span class="hljs-variable">$ </span>findlink <span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/gopl.io/</span><br>“<span class="hljs-symbol">http:</span>/<span class="hljs-regexp">/gopl.io/</span><br><span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/golang.org/help</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">https:/</span><span class="hljs-regexp">/golang.org/doc</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">https:/</span><span class="hljs-regexp">/golang.org/blog</span><span class="hljs-regexp">/</span><br><span class="hljs-regexp">...</span><br></code></pre></td></tr></table></figure><p>但是在过一段时间后，会导致no such host。DNS查找失败，即使该域名完全正确。<br>其实是因为一次性创建太多网络连接，超过每个线程打开文件数量限制，而导致调用<code>net.Dial</code>像DNS查找失败的问题。</p><p>上述程序太过于并行，而系统总有一些限制因素。如CPU核心数会限制计算负载，还磁盘的转轴和磁头数限制了本地磁盘io操作频率，网络带宽限制下载速度上限，或者web服务器的服务容量上限等。</p><p>有优化上述程序，着手于限制<code>links.Extract</code>在同一时间最多不会超过n次调用。<br>那么程序设计思路来了，可以使用有容量限制的<code>bufferd channel</code>来控制并发，类似于操作系统的计数信号量概念。<br>从概念上来说，channel中有n个空槽代表n个可以处理内容的token，从channel中接收到一个值就会释放其中一个token，并生成新的空槽，这样就保证了在没有接收操作介入时最多n个发送操作。其次channel中元素类型并不重要，可以使用零值struct{}作为元素。</p><p>下面是优化过后的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> token = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><br>n++<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<br><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>list := &lt;-worklist<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br><span class="hljs-keyword">if</span> !seen[link] &#123;<br>seen[link] = <span class="hljs-literal">true</span><br>n++<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> &#123;<br>worklist &lt;- crawl(link)<br>&#125;(link)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>fmt.Println(link)<br>token &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>list, err := links.Extract(link)<br>&lt;-token <span class="hljs-comment">// release token</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><p>引入计数n，解决了程序永远终止的问题，即使已经完全爬到所有链接。当worklist为空或者crawl的goroutine没有在运行时，程序退出。<br>计数器n还对worklist的发送操作数量进行了限制，当每次发现有元素发送到worklist时，n++。<br>当主循环中n–直到0时，会退出循环，终止程序。<br>该版本比5.6节中的深度搜索快20倍，并且没有错误，还能在任务完成正确终止程序。</p><p>下面程序也是避免过度并发的的另一种思路，没有使用计数信号量，取而代之使用了20个“长活”的crawler goroutine，这样可以保证最多20个HTTP请求在并发。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-type">string</span>)<br>unseenLinks := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> link := <span class="hljs-keyword">range</span> unseenLinks &#123;<br>foundlinks := crawl(link)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- foundlinks &#125;()<br>&#125;<br>&#125;()<br>&#125;<br><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<br><span class="hljs-keyword">if</span> !seen[link] &#123;<br>seen[link] = <span class="hljs-literal">true</span><br>unseenLinks &lt;- link<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(link <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>fmt.Println(link)<br>list, err := links.Extract(link)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br><br></code></pre></td></tr></table></figure><p>所有爬虫goroutine现在都是被同一个channel-unseenLinks发送数据，主goroutine负责拆分从worklist里拿到的元素，把没有爬过的由unseenLinks channel发送给一个爬虫的goroutine。<br>seen这个map限定于main goroutine中，即只能在main goroutine中访问seen。这种信息隐藏的方式，能够约束程序，使其不发生意外的状况。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.6：</strong> 为并发爬虫增加深度限制。也就是说，如果用户设置了depth&#x3D;3，那么只有从首页跳转三次以内能够跳到的页面才能被抓取到。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> token = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<br><br><span class="hljs-keyword">type</span> work <span class="hljs-keyword">struct</span> &#123;<br>url  <span class="hljs-type">string</span><br>dept <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []work)<br><span class="hljs-keyword">var</span> n <span class="hljs-type">int</span><br><br>n++<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> works []work<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>works = <span class="hljs-built_in">append</span>(works, work&#123;url, <span class="hljs-number">1</span>&#125;)<br>&#125;<br>worklist &lt;- works<br>&#125;()<br><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;<br>works := &lt;-worklist<br><span class="hljs-keyword">for</span> _, w := <span class="hljs-keyword">range</span> works &#123;<br><span class="hljs-keyword">if</span> !seen[w.url] &#123;<br>seen[w.url] = <span class="hljs-literal">true</span><br>n++<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w work)</span></span> &#123;<br>worklist &lt;- crawl(w)<br>&#125;(w)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(w work)</span></span> []work &#123;<br>log.Printf(<span class="hljs-string">&quot;%d : %s&quot;</span>, w.dept, w.url)<br><br><span class="hljs-keyword">if</span> w.dept &gt;= <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br>token &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>list, err := links.Extract(w.url)<br>&lt;-token<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><br><span class="hljs-keyword">var</span> works []work<br><span class="hljs-keyword">for</span> _, l := <span class="hljs-keyword">range</span> list &#123;<br>works = <span class="hljs-built_in">append</span>(works, work&#123;l, w.dept + <span class="hljs-number">1</span>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> works<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 8.7：</strong> 完成一个并发程序来创建一个线上网站的本地镜像，把该站点的所有可达的页面都抓取到本地硬盘。为了省事，我们这里可以只取出现在该域下的所有页面(比如golang.org结尾，译注：外链的应该就不算了。)当然了，出现在页面里的链接你也需要进行一些处理，使其能够在你的镜像站点上进行跳转，而不是指向原始的链接。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>base = flag.String(<span class="hljs-string">&quot;base&quot;</span>, <span class="hljs-string">&quot;https://www.sulinehk.com&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>wg   sync.WaitGroup<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> crawl(*base) &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>download(*base, url)<br>&#125;(url)<br>&#125;<br><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br>&lt;-done<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(base, url <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> !strings.HasPrefix(url, base) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>dir := strings.TrimPrefix(strings.TrimPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>), <span class="hljs-string">&quot;https://&quot;</span>)<br><span class="hljs-keyword">if</span> err := os.MkdirAll(dir, <span class="hljs-number">0755</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><br>filename := dir + <span class="hljs-string">&quot;index.html&quot;</span><br>file, err := os.Create(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>_, err = io.Copy(file, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>fmt.Println(url)<br>list, err := links.Extract(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.5. 并发的循环</title>
      <link href="/posts/5f0a41aff939/"/>
      <url>/posts/5f0a41aff939/</url>
      
        <content type="html"><![CDATA[<p>在并发的情况下，循环迭代的程序往往要注意一些问题。<br>下面引用对图片批量压缩的例子进行解析。<br><code>thumbnail.go</code>是关于拉伸图片的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package thumbnail produces thumbnail-size images from</span><br><span class="hljs-comment">// larger images.  Only JPEG images are currently supported.</span><br><span class="hljs-keyword">package</span> thumbnail<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/jpeg&quot;</span><br>_ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// register png</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// Image returns a thumbnail-size version of src.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Image</span><span class="hljs-params">(src image.Image)</span></span> image.Image &#123;<br><span class="hljs-comment">// Compute thumbnail size, preserving aspect ratio.</span><br>xs := src.Bounds().Size().X<br>ys := src.Bounds().Size().Y<br>width, height := <span class="hljs-number">128</span>, <span class="hljs-number">128</span><br><span class="hljs-keyword">if</span> aspect := <span class="hljs-type">float64</span>(xs) / <span class="hljs-type">float64</span>(ys); aspect &lt; <span class="hljs-number">1.0</span> &#123;<br>width = <span class="hljs-type">int</span>(<span class="hljs-number">128</span> * aspect) <span class="hljs-comment">// portrait</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>height = <span class="hljs-type">int</span>(<span class="hljs-number">128</span> / aspect)<br>&#125;<br>xscale := <span class="hljs-type">float64</span>(xs) / <span class="hljs-type">float64</span>(width)<br>yscale := <span class="hljs-type">float64</span>(ys) / <span class="hljs-type">float64</span>(height)<br><br>dst := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><br><span class="hljs-comment">// a very crude scaling algorithm</span><br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; width; x++ &#123;<br><span class="hljs-keyword">for</span> y := <span class="hljs-number">0</span>; y &lt; height; y++ &#123;<br>srcx := <span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(x) * xscale)<br>srcy := <span class="hljs-type">int</span>(<span class="hljs-type">float64</span>(y) * yscale)<br>dst.Set(x, y, src.At(srcx, srcy))<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> dst<br>&#125;<br><br><span class="hljs-comment">// ImageStream reads an image from r and</span><br><span class="hljs-comment">// writes a thumbnail-size version of it to w.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImageStream</span><span class="hljs-params">(w io.Writer, r io.Reader)</span></span> <span class="hljs-type">error</span> &#123;<br>src, _, err := image.Decode(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>dst := Image(src)<br><span class="hljs-keyword">return</span> jpeg.Encode(w, dst, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-comment">// ImageFile2 reads an image from infile and writes</span><br><span class="hljs-comment">// a thumbnail-size version of it to outfile.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImageFile2</span><span class="hljs-params">(outfile, infile <span class="hljs-type">string</span>)</span></span> (err <span class="hljs-type">error</span>) &#123;<br>in, err := os.Open(infile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> in.Close()<br><br>out, err := os.Create(outfile)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">if</span> err := ImageStream(out, in); err != <span class="hljs-literal">nil</span> &#123;<br>out.Close()<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;scaling %s to %s: %s&quot;</span>, infile, outfile, err)<br>&#125;<br><span class="hljs-keyword">return</span> out.Close()<br>&#125;<br><br><span class="hljs-comment">// ImageFile reads an image from infile and writes</span><br><span class="hljs-comment">// a thumbnail-size version of it in the same directory.</span><br><span class="hljs-comment">// It returns the generated file name, e.g. &quot;foo.thumb.jpeg&quot;.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImageFile</span><span class="hljs-params">(infile <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>ext := filepath.Ext(infile)<br>outfile := strings.TrimSuffix(infile, ext) + <span class="hljs-string">&quot;.thumb&quot;</span> + ext<br><span class="hljs-keyword">return</span> outfile, ImageFile2(outfile, infile)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="非并发循环压缩"><a href="#非并发循环压缩" class="headerlink" title="非并发循环压缩"></a>非并发循环压缩</h1><p>下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails makes thumbnails of the specified files.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">if</span> _, err := thumbnail.ImageFile(f); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="易并行"><a href="#易并行" class="headerlink" title="易并行"></a>易并行</h1><p>由于处理图片的顺序无关紧要，那么每个图片的操作都是相互独立的，这种情况称为<code>易并行问题（embarrassingly parallel）</code>。<br>这种易并行问题往往最容易转换成并行处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails2</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">go</span> thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子是<code>错误</code>的，当进行循环时，所有<code>goroutine</code>都已经启动，接着<code>makeThumbnails2</code>函数返回了，并没有等待<code>goroutine</code>执行完毕。</p><h1 id="channel获取goroutine的结果"><a href="#channel获取goroutine的结果" class="headerlink" title="channel获取goroutine的结果"></a>channel获取goroutine的结果</h1><p>虽然没有什么方法可以直接等待<code>goroutine</code>完成，但是可以通过<code>channel</code>将<code>goroutine</code>内部的完成情况告诉外部函数。<br>下面例子中是外部的goroutine只需要在返回之前对这些事件计数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails3 make thumbnails of the specified files in parallel.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnail3</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>thumbnail.ImageFile(f)<br>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;(f)<br>&#125;<br><br><span class="hljs-comment">// wait for goroutine to complete.</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;<br>&lt;-ch<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在该例子中，在<code>goroutine</code>中的匿名函数内，将空值<code>struct&#123;&#125;&#123;&#125;</code>发送给<code>channel ch</code>，在主<code>goroutine</code>中，循环接收<code>ch</code>的值，等待<code>goroutine</code>完成。<br>注意得是filenames数组中元素f传递给匿名函数的参数f，而不是在循环闭包中声明。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;()<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码导致出现匿名函数中的循环变量快照问题，上面这个单独的变量f是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的<code>goroutine</code>开始执行字面函数时，<code>for</code>循环可能已经更新了<code>f</code>并且开始了另一轮的迭代或者(更有可能的)已经结束了整个循环，“所以当这些<code>goroutine</code>开始读取f的值时，它们所看到的值已经是<code>slice</code>的最后一个元素了。显式添加参数，能够确保当前使用的<code>f</code>是当go语句执行时的<code>当前</code>那个<code>f</code>。</p><h1 id="获取working-goroutine的返回值"><a href="#获取working-goroutine的返回值" class="headerlink" title="获取working goroutine的返回值"></a>获取working goroutine的返回值</h1><p>如果我们想要从每一个worker goroutine往主goroutine中返回值时该怎么办呢？当我们调用thumbnail.ImageFile创建文件失败的时候，它会返回一个错误。下面的makeThumbnails会返回其在做拉伸操作时接收到的第一个错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span><br><span class="hljs-comment">// It returns an error if any step failed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails4</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>errors := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">error</span>)<br><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br>_, err := thumbnail.ImageFile(f)<br>errors &lt;- err<br>&#125;(f)<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">if</span> err := &lt;-errors; err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect: goroutine leak!</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用<code>channel</code>进行传输error信息，即可以把错误信息从<code>goroutine</code>传输到<code>main goroutine</code>。上述代码有一个错误，当一个非nil的error返回到<code>main goroutine</code>时，程序<code>return</code>了，导致<code>working channel</code>继续发送值时，却没有接收值，一直进行阻塞，永远不退出。这种情况叫<code>goroutine泄露</code>，可能导致程序卡住直至<code>out of memory</code>。<br>最简单地解决办法就是使用具有容量合适大小的<code>带缓存channel</code>，这样<code>working channel</code>向<code>channel</code>发送值时不会导致堵塞。还有一个解决办法就是，创建另外一个<code>goroutine</code>，但<code>main goroutine</code>获取第一个error时，清空<code>channel</code>。</p><h1 id="使用buffered-channel携带对象信息"><a href="#使用buffered-channel携带对象信息" class="headerlink" title="使用buffered channel携带对象信息"></a>使用buffered channel携带对象信息</h1><p>下一个版本的<code>makeThumbnails</code>使用了一个<code>buffered channel</code>来返回生成的图片文件的名字，附带生成时的错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span><br><span class="hljs-comment">// It returns the generated file names in an arbitrary order,</span><br><span class="hljs-comment">// or an error if any step failed.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails5</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> (thumbfiles []<span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">type</span> item <span class="hljs-keyword">struct</span> &#123;<br>thumbfile <span class="hljs-type">string</span><br>err       <span class="hljs-type">error</span><br>&#125;<br><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> item, <span class="hljs-built_in">len</span>(filenames))<br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> it item<br>it.thumbfile, it.err = thumbnail.ImageFile(f)<br>ch &lt;- it<br>&#125;(f)<br>&#125;<br><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;<br>it := &lt;-ch<br><span class="hljs-keyword">if</span> it.err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, it.err<br>&#125;<br>thumbfiles = <span class="hljs-built_in">append</span>(thumbfiles, it.thumbfile)<br>&#125;<br><br><span class="hljs-keyword">return</span> thumbfiles, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="统计文件大小"><a href="#统计文件大小" class="headerlink" title="统计文件大小"></a>统计文件大小</h1><p>最后一个版本的<code>makeThumbnails</code>返回了新文件们的大小总计数(bytes)。<br>与上面的例子不同的是，文件名不再是slice，而是单向接收的<code>channel</code>。<br>那么这样就获取不到文件数量，即确定不了<code>bufferd channel</code>的容量。</p><p>所以可以加入一个计数器，用于计算最后一个goroutine（不一定是最后开始的）什么时候结束，在每一个goroutine开始时加1，在goroutine结束时减1。这个计数器还要在多个goroutine中安全执行，在go中有这么一个计数器<code>sync.WaitGroup</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails6 makes thumbnails for each file received from the channel.</span><br><span class="hljs-comment">// It returns the number of bytes occupied by the files it creates.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails6</span><span class="hljs-params">(filename &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>sizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int64</span>)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// number of working goroutine</span><br><span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> filename &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-comment">// worker</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>thumb, err := thumbnail.ImageFile(f)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>info, _ := os.Stat(thumb) <span class="hljs-comment">// OK to ignore error</span><br>sizes &lt;- info.Size()<br>&#125;(f)<br>&#125;<br><br><span class="hljs-comment">// closer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br><span class="hljs-built_in">close</span>(sizes)<br>&#125;()<br><br><span class="hljs-keyword">var</span> total <span class="hljs-type">int64</span><br><span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> sizes &#123;<br>total += size<br>&#125;<br><span class="hljs-keyword">return</span> total<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">go</span> makeThumbnails6(ch)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>ch &lt;- <span class="hljs-string">&quot;img.png&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;img.png&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;img.png&quot;</span><br><span class="hljs-built_in">close</span>(ch) <span class="hljs-comment">// 手动关闭for range 的channel</span><br>&#125;()<br><span class="hljs-keyword">for</span> &#123; <span class="hljs-comment">// 用于等待makeThumnails6函数的完成</span><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>wg.Add(1)</code> 将goroutine加1，在匿名函数完成时<code>wg.Done()</code>（等价于<code>wg.Add(-1)</code>）进行减1。而<code>defer</code>机制可以保证，即使下面的代码出错也能减1。<br><code>wg.Wait()</code>等待并阻塞该<code>goroutine</code>，直至wg计数器值为0。这时继续执行关闭<code>sizes channel</code>操作。<br>那么在<code>main goroutine</code>中，通过<code>for range</code>获取到文件大小总和。<br>这里要注意的是<code>for...range</code>获取<code>文件名</code>时，要关闭<code>filename channel</code>，否则会一直等待，相当于<code>f:=&lt;-filename</code>阻塞。</p><p>还有一点，<code>close(sizes)</code>不能在<code>main goroutine</code>或者说不能与<code>for ...range sizes</code>同一个<code>goroutine</code>中执行，否则会一直阻塞，相互等待成为<code>dead lock</code>。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 8.4：</strong> 修改reverb2服务器，在每一个连接中使用sync.WaitGroup来计数活跃的echo goroutine。当计数减为零时，关闭TCP连接的写入，像练习8.3中一样。验证一下你的修改版netcat3客户端会一直等待所有的并发“喊叫”完成，即使是在标准输入流已经关闭的情况下。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Done()<br>echo(conn, input.Text(), <span class="hljs-number">1</span>*time.Second)<br>&#125;()<br>&#125;<br><br>wg.Wait()<br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(conn net.Conn, shout <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToUpper(shout))<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, shout)<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToLower(shout))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 8.5：</strong> 使用一个已有的CPU绑定的顺序程序，比如在3.3节中我们写的Mandelbrot程序或者3.2节中的3-D surface计算程序，并将他们的主循环改为并发形式，使用channel来进行通信。在多核计算机上这个程序得到了多少速度上的改进？使用多少个goroutine是最合适的呢？<br>解：<br>concurrent.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConcurrentRender</span><span class="hljs-params">(workers <span class="hljs-type">int</span>)</span></span> *image.RGBA &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><br>rows := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, height)<br><span class="hljs-keyword">for</span> row := <span class="hljs-number">0</span>; row &lt; height; row++ &#123;<br>rows &lt;- row<br>&#125;<br><span class="hljs-built_in">close</span>(rows)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; workers; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> py := <span class="hljs-keyword">range</span> rows &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br>img.Set(<br>px,<br>py,<br>mandelbrot(z),<br>)<br>&#125;<br>&#125;<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br><br><span class="hljs-keyword">return</span> img<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;<span class="hljs-number">255</span> - contrast*n&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br></code></pre></td></tr></table></figure><p>serial.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package mandelbrot emits a PNG image of the Mandelbrot fractal.</span><br><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SerialRender</span><span class="hljs-params">()</span></span> *image.RGBA &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + ymin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br>img.Set(px, py, mandelbrot(z))<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> img<br>&#125;<br></code></pre></td></tr></table></figure><p>mandelbrot_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;runtime&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSerialRender</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>SerialRender()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">benchmarkConcurrentRender</span><span class="hljs-params">(b *testing.B, workers <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>ConcurrentRender(workers)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark1</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMaxProces</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, runtime.GOMAXPROCS(<span class="hljs-number">-1</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark8</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">8</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark16</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">16</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark32</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark64</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">64</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark128</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>benchmarkConcurrentRender(b, <span class="hljs-number">128</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">使用cpu支持最大线程数时最优</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex8/ex8.5/mandelbrot</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkSerialRender</span><br><span class="hljs-comment">BenchmarkSerialRender-8          4 269136007 ns/op</span><br><span class="hljs-comment">Benchmark1</span><br><span class="hljs-comment">Benchmark1-8                     4 252338560 ns/op</span><br><span class="hljs-comment">BenchmarkMaxProces</span><br><span class="hljs-comment">BenchmarkMaxProces-8            12  88347559 ns/op</span><br><span class="hljs-comment">Benchmark8</span><br><span class="hljs-comment">Benchmark8-8                    13  85825956 ns/op</span><br><span class="hljs-comment">Benchmark16</span><br><span class="hljs-comment">Benchmark16-8                   18  90070427 ns/op</span><br><span class="hljs-comment">Benchmark32</span><br><span class="hljs-comment">Benchmark32-8                   15  99837822 ns/op</span><br><span class="hljs-comment">Benchmark64</span><br><span class="hljs-comment">Benchmark64-8                   12  93368396 ns/op</span><br><span class="hljs-comment">Benchmark128</span><br><span class="hljs-comment">Benchmark128-8                  12  93611058 ns/op</span><br><span class="hljs-comment">PASS</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.4. Channels</title>
      <link href="/posts/e24baaf2eab7/"/>
      <url>/posts/e24baaf2eab7/</url>
      
        <content type="html"><![CDATA[<h1 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>如果说<code>goroutine</code>是go语言的并发体，那么<code>Channels</code>是它们之间的通信机制。<br>一个<code>goroutine</code>可以通过<code>Channels</code>发送信息给另一个<code>goroutine</code>。<br>每个<code>Channels</code>都有其可发送的数据的数据类型，如一个可以发送<code>int</code>类型数据的<code>channel</code>一般写为<code>chan int</code>。</p><h2 id="创建channel"><a href="#创建channel" class="headerlink" title="创建channel"></a>创建channel</h2><p>使用内置的<code>make</code>函数，我们可以创建一个<code>channel</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>) <span class="hljs-comment">// ch has type &#x27;chan int&#x27;</span><br></code></pre></td></tr></table></figure><p>和<code>map</code>类型，<code>channel</code>也有一个对应<code>make</code>创建的底层数据结构的引用。<br>当复制或用于函数传递时，也只是拷贝了一个<code>channel</code>的引用。</p><p><code>channel</code>的零值是<code>nil</code>。</p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>两个相同类型的<code>channel</code>可以使用<code>==</code>运算符比较。<br>如果两个<code>channel</code>引用的是相同的对象，那么比较的结果为<code>true</code>。<br>一个<code>channel</code>也可以和<code>nil</code>进行比较。</p><h2 id="发送和接收"><a href="#发送和接收" class="headerlink" title="发送和接收"></a>发送和接收</h2><p><code>channel</code>有两个通信操作，<code>发送</code>和<code>接收</code>。<br>发送操作将一个值从一个<code>goroutine</code>中通过<code>channel</code>发送到另一个执行接收操作的<code>goroutine</code>。<br><code>发送</code>和<code>接收</code>的运算符号都是<code>&lt;-</code>。<br>发送操作是运算符分割<code>channel</code>和<code>值</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- x <span class="hljs-comment">// a send statement </span><br></code></pre></td></tr></table></figure><p>接收语句中，<code>&lt;-</code>写在<code>channel</code>对象前。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x = &lt;-ch  <span class="hljs-comment">// a receive expression in an assignment statement.</span><br></code></pre></td></tr></table></figure><p>接收语句还可以忽略接收对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;-ch  <span class="hljs-comment">// a receive statement.result is discarded.</span><br></code></pre></td></tr></table></figure><h2 id="close操作"><a href="#close操作" class="headerlink" title="close操作"></a>close操作</h2><p><code>channel</code>还支持<code>close</code>操作，用于关闭<code>channel</code>，随后对基于该<code>goroutine</code>的任何发送操作都导致<code>panic</code>异常。<br>对一个已经被<code>close</code>过的<code>channel</code>关闭之前接收操作依然可以接受到之前已经成功发送的数据。<br>如果<code>channel</code>中已经没有数据的话会产生一个零值的数据。<br>使用内置的<code>close</code>函数就可以关闭一个<code>channel</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure><h2 id="无缓存和带缓存"><a href="#无缓存和带缓存" class="headerlink" title="无缓存和带缓存"></a>无缓存和带缓存</h2><p>使用<code>make</code>函数创建的最简单的是无缓存<code>channel</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)  <span class="hljs-comment">// unbuffered channel</span><br></code></pre></td></tr></table></figure><p>可以指定<code>make</code>函数的第二个参数，对应<code>channel</code>的容量。<br>如果容量等于0，仍然是无缓存<code>channel</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// unbuffered channel</span><br></code></pre></td></tr></table></figure><p>如果容量大于0，则是带缓存<code>channel</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// buffered channel with capacity 3</span><br></code></pre></td></tr></table></figure><h1 id="8-4-1-不带缓存的Channels"><a href="#8-4-1-不带缓存的Channels" class="headerlink" title="8.4.1. 不带缓存的Channels"></a>8.4.1. 不带缓存的Channels</h1><p>无缓存<code>channel</code>的发送操作会导致发送者<code>goroutine</code>阻塞，直到另一个<code>goroutine</code>在相同的<code>channel</code>上执行接收操作，并且发送的值通过<code>channel</code>成功传输之后，两个<code>goroutine</code>可以继续执行后面的语句。<br>反之，如果接收操作先发生，那么接收者<code>goroutine</code>也将阻塞，直到另一个<code>goroutine</code>在相同的<code>channel</code>上执行发送操作。</p><p>无缓存<code>channel</code>的发送和接收操作会导致两个<code>goroutine</code>做一次同步操作，因此无缓存<code>channel</code>也被称为<code>同步channel</code></p><p>当通过一个无缓存<code>channel</code>发送数据时，接收者收到数据发生在唤醒发送者<code>goroutine</code>之前，被称为<code>happens before</code>。</p><p>在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// control+D 结束输入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>io.Copy(os.Stdout, conn) <span class="hljs-comment">// ignore error // 2023/09/19 00:24:20 read tcp 127.0.0.1:55690-&gt;127.0.0.1:8000: use of closed network connection</span><br>log.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// sign main goroutine</span><br>&#125;()<br>mustCopy(conn, os.Stdin)<br>conn.Close()<br>&lt;-done <span class="hljs-comment">// waiting</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br>_, err := io.Copy(dst, src)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当用户关闭了标准输入(mac系统ctrl+D)，主<code>goroutine</code>中的<code>mustCopy</code>函数调用返回，然后调用<code>conn.Close()</code>关闭读写方向的网络链接。<br>关闭网络链接中的写方向的链接将导致<code>server</code>程序收到一个文件结束的信号（EOF，end-of-file）。<br>关闭网络链接中读方向的链接将导致后台<code>goroutine</code>的<code>io.Copy</code>函数调用返回一个<code>read from closed connection</code>（从关闭的链接读）类似的错误。该例子忽略了错误日志语句。<br>在后台<code>goroutine</code>返回之前，它先打印一个日志信息，然后向<code>done</code>对应的<code>channel</code>发送一个值。主<code>goroutine</code>在退出前先等待从<code>done</code>对应的<code>channel</code>接收一个值。所以，总能在程序退出前正确输出<code>done</code>信息。</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 8.3：</strong> 在netcat3例子中，conn虽然是一个interface类型的值，但是其底层真实类型是<code>*net.TCPConn</code>，代表一个TCP链接。一个TCP链接有读和写两个部分，可以使用CloseRead和CloseWrite方法分别关闭它们。修改netcat3的主goroutine代码，只关闭网络链接中写的部分，这样的话后台goroutine可以在标准输入被关闭后继续打印从reverb1服务器传回的数据。（要在reverb2服务器也完成同样的功能是比较困难的；参考练习 8.4。）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>tcpConn := conn.(*net.TCPConn)<br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>io.Copy(os.Stdout, conn)<br>log.Println(<span class="hljs-string">&quot;done&quot;</span>)<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><br>mustCopy(conn, os.Stdin)<br><br>tcpConn.CloseWrite()<br>&lt;-done<br>tcpConn.CloseRead()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := io.Copy(dst, src); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-4-2-串联的Channels-Pipeline"><a href="#8-4-2-串联的Channels-Pipeline" class="headerlink" title="8.4.2. 串联的Channels(Pipeline)"></a>8.4.2. 串联的Channels(Pipeline)</h1><p><code>Channels</code>也可以用于将多个<code>goroutine</code>链接在一起，一个<code>Channels</code>的输出作为下一个<code>Channels</code>的输入。这种串联的<code>Channels</code>就是所谓的管道（<code>pipeline</code>）。<br>下面的程序用两个channels将三个goroutine串联起来:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>natruals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// Counter</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; ; x++ &#123;<br>natruals &lt;- x<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// Squarer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>x := &lt;-natruals<br>squares &lt;- x * x<br>&#125;<br>&#125;()<br><br><span class="hljs-comment">// Printer (in main goroutine)</span><br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(&lt;-squares)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>像这样的串联Channels的管道（<code>Pipelines</code>）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。<br>但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？<br><strong>通过内置的close函数来关闭channel实现。</strong><br><strong>当<code>channel</code>被关闭了，再向该<code>channel</code>发送数据则导致<code>paince</code>异常。</strong><br><strong>当一个被关闭的<code>channel</code>中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。</strong><br>所以上述例子中关闭<code>naturals channel</code>并不能终止循环，它依然收到一个永无休止的零值序列，然后将它们发送给打印这<code>goroutine</code>。</p><p><strong>没有办法直接测试一个channel是否被关闭。</strong><br>但接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x, ok := &lt;-naturals<br></code></pre></td></tr></table></figure><p>利用该特性，可以修改上述例子中的squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Squarer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">for</span> &#123;<br>        x, ok := &lt;-naturals<br>        <span class="hljs-keyword">if</span> !ok &#123;<br>            <span class="hljs-keyword">break</span> <span class="hljs-comment">// channel was closed and drained</span><br>        &#125;<br>        squares &lt;- x * x<br>    &#125;<br>    <span class="hljs-built_in">close</span>(squares)<br>&#125;()<br></code></pre></td></tr></table></figure><p>上面的写法很笨拙，可以使用<code>for...range</code>循环的简洁特性直接迭代。</p><p>在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><br><span class="hljs-comment">// Counter</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt;= <span class="hljs-number">100</span>; x++ &#123;<br>naturals &lt;- x<br>&#125;<br><span class="hljs-built_in">close</span>(naturals)<br>&#125;()<br><br><span class="hljs-comment">// Squarer</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> naturals &#123;<br>squares &lt;- x * x<br>&#125;<br><span class="hljs-built_in">close</span>(squares)<br>&#125;()<br><br><span class="hljs-comment">// Printer</span><br><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> squares &#123;<br>fmt.Println(x)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实并不需要关闭每一个<code>channel</code>。只要当需要告诉接收者<code>goroutine</code>，所有的数据已经全部发送时才需要关闭<code>channel</code>。<br><strong>不管一个<code>channel</code>是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。</strong><br>与关闭已打开文件的操作不同，文件在不使用时都要调用其close方法进行关闭。</p><p><strong>重复关闭同一个channel都会导致panic异常。</strong><br><strong>关闭nil值的channel都会导致panic异常。</strong></p><h1 id="8-4-3-单方向的Channel"><a href="#8-4-3-单方向的Channel" class="headerlink" title="8.4.3. 单方向的Channel"></a>8.4.3. 单方向的Channel</h1><p>将上述例子中的三个<code>goroutine</code>拆分成三个小函数，使用两个<code>channel</code>连接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out, in <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span>”<br></code></pre></td></tr></table></figure><p>每个函数都有相同类型的参数<code>chan int</code>，但是为了函数的健壮性，<code>out</code>只输出，<code>in</code>只输入。<br>Go语言的类型系统提供了单方向的<code>channel</code>类型，分别用于只发送或只接收的<code>channel</code>。<br>类型<code>chan&lt;-int</code>表示只发送int类型的<code>channel</code>；<br>类型<code>&lt;-chan int</code>表示只接收int类型的<code>channel</code>；<br>需要注意的是：<br>因为<code>close</code>操作只作用于不再往<code>channel</code>发送数据，所以在发送者的<code>goroutine</code>中进行<code>close</code>操作。<br><strong>如果只接收的<code>channel</code>进行<code>close</code>操作会导致编译期错误。</strong><br>下面是改进后的版本：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;<br>out &lt;- x<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> in &#123;<br>out &lt;- x * x<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> in &#123;<br>fmt.Println(x)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br>squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>)<br><span class="hljs-keyword">go</span> counter(naturals)<br><span class="hljs-keyword">go</span> squarer(squares, naturals)<br>printer(squares)<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>counter(naturals)</code>将<code>chan int</code>类型的<code>naturals</code>隐式地转换为<code>chan&lt;- int</code>类型只发送型的<code>channel</code>。<br>调用<code>printer(squares)</code>也会进行相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的<code>channel</code>。<br><strong>任何双向<code>channel</code>向单向<code>channel</code>变量的赋值操作都将导致该隐式转换。</strong><br><strong>注意得是，并没有单向<code>channel</code>(如 chan&lt;-int)转换成双向类型的<code>channel</code>(chan int).</strong></p><h1 id="8-4-4-带缓存的Channels"><a href="#8-4-4-带缓存的Channels" class="headerlink" title="8.4.4. 带缓存的Channels"></a>8.4.4. 带缓存的Channels</h1><p>带缓存的<code>channel</code>内部持有一个队列。<br>队列的最大容量是定义<code>channel</code>时的第二个参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><p>缓存Channel的<code>发送操作</code>就是向内部缓存队列的尾部插入元素。<br><code>接收操作</code>则是从队列的头部删除元素。<br>如果内部缓存队列是满的，那么发送操作将阻塞，直到另一个<code>goroutine</code>执行接收操作而释放新空间。<br>相反，如果内部缓存队列是空的，那么接收操作将阻塞，直到另一个<code>goroutine</code>执行发生操作而向缓存队列插入元素。<br>无阻塞的状态下，<code>channel</code>进行连续发送操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch &lt;- <span class="hljs-string">&quot;A&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;B&quot;</span><br>ch &lt;- <span class="hljs-string">&quot;C&quot;</span><br></code></pre></td></tr></table></figure><p>当前<code>channel</code>的缓存队列已满，已阻塞，那么进行接收操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">println</span>(&lt;-ch)<br></code></pre></td></tr></table></figure><p>此时，缓存队列不是满的，也不是空的，<code>channel</code>也不阻塞，可以进行发送或接收操作。<br>也就是说，有缓存<code>channel</code>实际上是解耦了<code>发送</code>和<code>接收</code>操作。<br>示意图如下：<br><img src="/./images/1695570577915.png" alt="有缓存channel的发送和接收操作"></p><p>channel内部缓存容量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">cap</span>(ch)) <span class="hljs-comment">// &quot;3”</span><br></code></pre></td></tr></table></figure><p>channel内部缓存队列中有效元素的个数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// &quot;2”</span><br></code></pre></td></tr></table></figure><p>因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。</p><p>下面的例子展示了一个使用了带缓存<code>channel</code>的应用。<br>程序并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存<code>channel</code>，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此<code>mirroredQuery</code>函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。（顺便说一下，多个<code>goroutines</code>并发地向同一个<code>channel</code>发送数据，或从同一个<code>channel</code>接收数据都是常见的用法。）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirroredQuery</span><span class="hljs-params">()</span></span> <span class="hljs-type">string</span> &#123;<br>    responses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>, <span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;asia.gopl.io&quot;</span>) &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;europe.gopl.io&quot;</span>) &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;americas.gopl.io&quot;</span>) &#125;()<br>    <span class="hljs-keyword">return</span> &lt;-responses <span class="hljs-comment">// return the quickest response</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(hostname <span class="hljs-type">string</span>)</span></span> (response <span class="hljs-type">string</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>如果使用了无缓存的<code>channel</code>，那么两个慢的<code>goroutine</code>将会因没有接收者而永远阻塞，这种情况称为<code>goroutine泄露</code>。<br>与垃圾回收机制不同，泄露的<code>goroutine</code>并不会被自动回收，因此确保每个不再需要的<code>gotoutinr</code>能正常退出是很重要的。</p><h1 id="无缓存和带缓存的channel的选择"><a href="#无缓存和带缓存的channel的选择" class="headerlink" title="无缓存和带缓存的channel的选择"></a>无缓存和带缓存的channel的选择</h1><p>无缓存和带缓存的channel选择其实也是带缓存<code>channel</code>容量大小的选择。</p><p>无缓存channel能保证每个发送操作与相应的接收操作同步。<br>带缓存channel中，发送和接收操作是解耦的。</p><p>即使知道发送到<code>channel</code>上的信息的数量上限，创建一个对应容量大小带缓存<code>channel</code>也是不现实的。因为如果在执行接收操作前缓存了所有已经发送的值，在未能分配足够的缓冲将导致死锁。 </p><p><code>channel</code>的缓存也可能影响程序的性能。<br>发送操作和接收操作的速率不一致，将会导致整个流程的进度。<br>所以如何合理分配<code>channel</code>的缓存容量，要依实际需求而决定。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.3. 示例：并发的Echo服务器</title>
      <link href="/posts/10cf7d1432ab/"/>
      <url>/posts/10cf7d1432ab/</url>
      
        <content type="html"><![CDATA[<p><code>Echo</code>服务器一般情况下会返回它接收到的内容。<br>类似回音，一开始返回全大写的内容，如HELLO，表示<code>声音很大</code>； 间隔一定时间后，返回有所缓和的<code>Hello</code>；最后返回一个表示声音很小的全小写<code>hello</code>直至消失。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Reverb1 is a TCP server that simulates an echo.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>echo(conn, input.Text(), <span class="hljs-number">1</span>*time.Second)<br>&#125;<br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(conn net.Conn, shout <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToUpper(shout))<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, shout)<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToLower(shout))<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来要对客户端进行改造，将终端返回的数据打印到标准输出，将标准输入发送到终端。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">go</span> mustCopy(os.Stdout, conn)<br>mustCopy(conn, os.Stdin)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := io.Copy(dst, src); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>main goroutine</code>从标准输入流中读取内容并把它发送到服务器时，另一个<code>goroutine</code>获取服务器发生来的内容并打印出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ../reverb1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./reverb1 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ../netcat2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./netcat2</span><br>Hello?<br>         ISHELLO?<br>         IsHello?<br>         ishello?<br>Hello?<br>         HELLO?<br>         Hello?<br>         hello?<br>Is there anybody there?<br>         IS THERE ANYBODY THERE?<br>A<br> Is there anybody there?<br>         is there anybody there?<br>         A<br>         A<br>         a<br>^D<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">killall reverb1</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">killall netcat2</span><br></code></pre></td></tr></table></figure><p>在第三次<code>shout</code>的时候，<code>A</code>在等上一次回响完成后才能进行回响，这种情况是不<code>现实</code>的。为了模拟现实世界的回响，可以再使用<code>goroutine</code>进行处理<code>echo</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br>input := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br><span class="hljs-keyword">go</span> echo(conn, input.Text(), <span class="hljs-number">1</span>*time.Second)<br>&#125;<br>conn.Close()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(conn net.Conn, shout <span class="hljs-type">string</span>, delay time.Duration)</span></span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToUpper(shout))<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, shout)<br>time.Sleep(delay)<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToLower(shout))<br>&#125;<br></code></pre></td></tr></table></figure><p>现在回响是并发并且会按时间来覆盖掉其它响应了：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ../reverb2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./reverb2 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ../netcat2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./netcat2</span><br>Hello?<br>         HELLO?<br>         Hello?<br>         hello?<br>Call<br>         CALL<br>         Call<br>A<br>         A<br>         call<br>         A<br>         a<br>B<br>         B<br>C<br>         C<br>         B<br>         C<br>         b<br>         c<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.2. 示例：并发的Clock服务</title>
      <link href="/posts/fca3f5579354/"/>
      <url>/posts/fca3f5579354/</url>
      
        <content type="html"><![CDATA[<p>网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自远彼此独立的客户端。</p><h1 id="第一个例子"><a href="#第一个例子" class="headerlink" title="第一个例子"></a>第一个例子</h1><p>第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Clock1 is a TCP server that periodically writes the time.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err) <span class="hljs-comment">// e.g., connection aborted</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">for</span> &#123;<br>_, err := io.WriteString(conn, time.Now().Format(<span class="hljs-string">&quot;15:04:05\n&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Listen</code>函数创建了一个<code>net.Listener</code>的对象，该对象会监听一个网络端口上到的连接。<code>listener</code>对象的<code>Accept</code>方法会直接阻塞，直到一个新的连接被创建，然后会返回一个<code>net.Conn</code>对象来表示这个连接。<br><code>handleConn</code>函数处理一个完整的客户端连接。在一个<code>for</code>死循环中，将当前时间<code>time.Now()</code>写到客户端。由于<code>net.Conn</code>实现了<code>io.Writer</code>接口，所以可以直接写入内容。死循环直到出错才退出循环，一般情况下，客户端主动断开连接。<br>使用<code>defer</code>关闭<code>conn.Close()</code>服务器侧的连接，然后返回到主函数，继续等待下一个连接请求。<br><code>time.Time.Format</code>方法用于格式化日期和时间。其参数是格式化模版标识如何格式化时间，格式化模板为<code>Mon Jan 2 03:04:05PM 2006 UTC-0700</code>。<br>与其他编程语言<code>Y-m-d H:M:S</code>不同的是，格式化模板为<code>1月2日下午3点4分5秒2006年UTC-0700</code>，即<code>1234567</code>。<br>为了连接例子中的服务器，可以使用<code>Unix</code>中<code>netcat</code>工具中的<code>nc</code>命令。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> build ../clock1<br>$ ./clock1 &amp;<br>[<span class="hljs-number">1</span>] <span class="hljs-number">1822</span><br>$ nc localhost <span class="hljs-number">8000</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">49</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">50</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">51</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">52</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">53</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">54</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55</span><br><span class="hljs-number">19</span>:<span class="hljs-number">13</span>:<span class="hljs-number">56</span><br>^C<br>$ killall clock1<br>[<span class="hljs-number">1</span>]+  Terminated: <span class="hljs-number">15</span>          ./clock1<br></code></pre></td></tr></table></figure><p><code>./clock1 &amp;</code>指的是在后台运行;<br><code>nc</code>命令连接服务器访问地址；<br><code>Ctrl+C</code>中断客户端访问，停止访问；<br><code>killall</code>是杀掉名字匹配的进程；<br>没有<code>nc</code>，也可以使用<code>telnet</code>命令实现。<br>也可以使用下面telnet程序进行访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br>mustCopy(os.Stdout, conn)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := io.Copy(dst, src); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序会从连接中读取数据，并将读到的内容写入到标准输出中，直到发生<code>end of file</code>和发生错误。<br>下面是测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> build ../netcat1<br>$ ./netcat1 <br><span class="hljs-number">19</span>:<span class="hljs-number">44</span>:<span class="hljs-number">51</span><br><span class="hljs-number">19</span>:<span class="hljs-number">44</span>:<span class="hljs-number">52</span><br><span class="hljs-number">19</span>:<span class="hljs-number">44</span>:<span class="hljs-number">53</span><br>^C<br>$ killall clock1<br></code></pre></td></tr></table></figure><p>上述例子中的服务器同一时间只能处理一个客户端连接。第二个客户端必须等待第一个客户端的完成访问，才能继续往后执行。<br>下面的例子将服务器改成并发，在<code>handleConn</code>函数前加上<code>go</code>关键字，让每一次<code>handleConn</code>的调用都进入一个独立的<code>goroutine</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">for</span> &#123;<br>_, err := io.WriteString(conn, time.Now().Format(<span class="hljs-string">&quot;15:04:05\n&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样多个客户端能够同时接收到时间：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ../clock2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./clock2 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./netcat1</span> <br>19:44:51<br>19:44:52<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./netcat1</span><br>19:44:55<br>19:44:56<br></code></pre></td></tr></table></figure><p><strong>练习 8.1：</strong> 修改clock2来支持传入参数作为端口号，然后写一个clockwall的程序，这个程序可以同时与多个clock服务器通信，从多服务器中读取时间，并且在一个表格中一次显示所有服务传回的结果，类似于你在某些办公室里看到的时钟墙。如果你有地理学上分布式的服务器可以用的话，让这些服务器跑在不同的机器上面；或者在同一台机器上跑多个不同的实例，这些实例监听不同的端口，假装自己在不同的时区。像下面这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">TZ=US/Eastern    ./clock2 -port 8010 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">TZ=Asia/Tokyo    ./clock2 -port 8020 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">TZ=Europe/London ./clock2 -port 8030 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">clockwall NewYork=localhost:8010 Tokyo=localhost:8020 London=localhost:8030</span><br></code></pre></td></tr></table></figure><p>解：<br>clock.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> port = flag.String(<span class="hljs-string">&quot;port&quot;</span>, <span class="hljs-string">&quot;8000&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:&quot;</span>+*port)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">for</span> &#123;<br>_, err := io.WriteString(conn, time.Now().Format(<span class="hljs-string">&quot;15:04:05\n&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>clockwall.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> server <span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-type">string</span><br>addr    <span class="hljs-type">string</span><br>message <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>servers := parse(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">for</span> _, ser := <span class="hljs-keyword">range</span> servers &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, ser.addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ser *server)</span></span> &#123;<br>sc := bufio.NewScanner(conn)<br><span class="hljs-keyword">for</span> sc.Scan() &#123;<br>ser.message = sc.Text()<br>&#125;<br>&#125;(ser)<br>&#125;<br><br><span class="hljs-keyword">for</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">for</span> _, ser := <span class="hljs-keyword">range</span> servers &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, ser.name, ser.message)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;-------------&quot;</span>)<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parse</span><span class="hljs-params">(args []<span class="hljs-type">string</span>)</span></span> []*server &#123;<br><span class="hljs-keyword">var</span> servers []*server<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> args &#123;<br>s := strings.SplitN(arg, <span class="hljs-string">&quot;=&quot;</span>, <span class="hljs-number">2</span>)<br>servers = <span class="hljs-built_in">append</span>(servers, &amp;server&#123;s[<span class="hljs-number">0</span>], s[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;&quot;</span>&#125;)<br>&#125;<br><span class="hljs-keyword">return</span> servers<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 8.2：</strong> 实现一个并发FTP服务器。服务器应该解析客户端来的一些命令，比如cd命令来切换目录，ls来列出目录内文件，get和send来传输文件，close来关闭连接。你可以用标准的ftp命令来作为客户端，或者也可以自己实现一个。<br>解：<br>server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listener.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> handleConn(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br>sc := bufio.NewScanner(conn)<br>cwd := <span class="hljs-string">&quot;.&quot;</span><br><br>CLOSE:<br><span class="hljs-keyword">for</span> sc.Scan() &#123;<br>log.Println(sc.Text())<br>args := strings.Fields(sc.Text())<br>cmd := args[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">switch</span> cmd &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br><span class="hljs-keyword">break</span> CLOSE<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;cd&quot;</span>:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &lt; <span class="hljs-number">2</span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;not enough argument&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>cwd += <span class="hljs-string">&quot;/&quot;</span> + args[<span class="hljs-number">1</span>]<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ls&quot;</span>:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &lt; <span class="hljs-number">2</span> &#123;<br>ls(conn, cwd)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>path := args[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">if</span> err := ls(conn, path); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(conn, err)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;get&quot;</span>:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &lt; <span class="hljs-number">2</span> &#123;<br>fmt.Fprintln(conn, <span class="hljs-string">&quot;not enough argument&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>filename := args[<span class="hljs-number">1</span>]<br>data, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(conn, err)<br>&#125;<br>fmt.Fprintf(conn, <span class="hljs-string">&quot;%s\n&quot;</span>, data)<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>sp := strings.Split(args[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;/&quot;</span>)<br>filename := sp[<span class="hljs-built_in">len</span>(sp)<span class="hljs-number">-1</span>]<br>f, err := os.Create(<span class="hljs-string">&quot;./ex/ex8/ex8.2/server/&quot;</span> + filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(conn, err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br>c, err := strconv.Atoi(args[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(conn, err)<br>&#125;<br><br><span class="hljs-keyword">var</span> texts <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; c &amp;&amp; sc.Scan(); i++ &#123;<br>texts += sc.Text() + <span class="hljs-string">&quot;\n&quot;</span><br>&#125;<br>texts = strings.TrimSuffix(texts, <span class="hljs-string">&quot;\n&quot;</span>)<br>fmt.Fprint(f, texts)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ls</span><span class="hljs-params">(w io.Writer, dir <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>files, err := os.ReadDir(dir)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">for</span> _, file := <span class="hljs-keyword">range</span> files &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s\n&quot;</span>, file.Name())<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8888&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">go</span> mustCopy(os.Stdout, conn)<br><br>sc := bufio.NewScanner(os.Stdin)<br>CLOSE:<br><span class="hljs-keyword">for</span> sc.Scan() &#123;<br>args := strings.Fields(sc.Text())<br>cmd := args[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">switch</span> cmd &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;close&quot;</span>:<br>fmt.Fprintln(conn, sc.Text())<br><span class="hljs-keyword">break</span> CLOSE<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;ls&quot;</span>, <span class="hljs-string">&quot;cd&quot;</span>, <span class="hljs-string">&quot;get&quot;</span>:<br>fmt.Fprintln(conn, sc.Text())<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(args) &lt; <span class="hljs-number">2</span> &#123;<br>log.Println(<span class="hljs-string">&quot;not enough argument&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>filename := args[<span class="hljs-number">1</span>]<br>data, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Printf(<span class="hljs-string">&quot;read file err: %v&quot;</span>, err)<br>&#125;<br>fmt.Fprintf(conn, <span class="hljs-string">&quot;%s %d\n&quot;</span>, sc.Text(), countLines(data))<br>fmt.Fprintf(conn, <span class="hljs-string">&quot;%s&quot;</span>, data)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(data []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br>sc := bufio.NewScanner(bytes.NewReader(data))<br><span class="hljs-keyword">for</span> sc.Scan() &#123;<br>c++<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<br><span class="hljs-keyword">if</span> _, err := io.Copy(dst, src); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8.1. Goroutines</title>
      <link href="/posts/dbf6e956aad2/"/>
      <url>/posts/dbf6e956aad2/</url>
      
        <content type="html"><![CDATA[<p>在Go语言中，每一个并发的执行单元叫作一个<code>goroutine</code>。<br>新的<code>goroutine</code>会用<code>go</code>语句来创建。在语法上，<code>go</code>语句是一个普通的函数或方法调用前加上关键字<code>go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">f()<br><span class="hljs-keyword">go</span> f()<br></code></pre></td></tr></table></figure><p>下面的例子，<code>main goroutine</code>将计算菲波那契数列的第45个元素值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> spinner(<span class="hljs-number">100</span> * time.Millisecond)<br><span class="hljs-keyword">const</span> n = <span class="hljs-number">45</span><br>fibN := fib(n) <span class="hljs-comment">// slow</span><br>fmt.Printf(<span class="hljs-string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinner</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">`——\|/`</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\r%c&quot;</span>, r) <span class="hljs-comment">// \r转义字符，将光标移动到当前行的首位，以便下次输出覆盖该行内容。</span><br>time.Sleep(delay)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-keyword">return</span> fib(x<span class="hljs-number">-1</span>) + fib(x<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>动画显示了几秒之后，fib(45)的调用成功地返回，并且打印结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Fibonacci(<span class="hljs-number">45</span>) = <span class="hljs-number">1134903170</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第八章 Goroutines和Channels</title>
      <link href="/posts/160e8baeca27/"/>
      <url>/posts/160e8baeca27/</url>
      
        <content type="html"><![CDATA[<p>并发程序指同时进行多个任务的程序。<br>Go语言中的并发程序可以用两种手段来实现。</p><ul><li>goroutine</li><li>channel</li></ul><p>还支持<code>顺序通信进程（communicating sequential processes）</code>，简称<code>CSP</code>。<code>CSP</code>是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例<code>goroutine</code>中传递，尽管会别被限制在单一实例中。<br>第9章则是更为传统的并发模型：<code>多线程共享内存</code>。</p><p><a href="/posts/dbf6e956aad2/">8.1. Goroutines</a><br><a href="/posts/fca3f5579354/">8.2. 示例：并发的Clock服务</a><br><a href="">8.3. 示例：并发的Echo服务</a><br><a href="/posts/e24baaf2eab7/">8.4. Channels</a><br><a href="/posts/5f0a41aff939/">8.5. 并发的循环</a><br><a href="/posts/1258766bd2ef/">8.6. 示例：并发的Web爬虫</a><br><a href="/posts/866000668cee/">8.7. 基于select的多路复用</a><br><a href="/posts/dbf617f2750e/">8.8. 示例：并发的字典遍历</a><br><a href="/posts/92d779dbee59/">8.9. 并发的退出</a><br><a href="/posts/b4674e4b8337/">8.10. 示例：聊天服务</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.15. 一些建议</title>
      <link href="/posts/8520b52085ef/"/>
      <url>/posts/8520b52085ef/</url>
      
        <content type="html"><![CDATA[<p>当设计一个新包时，一般情况下是创建一个接口的集合开始和定义它们的具体类型。<br>这种方式会导致有很多接口，且每一个都会仅有一个实现。<br>这种设计方式是错误的，这种接口是不必要的抽象，且还有运行时损耗。<br>实际上，可以使用导出机制来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有在当两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p><p>当一个接口只被一个具体类型实现时，往往是因为依赖，即依赖于另外一个包内的接口类型。这种情况下，<code>一个接口是解耦两个包的一个好的方式</code>。</p><p>在Go语言中只有当两个或更多的类型需要实现同一个接口时才使用接口。接口尽量使用小接口，方法尽可能少，如<code>io.Writer</code>或<code>fmt.Stringer</code>只有一个方法。<br>对于接口设计的一个好的标准就是<code>ask only for what you need</code>(只考虑你需要的)。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.14. 示例：基于标记的XML解码</title>
      <link href="/posts/c380e460aca4/"/>
      <url>/posts/c380e460aca4/</url>
      
        <content type="html"><![CDATA[<p>第4.5章节展示了如何使用<code>encoding/json</code>包中的<code>Marshal</code>和<code>Unmarshal</code>函数来将JSON文档转换成Go语言的数据结构。<code>encoding/xml</code>包提供了一个相似的API。<br><code>encoding/xml</code>包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入和产生一个标记流；四个主要的标记类型－<code>StartElement</code>，<code>EndElement</code>，<code>CharData</code>，和<code>Comment</code>－每一个都是<code>encoding/xml</code>包中的具体类型。每一个对<code>(*xml.Decoder).Token</code>的调用都返回一个标记。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xml<br><br><span class="hljs-keyword">type</span> Name <span class="hljs-keyword">struct</span> &#123;<br>    Local <span class="hljs-type">string</span> <span class="hljs-comment">// e.g., &quot;Title&quot; or &quot;id&quot;</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Attr <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// e.g., name=&quot;value&quot;</span><br>    Name  Name<br>    Value <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">// A Token includes StartElement, EndElement, CharData,</span><br><span class="hljs-comment">// and Comment, plus a few esoteric types (not shown).</span><br><span class="hljs-keyword">type</span> Token <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">type</span> StartElement <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// e.g., &lt;name&gt;</span><br>    Name Name<br>    Attr []Attr<br>&#125;<br><span class="hljs-keyword">type</span> EndElement <span class="hljs-keyword">struct</span> &#123; Name Name &#125; <span class="hljs-comment">// e.g., &lt;/name&gt;</span><br><span class="hljs-keyword">type</span> CharData []<span class="hljs-type">byte</span>                 <span class="hljs-comment">// e.g., &lt;p&gt;CharData&lt;/p&gt;</span><br><span class="hljs-keyword">type</span> Comment []<span class="hljs-type">byte</span>                  <span class="hljs-comment">// e.g., &lt;!-- Comment --&gt;</span><br><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">struct</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDecoder</span><span class="hljs-params">(io.Reader)</span></span> *Decoder<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*Decoder)</span></span> Token() (Token, <span class="hljs-type">error</span>) <span class="hljs-comment">// returns next Token in sequence</span><br></code></pre></td></tr></table></figure><p>这个没有方法的Token接口也是一个可识别联合的例子。<br>传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现。<br>在这个实现中每个具体类型都被统一地对待。<br>相反，<code>满足可识别联合的具体类型的集合被设计确定和暴露，而不是隐藏。</code><br><code>可识别的联合类型几乎没有方法；</code><br><code>操作它们的函数使用一个类型开关的case集合来进行表述；</code><br><code>这个case集合中每一个case中有不同的逻辑。</code></p><p>下面的<code>xmlselect</code>程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要具体化这个文档树。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Xmlselect prints the text of selected elements of an XML document.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/xml&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dec := xml.NewDecoder(os.Stdin)<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> &#123;<br>tok, err := dec.Token()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;xmlselect: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">switch</span> tok := tok.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> xml.StartElement:<br>stack = <span class="hljs-built_in">append</span>(stack, tok.Name.Local) <span class="hljs-comment">// push</span><br><span class="hljs-keyword">case</span> xml.EndElement:<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span><br><span class="hljs-keyword">case</span> xml.CharData:<br><span class="hljs-keyword">if</span> containsAll(stack, os.Args[<span class="hljs-number">1</span>:]) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, strings.Join(stack, <span class="hljs-string">&quot; &quot;</span>), tok)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// containsAll reports whether x contains the elements of y, in order</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(x, y []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(y) &lt;= <span class="hljs-built_in">len</span>(x) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>] == y[<span class="hljs-number">0</span>] &#123;<br>y = y[<span class="hljs-number">1</span>:]<br>&#125;<br>x = x[<span class="hljs-number">1</span>:]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build -o xmlselect ./main.go</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">../../ch1/fetch http://www.w3.org/TR/2006/REC-xml11-20060816 | ./xmlselect div div h2</span><br>html body div div h2: 1 Introduction<br>html body div div h2: 2 Documents<br>html body div div h2: 3 Logical Structures<br>html body div div h2: 4 Physical Structures<br>html body div div h2: 5 Conformance<br>html body div div h2: 6 Notation<br>html body div div h2: A References<br>html body div div h2: B Definitions for Character Normalization<br>html body div div h2: C Expansion of Entity and Character References (Non-Normative)<br>html body div div h2: D Deterministic Content Models (Non-Normative)<br>html body div div h2: E Autodetection of Character Encodings (Non-Normative)<br>html body div div h2: F W3C XML Working Group (Non-Normative)<br>html body div div h2: G W3C XML Core Working Group (Non-Normative)<br>html body div div h2: H Production Notes (Non-Normative)<br>html body div div h2: I Suggestions for XML Names (Non-Normative)<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.17：</strong> 扩展xmlselect程序以便让元素不仅仅可以通过名称选择，也可以通过它们CSS样式上属性进行选择；例如一个像这样的元素可以通过匹配id或者class同时还有它的名称来进行选择。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/xml&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// cat in.html | go run main.go id=p3</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>decoder := xml.NewDecoder(os.Stdin)<br><span class="hljs-keyword">var</span> stack []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> attrs []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> &#123;<br>token, err := decoder.Token()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;xmlselect: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">switch</span> token := token.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> xml.StartElement:<br>stack = <span class="hljs-built_in">append</span>(stack, token.Name.Local) <span class="hljs-comment">// push</span><br>attr := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> token.Attr &#123;<br>attr[a.Name.Local] = a.Value<br>&#125;<br>attrs = <span class="hljs-built_in">append</span>(attrs, attr)<br><span class="hljs-keyword">case</span> xml.EndElement:<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span><br>attrs = attrs[:<span class="hljs-built_in">len</span>(attrs)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">case</span> xml.CharData:<br><span class="hljs-keyword">if</span> containsAll(toSlice(stack, attrs), os.Args[<span class="hljs-number">1</span>:]) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, strings.Join(stack, <span class="hljs-string">&quot; &quot;</span>), token)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(x, y []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(y) &lt;= <span class="hljs-built_in">len</span>(x) &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>] == y[<span class="hljs-number">0</span>] &#123;<br>y = y[<span class="hljs-number">1</span>:]<br>&#125;<br>x = x[<span class="hljs-number">1</span>:]<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toSlice</span><span class="hljs-params">(stack []<span class="hljs-type">string</span>, attrs []<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> result []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i, name := <span class="hljs-keyword">range</span> stack &#123;<br>result = <span class="hljs-built_in">append</span>(result, name)<br><span class="hljs-keyword">for</span> attr, value := <span class="hljs-keyword">range</span> attrs[i] &#123;<br>result = <span class="hljs-built_in">append</span>(result, attr+<span class="hljs-string">&quot;=&quot;</span>+value)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><p>in.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="hljs-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xml:lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Extensible Markup Language (XML) 1.1 (Second Edition)<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d1&quot;</span>&gt;</span>d1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d2&quot;</span>&gt;</span>d2<br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;d3&quot;</span>&gt;</span>d3<br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span>p3<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>p2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>p1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>练习 7.18：</strong> 使用基于标记的解码API，编写一个可以读取任意XML文档和构造这个文档所代表的普通节点树的程序。节点有两种类型：CharData节点表示文本字符串，和 Element节点表示被命名的元素和它们的属性。每一个元素节点有一个字节点的切片。<br>你可能发现下面的定义会对你有帮助。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;encoding/xml&quot;</span><br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">interface</span>&#123;&#125; <span class="hljs-comment">// CharData or *Element</span><br><br><span class="hljs-keyword">type</span> CharData <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>    Type     xml.Name<br>    Attr     []xml.Attr<br>    Children []Node<br>&#125;<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/xml&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// cat in.html | go run main.go</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>node, err := parse(xml.NewDecoder(os.Stdin))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, node)<br>&#125;<br><br><span class="hljs-keyword">type</span> Node <span class="hljs-keyword">interface</span> &#123;<br>String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> CharData <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CharData)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(c)<br>&#125;<br><br><span class="hljs-keyword">type</span> Element <span class="hljs-keyword">struct</span> &#123;<br>Type     xml.Name<br>Attr     []xml.Attr<br>Children []Node<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *Element)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> attrs, children <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, attr := <span class="hljs-keyword">range</span> e.Attr &#123;<br>attrs += fmt.Sprintf(<span class="hljs-string">&quot; %s=%q&quot;</span>, attr.Name.Local, attr.Value)<br>&#125;<br><span class="hljs-keyword">for</span> _, child := <span class="hljs-keyword">range</span> e.Children &#123;<br>children += child.String()<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;&lt;%s%s&gt;%s&lt;%s&gt;&quot;</span>,<br>e.Type.Local, attrs, children, e.Type.Local)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parse</span><span class="hljs-params">(dec *xml.Decoder)</span></span> (Node, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> stack []*Element<br><span class="hljs-keyword">for</span> &#123;<br>token, err := dec.Token()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">switch</span> token := token.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> xml.StartElement:<br>e := &amp;Element&#123;token.Name, token.Attr, []Node&#123;&#125;&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>p := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>p.Children = <span class="hljs-built_in">append</span>(p.Children, e)<br>&#125;<br>stack = <span class="hljs-built_in">append</span>(stack, e)<br><span class="hljs-keyword">case</span> xml.EndElement:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected tag closing&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">return</span> stack[<span class="hljs-number">0</span>], <span class="hljs-literal">nil</span><br>&#125;<br>stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br><span class="hljs-keyword">case</span> xml.CharData:<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(stack) &gt; <span class="hljs-number">0</span> &#123;<br>p := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>]<br>p.Children = <span class="hljs-built_in">append</span>(p.Children, CharData(token))<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.13. 类型开关</title>
      <link href="/posts/c4e3ed798cee/"/>
      <url>/posts/c4e3ed798cee/</url>
      
        <content type="html"><![CDATA[<p>接口一般以两种方式使用。</p><ul><li>第一个方式中，<code>io.Reader</code>、<code>io.Writer</code>、<code>fmt.Stringer</code>、<code>sort.Interface</code>、<code>http.Handler</code>、和<code>error</code>为例，一个接口的方法表达了实现这个接口的具体类型间的相思性，但是隐藏了代表的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</li><li>第二个方式利用一个接口值可以持有各种具体类型值的能力并且将这个接口认为是这些类型的<code>union</code>（联合）。类型断言用来动态地区别这些类型并且对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不是在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为<code>discriminated unions</code>（可辨识联合）。</li></ul><p>在面向对象编程中，这两种方式分别是<code>subtype polymorphism</code>（子类型多态）和 <code>ad-hoc polymorphism</code>（非参数多态）</p><h1 id="SQL数据库例子"><a href="#SQL数据库例子" class="headerlink" title="SQL数据库例子"></a>SQL数据库例子</h1><p>Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;database/sql&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">listTracks</span><span class="hljs-params">(db sql.DB, artist <span class="hljs-type">string</span>, minYear, maxYear <span class="hljs-type">int</span>)</span></span> &#123;<br>db.Exec(<span class="hljs-string">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span>,<br>artist, minYear, maxYear)<br><span class="hljs-comment">// ...</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>Exec方法使用SQL字面量替换在查询字符串中的每个’?’；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。<br>这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对手可以通过利用输入内容中不正确的引文来控制查询语句。</p><p>在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">int</span>); ok &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">uint</span>); ok &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b, ok := x.(<span class="hljs-type">bool</span>); ok &#123;<br><span class="hljs-keyword">if</span> b &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-type">string</span>); ok &#123;<br><span class="hljs-keyword">return</span> sqlQuoteString(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>switch</code>语句简化<code>if-else</code>链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:       <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>, <span class="hljs-type">uint</span>: <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:      <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">default</span>:        <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>和普通<code>switch</code>语句一样，每一个<code>case</code>会被顺序的进行考虑，并且当一个匹配找到时，这个<code>case</code>中的内容会被执行。当一个或多个<code>case</code>类型是接口时，<code>case</code>的顺序就会变得很重要，因为可能会有两个<code>case</code>同时匹配的情况。<code>default case</code>相对其它<code>case</code>的位置是无所谓的。它不会允许落空发生。</p><p>注意到在原来的函数中，对于<code>bool</code>和<code>string</code>情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型开关语句有一个扩展的形式，它可以将提取的值绑定到一个在每个<code>case</code>范围内的新变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>已经将新的变量也命名为<code>x</code>；和类型断言一样，重用变量名是很常见的。和一个<code>switch</code>语句相似地，一个类型开关隐式的创建了一个语言块，因此新变量<code>x</code>的定义不会和外面块中的<code>x</code>变量冲突。每一个<code>case</code>也会隐式的创建一个单独的语言块。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>, <span class="hljs-type">uint</span>:<br>        <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x) <span class="hljs-comment">// x has type interface&#123;&#125; here.</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">bool</span>:<br>        <span class="hljs-keyword">if</span> x &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:<br>        <span class="hljs-keyword">return</span> sqlQuoteString(x) <span class="hljs-comment">// (not shown)</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>当多个case需要相同的操作时，比如int和uint的情况，类型开关可以进行合并。</code><br>虽然<code>x</code>的类型是<code>interface&#123;&#125;</code>，但是我们把它认为是一个<code>int</code>，<code>uint</code>，<code>bool</code>，<code>string</code>，和<code>nil</code>值的<code>discriminated union</code>（可识别联合）。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.12. 通过类型断言询问行为</title>
      <link href="/posts/b10f700bc1c1/"/>
      <url>/posts/b10f700bc1c1/</url>
      
        <content type="html"><![CDATA[<h1 id="stringWriter"><a href="#stringWriter" class="headerlink" title="stringWriter"></a>stringWriter</h1><p>下面程序与<code>net/http</code>包中web服务器负责写入<code>HTTP</code>头字段（如：<code>Content-type:text/html</code>）的部分相似。<br><code>io.Writer</code>接口类型的变量w代表HTTP响应。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> _, err := w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;Content-Type:&quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> _, err := w.Write([]<span class="hljs-type">byte</span>(contentType)); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为<code>Write</code>方法需要传入一个<code>bbyte</code>切片，而我们希望写入的值是一个字符串，所以需要使用<code>[]byte(...)</code>进行转换。<br>这个转换还做了拷贝，而拷贝在转换后几乎立马就被丢弃掉。<br>这个内存分配可能导致服务器的速度变慢，那这里可以避免内存分配么？</p><p><code>io.Writer</code>接口的方法是<code>Write(p []byte) (n int, err error)</code>, 那么只能传入字节切片。那么程序中的<code>w</code>变量持有的动态类型也有一个允许字符串高效写入的<code>WriteString</code>方法，就可以避免分配一个临时的拷贝。<br>很多满足<code>io.Writer</code>接口的类型同时也有<code>WriteString</code>方法，包括<code>*bytes.Buffer</code>，<code>os.File</code>和<code>*bufio.Writer</code>。<br>所以假设变量<code>w</code>也拥有<code>WriteString</code>方法，且定义一个只有<code>WriteString</code>方法的新接口，还可以使用类型断言来检测是否变量w的动态类型满足这个新接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">(w io.Writer, s <span class="hljs-type">string</span>)</span></span> (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">type</span> stringWriter <span class="hljs-keyword">interface</span> &#123;<br>WriteString(<span class="hljs-type">string</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><span class="hljs-keyword">if</span> sw, ok := w.(stringWriter); ok &#123;<br><span class="hljs-keyword">return</span> sw.WriteString(s) <span class="hljs-comment">// avoid a copy</span><br>&#125;<br><span class="hljs-keyword">return</span> w.Write([]<span class="hljs-type">byte</span>(s)) <span class="hljs-comment">// allocate temporary copy</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> _, err := writeString(w, <span class="hljs-string">&quot;Content-Type:&quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> _, err := writeString(w, contentType); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为了避免重复定义，我们将这个检查移入到一个实用工具函数<code>writeString</code>中。甚至于它太有用了，标准库中也存在该函数<code>io.WriteString</code>。</p><p>这个例子神奇之处在于没有定义<code>WriteString</code>方法的标准接口和没有指定它是一个需要行为的标准接口。而是通过它的方法来决定它是否满足<code>stringWriter</code>接口。</p><h1 id="Stringer"><a href="#Stringer" class="headerlink" title="Stringer"></a>Stringer</h1><p><code>fmt.Fprintf</code>也是通过该技巧进行对其他所有值中区分满足<code>error</code>或<code>fmt.Stringer</code>接口的值。<br>在<code>fmt.Fprintf</code>中，有一个将单个操作对象转换成一个字符串的的步骤。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formatOneValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>    <span class="hljs-keyword">if</span> err, ok := x.(<span class="hljs-type">error</span>); ok &#123;<br>        <span class="hljs-keyword">return</span> err.Error()<br>    &#125;<br>    <span class="hljs-keyword">if</span> str, ok := x.(Stringer); ok &#123;<br>        <span class="hljs-keyword">return</span> str.String()<br>    &#125;<br>    <span class="hljs-comment">// ...all other types...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果<code>x</code>满足上面2个接口之一，那么满足接口决定值的格式化方式。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.11. 基于类型断言区别错误类型</title>
      <link href="/posts/179a7331746a/"/>
      <url>/posts/179a7331746a/</url>
      
        <content type="html"><![CDATA[<p>os包中文件操作返回的错误集合。<br><code>I/O</code>可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：</p><ul><li>文件已经存在（对于创建操作）  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.IsExist(err <span class="hljs-type">error</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure></li><li>找不到文件（对于读取操作）  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.IsNotExist(err <span class="hljs-type">error</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure></li><li>权限拒绝  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.IsPermission(err <span class="hljs-type">error</span>) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure></li></ul><p>可能会检测错误信息中是否包含特定的字符串的方式去实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not robust!</span><br>    <span class="hljs-keyword">return</span> strings.Contains(err.Error(), <span class="hljs-string">&quot;file does not exist&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这种方案并不健壮，处理<code>I/O</code>错误的逻辑可能一个和另一个平台非常的不同，并且对相同的失败可能报出各种不同的错误信息。</p><p>可以使用专门的类型来描述结构化的错误，如<code>os</code>包中的<code>PathError</code>类型来描述文件路径操作中涉及到的失败，如<code>Open</code>和<code>Delete</code>方法。<br>还有一个叫<code>LinkError</code>类型描述涉及到两个文件路径的操作，如<code>Symlink</code>和<code>Rename</code>方法。<br>下面是<code>PathError</code>的源码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;<br>Op   <span class="hljs-type">string</span><br>Path <span class="hljs-type">string</span><br>Err  <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span></span> Error() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error() &#125;<br></code></pre></td></tr></table></figure><p>虽然<code>PathError</code>的<code>Error</code>方法简单连接字段拼接成错误信息。<br>但是<code>PathError</code>的结构保护了内部的组件，也使得调用方需要使用类型断言来检测错误的具体类型来以便区分<code>error</code>。而且类型比字符串能提供更多细节。</p><p>下面是关于上面三个函数的工作流程：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err := os.Open(<span class="hljs-string">&quot;/no/such/file&quot;</span>)<br>fmt.Println(err)         <span class="hljs-comment">// open /no/such/file: no such file or directory</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, err) <span class="hljs-comment">// &amp;fs.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2&#125;</span><br></code></pre></td></tr></table></figure><p>下面展示的<code>IsNotExist</code>，它会报出是否一个错误和<code>syscall.ENOENT</code>(§7.8)或者和有名的错误<code>os.ErrNotExist</code>相等(可以在§5.4.2中找到io.EOF）；或者是一个<code>*PathError</code>，它内部的错误是<code>syscall.ENOENT</code>和<code>os.ErrNotExist</code>其中之一。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> underlyingErrorIs(err, ErrNotExist)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ErrNotExist</code>&#x3D;&gt;<code>os.ErrNotExist</code>&#x3D;&gt;<code>fs.ErrNotExist</code>&#x3D;&gt;<code>oserror.ErrNotExist</code>&#x3D;&gt;<code> errors.New(&quot;file does not exist&quot;)</code></p><p>方法<code>underlyingErrorIs</code>有对<code>syscall.ENOENT</code>进行相等判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">underlyingErrorIs</span><span class="hljs-params">(err, target <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// Note that this function is not errors.Is:</span><br><span class="hljs-comment">// underlyingError only unwraps the specific error-wrapping types</span><br><span class="hljs-comment">// that it historically did, not all errors implementing Unwrap().</span><br>err = underlyingError(err)<br><span class="hljs-keyword">if</span> err == target &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><span class="hljs-comment">// To preserve prior behavior, only examine syscall errors.</span><br>e, ok := err.(syscallErrorType)<br><span class="hljs-keyword">return</span> ok &amp;&amp; e.Is(target)<br>&#125;<br></code></pre></td></tr></table></figure><p>方法<code>underlyingError</code>对<code>PathError</code>进行相等判断。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">underlyingError</span><span class="hljs-params">(err <span class="hljs-type">error</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">switch</span> err := err.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> *PathError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *LinkError:<br><span class="hljs-keyword">return</span> err.Err<br><span class="hljs-keyword">case</span> *SyscallError:<br><span class="hljs-keyword">return</span> err.Err<br>&#125;<br><span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure><p>应用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err := os.Open(<span class="hljs-string">&quot;/no/such/file&quot;</span>)<br>fmt.Println(os.IsNotExist(err)) <span class="hljs-comment">// &quot;true”</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.10. 类型断言</title>
      <link href="/posts/fcef06327bd8/"/>
      <url>/posts/fcef06327bd8/</url>
      
        <content type="html"><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><p>类型断言是作用在接口值上的。<br>断言类型语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">x.(T)<br></code></pre></td></tr></table></figure><p><code>x</code>表示接口类型；<code>T</code>表示类型。<br>一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p><h1 id="具体类型"><a href="#具体类型" class="headerlink" title="具体类型"></a>具体类型</h1><p>如果断言的类型<code>T</code>是一个具体类型，然后类型断言检查<code>x</code>的动态类型是否和<code>T</code>相同。<br>如果成功了，类型断言的结果是<code>x</code>的动态值，当然它的类型是<code>T</code>。<br>如果检查失败，接下来这个操作会抛出panic。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>f := w.(*os.File) <span class="hljs-comment">// success: f == os.Stdout</span><br>c := w.(*bytes.Buffer) <span class="hljs-comment">// panic: interface conversion: io.Writer is *os.File, not *bytes.Buffer</span><br>fmt.Println(f, c)<br></code></pre></td></tr></table></figure><h1 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h1><p>如果相反断言的类型<code>T</code>是一个接口类型，然后类型断言检查是否<code>x</code>的动态类型满足T。<br>如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同类型和值部分的接口值，但是结果有类型<code>T</code>。<br>即，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但也被保护了接口值内部的动态类型和值的部分。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>rw := w.(io.ReadWriter) <span class="hljs-comment">// success: *os.File has both Read and Write</span><br>w = <span class="hljs-built_in">new</span>(ByteCounter)<br>rw = w.(io.ReadWriter) <span class="hljs-comment">// panic: interface conversion: *main.ByteCounter is not io.ReadWriter: missing method Read</span><br>fmt.Println(rw, w)<br></code></pre></td></tr></table></figure><p>在上面的第一个类型断言后，w和rw都持有<code>os.Stdout</code>，并且还有一个动态类型<code>*os.File</code>。但是变量w是一个<code>io.Writer</code>类型只对公开出文件的<code>Write</code>方法，然而<code>rw</code>变量也只公开它的<code>Read</code>方法。</p><h1 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h1><p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像赋值操作一样，除了对于nil接口值的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">w = rw             <span class="hljs-comment">// io.ReadWriter is assignable to io.Writer</span><br>w = rw.(io.Writer) <span class="hljs-comment">// fails only if rw == nil</span><br></code></pre></td></tr></table></figure><h1 id="检测接口值"><a href="#检测接口值" class="headerlink" title="检测接口值"></a>检测接口值</h1><p>一个接口值的动态类型是不确定的，并且我们更愿意去检验它是否是一些特定的类型。<br>类型断言会返回2个返回值，类型断言成功后返回的变量和是否断言成功的布尔值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer = os.Stdout<br>f, ok := w.(*os.File)      <span class="hljs-comment">// success: ok, f==os.Stdout</span><br>b, ok := w.(*bytes.Buffer) <span class="hljs-comment">// failure: !ok, b==nil</span><br></code></pre></td></tr></table></figure><p>如果断言操作失败，第一个结果等于被断言类型的零值，如该例子中就是<code>nil</code>的<code>*bytes.Buffer</code>类型。</p><p>简洁的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> f, ok := w.(*os.File); ok &#123;<br><span class="hljs-comment">// use f</span><br>&#125;<br></code></pre></td></tr></table></figure><p>变量名重用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> w, ok := w.(*os.File); ok &#123;<br><span class="hljs-comment">// use w</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.9. 示例：表达式求值</title>
      <link href="/posts/d3aed5deb5f5/"/>
      <url>/posts/d3aed5deb5f5/</url>
      
        <content type="html"><![CDATA[<h1 id="表达式求值器"><a href="#表达式求值器" class="headerlink" title="表达式求值器"></a>表达式求值器</h1><p>在本节中，我们会构建一个简单算术表达式的求值器。<br>下面为一些表达式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">sqrt(A / pi)<br>pow(x, <span class="hljs-number">3</span>) + pow(y, <span class="hljs-number">3</span>)<br>(F - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>”<br></code></pre></td></tr></table></figure><ul><li>使用一个接口Expr来表示Go语言中任意的表达式。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><code>Var</code>类型表示一个变量。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Var <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure></li><li><code>literal</code>类型表示一个浮点型常量。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> literal <span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure></li><li><code>unary</code>和<code>binary</code>类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A unary represents a unary operator expression, e.g., -x.</span><br><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;<br>op <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;,&#x27;-&#x27;</span><br>x  Expr<br>&#125;<br><br><span class="hljs-comment">// A binary represents a binary operator expression, e.g., x+y.</span><br><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;<br>op   <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;,&#x27;/&#x27;</span><br>x, y Expr<br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>call</code>类型表示对一个函数的调用。并且其字段<code>fn</code>只能是<code>pow</code>,<code>sin</code>和<code>sqrt</code>。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A call represents a function call expression, e.g., sin(x).</span><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>fn   <span class="hljs-type">string</span><br>args []Expr<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>为了计算表达式的值，还需要<code>environment</code>变量将变量的名字映射成对应的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">float64</span><br></code></pre></td></tr></table></figure><p>还要定义一个<code>Eval</code>方法，根据输入的<code>environment</code>返回表达式的值。<br>所以加入到<code>Expr</code>接口方法中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Eval returns the value of this Expr in the environment env.</span><br>Eval(env Env) <span class="hljs-type">float64</span><br>&#125;<br></code></pre></td></tr></table></figure><p>而且每个表达式都要实现该方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> env[v]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Eval(_ Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> u.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> +u.x.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> -u.x.Eval(env)<br>&#125;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported unary operator: %q&quot;</span>, u.op))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> b.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)<br>&#125;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported binary operator: %q&quot;</span>, b.op))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> c.fn &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br><span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))<br>&#125;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported function call: %s&quot;</span>, c.fn))<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以编写测试案例去验证我们的程序。<br>eval_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEval</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>expr <span class="hljs-type">string</span><br>env  Env<br>want <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">87616</span>, <span class="hljs-string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="hljs-string">&quot;167&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">12</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">10</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">-40</span>&#125;, <span class="hljs-string">&quot;-40&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">32</span>&#125;, <span class="hljs-string">&quot;0&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">212</span>&#125;, <span class="hljs-string">&quot;100&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> prevExpr <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<br><span class="hljs-keyword">if</span> test.expr != prevExpr &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\n%s\n&quot;</span>, test.expr)<br>prevExpr = test.expr<br>&#125;<br>expr, err := Parse(test.expr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err) <span class="hljs-comment">// parse error</span><br><span class="hljs-keyword">continue</span><br>&#125;<br>got := fmt.Sprintf(<span class="hljs-string">&quot;%.6g&quot;</span>, expr.Eval(test.env))<br>fmt.Printf(<span class="hljs-string">&quot;\t%v =&gt; %s\n&quot;</span>, test.env, got)<br><span class="hljs-keyword">if</span> got != test.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;%s.Eval() in %v = %q, want %q\n&quot;</span>, test.expr, test.env, got, test.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是将字符串格式的表达式转换成<code>Expr</code>类型。<br>parse.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/scanner&quot;</span><br>)<br><br><span class="hljs-comment">// This lexer is similar to the one described in Chapter 13.</span><br><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;<br>scan  scanner.Scanner<br>token <span class="hljs-type">rune</span> <span class="hljs-comment">// current lookahead token</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> text() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<br><br><span class="hljs-keyword">type</span> lexPanic <span class="hljs-type">string</span><br><br><span class="hljs-comment">// describe returns a string describing the current token, for use in errors.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> describe() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.EOF:<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end of file&quot;</span><br><span class="hljs-keyword">case</span> scanner.Ident:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;identifier %s&quot;</span>, lex.text())<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;number %s&quot;</span>, lex.text())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, <span class="hljs-type">rune</span>(lex.token)) <span class="hljs-comment">// any other rune</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">precedence</span><span class="hljs-params">(op <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Parse parses the input string as an arithmetic expression.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (_ Expr, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> x := <span class="hljs-built_in">recover</span>().(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br><span class="hljs-comment">// no panic</span><br><span class="hljs-keyword">case</span> lexPanic:<br>err = fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-comment">// unexpected panic: resume state of panic.</span><br><span class="hljs-built_in">panic</span>(x)<br>&#125;<br>&#125;()<br>lex := <span class="hljs-built_in">new</span>(lexer)<br>lex.scan.Init(strings.NewReader(input))<br>lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats<br>lex.next()<br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != scanner.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExpr</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">return</span> parseBinary(lex, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-comment">// binary = unary(&#x27;+&#x27; binary)*</span><br><span class="hljs-comment">// parseBinary stops when it encounters an</span><br><span class="hljs-comment">// operator of lower precedence than precl.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseBinary</span><span class="hljs-params">(lex *lexer, precl <span class="hljs-type">int</span>)</span></span> Expr &#123;<br>lhs := parseUnary(lex)<br><span class="hljs-keyword">for</span> prec := precedence(lex.token); prec &gt;= precl; prec-- &#123;<br><span class="hljs-keyword">for</span> precedence(lex.token) == prec &#123;<br>op := lex.token<br>lex.next()<br>rhs := parseBinary(lex, prec+<span class="hljs-number">1</span>)<br>lhs = binary&#123;op, lhs, rhs&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br><br><span class="hljs-comment">// unary = &#x27;+&#x27; expr | primary</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseUnary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">if</span> lex.token == <span class="hljs-string">&#x27;+&#x27;</span> || lex.token == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>op := lex.token<br>lex.next()<br><span class="hljs-keyword">return</span> unary&#123;op, parseUnary(lex)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> parsePrimary(lex)<br>&#125;<br><br><span class="hljs-comment">// primary = id</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//   | id &#x27;(&#x27; expr &#x27;,&#x27; ... &#x27;,&#x27; expr &#x27;)&#x27;</span><br><span class="hljs-comment">//   | num</span><br><span class="hljs-comment">//        | &#x27;(&#x27; expr &#x27;)&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrimary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br>id := lex.text()<br>lex.next()<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> Var(id)<br>&#125;<br>lex.next()<br><span class="hljs-keyword">var</span> args []Expr<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>args = <span class="hljs-built_in">append</span>(args, parseExpr(lex))<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;,&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %s, want &#x27;)&#x27;&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> call&#123;id, args&#125;<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br>f, err := strconv.ParseFloat(lex.text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(lexPanic(err.Error()))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume number</span><br><span class="hljs-keyword">return</span> literal(f)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %s, want &#x27;)&#x27;&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> e<br>&#125;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br></code></pre></td></tr></table></figure><p>使用一下命令去测试， <code>-v</code>是输出<code>fmt.Printf</code>打印内容，默认是不输出的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go test -v ./ch/ch7/eval<br></code></pre></td></tr></table></figure><p>打印出一下内容：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">=== RUN   TestEval<br><br>sqrt(A / pi)<br>        <span class="hljs-keyword">map</span>[A:<span class="hljs-number">87616</span> pi:<span class="hljs-number">3.141592653589793</span>] =&gt; <span class="hljs-number">167</span><br><br>pow(x, <span class="hljs-number">3</span>) + pow(y, <span class="hljs-number">3</span>)<br>        <span class="hljs-keyword">map</span>[x:<span class="hljs-number">12</span> y:<span class="hljs-number">1</span>] =&gt; <span class="hljs-number">1729</span><br>        <span class="hljs-keyword">map</span>[x:<span class="hljs-number">9</span> y:<span class="hljs-number">10</span>] =&gt; <span class="hljs-number">1729</span><br><br><span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (F - <span class="hljs-number">32</span>)<br>        <span class="hljs-keyword">map</span>[F:<span class="hljs-number">-40</span>] =&gt; <span class="hljs-number">-40</span><br>        <span class="hljs-keyword">map</span>[F:<span class="hljs-number">32</span>] =&gt; <span class="hljs-number">0</span><br>        <span class="hljs-keyword">map</span>[F:<span class="hljs-number">212</span>] =&gt; <span class="hljs-number">100</span><br>--- PASS: TestEval (<span class="hljs-number">0.00</span>s)<br>PASS<br>ok      <span class="hljs-keyword">go</span>-learn-gopl/ch/ch7/eval       <span class="hljs-number">0.128</span>s<br></code></pre></td></tr></table></figure><p>在解释型语言中，为了静态错误检查语法是非常常见的；<br>静态错误就是不用运行程序就可以检测出来的错误。<br>通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。<br>往<code>Expr</code>接口中增加另一个方法。Check方法在一个表达式语义树检查出静态错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Eval returns the value of this Expr in the environment env.</span><br>Eval(env Env) <span class="hljs-type">float64</span><br><span class="hljs-comment">// Check reports errors in this Expr and adds its Vars to the set.</span><br>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>Var</code>类型是不可能出现问题的，<code>literal</code>类型也是如此。<br><code>unary</code>和<code>binary</code>类型要考虑符号是否正确，然后再递归检查运算单元。<br><code>call</code>要考虑函数是否已知并且参数数量是否无误，然后再递归检查每一个参数的有效性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>vars[v] = <span class="hljs-literal">true</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected unary op %q&quot;</span>, u.op)<br>&#125;<br><span class="hljs-keyword">return</span> u.x.Check(vars)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected unary op %q&quot;</span>, b.op)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> b.y.Check(vars)<br>&#125;<br><br><span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>arity, ok := numParams[c.fn]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function %q&quot;</span>, c.fn)<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.args) != arity &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;car to %s has %d args, want %d&quot;</span>, c.fn, <span class="hljs-built_in">len</span>(c.args), arity)<br>&#125;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br><span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>写一个测试案例去测试<code>Check</code>是否有效。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestError</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> []<span class="hljs-keyword">struct</span>&#123; expr, wantErr <span class="hljs-type">string</span> &#125;&#123;<br>&#123;<span class="hljs-string">&quot;x % 2&quot;</span>, <span class="hljs-string">&quot;unexpected &#x27;%&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;math.Pi&quot;</span>, <span class="hljs-string">&quot;unexpected &#x27;.&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;!true&quot;</span>, <span class="hljs-string">&quot;unexpected &#x27;!&#x27;&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;log(10)&quot;</span>, <span class="hljs-string">`unknown function &quot;log&quot;`</span>&#125;,<br>&#123;<span class="hljs-string">&quot;sqrt(i, 2)&quot;</span>, <span class="hljs-string">&quot;call to sqrt has 2 args, want 1&quot;</span>&#125;,<br>&#125; &#123;<br>expr, err := Parse(test.expr)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>vars := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>)<br>err = expr.Check(vars)<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>t.Errorf(<span class="hljs-string">&quot;unexpected success: %s&quot;</span>, test.expr)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%-20s%v\n&quot;</span>, test.expr, err)<br><span class="hljs-keyword">if</span> err.Error() != test.wantErr &#123;<br>t.Errorf(<span class="hljs-string">&quot;got error %s, want %s&quot;</span>, err, test.wantErr)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//!+output</span><br><span class="hljs-comment">=== RUN   TestError</span><br><span class="hljs-comment">x % 2               unexpected &#x27;%&#x27;</span><br><span class="hljs-comment">math.Pi             unexpected &#x27;.&#x27;</span><br><span class="hljs-comment">!true               unexpected &#x27;!&#x27;</span><br><span class="hljs-comment">log(10)             unknown function &quot;log&quot;</span><br><span class="hljs-comment">sqrt(i, 2)          car to sqrt has 2 args, want 1</span><br><span class="hljs-comment">    eval_test.go:82: got error car to sqrt has 2 args, want 1, want call to sqrt has 2 args, want 1</span><br><span class="hljs-comment">--- FAIL: TestError (0.00s)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">FAIL</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h1 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h1><p><code>ParseAndCheck</code>函数将转换和检查结合在一起，下面是例子<code>surface</code>中的<code>ParseAndCheck</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseAndCheck</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (eval.Expr, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;empty expression&quot;</span>)<br>&#125;<br>expr, err := eval.Parse(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>vars := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[eval.Var]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">if</span> err := expr.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> vars &#123;<br><span class="hljs-keyword">if</span> v != <span class="hljs-string">&quot;x&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;y&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;r&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;undefined variable: %s&quot;</span>, v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> expr, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>surface</code>改成web应用，那么需要一个接口函数<code>plot</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plot</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>req.ParseForm()<br>expr, err := parseAndCheck(req.Form.Get(<span class="hljs-string">&quot;expr&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;bad expr:&quot;</span>+err.Error(), http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;image/svg+xml&quot;</span>)<br>surface(w, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>r := math.Hypot(x, y)<br><span class="hljs-keyword">return</span> expr.Eval(eval.Env&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y, <span class="hljs-string">&quot;r&quot;</span>: r&#125;)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>plot</code>函数中，转换和检查HTTP请求中的指定表达式，并且创建一个符合<code>surface()</code>函数中的匿名函数。<br>全部代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch7/eval&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>width, height = <span class="hljs-number">600</span>, <span class="hljs-number">320</span>            <span class="hljs-comment">// canvas size in pixels</span><br>cells         = <span class="hljs-number">100</span>                 <span class="hljs-comment">// number of grid cells</span><br>xyrange       = <span class="hljs-number">30.0</span>                <span class="hljs-comment">// x, y axis range (-xyrange..+xyrange)</span><br>xyscale       = width / <span class="hljs-number">2</span> / xyrange <span class="hljs-comment">// pixels per x or y unit</span><br>zscale        = height * <span class="hljs-number">0.4</span>        <span class="hljs-comment">// pixels per z unit</span><br>)<br><br><span class="hljs-keyword">var</span> sin30, cos30 = <span class="hljs-number">0.5</span>, math.Sqrt(<span class="hljs-number">3.0</span> / <span class="hljs-number">4.0</span>) <span class="hljs-comment">// sin(30°)， cos(30°)</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">corner</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>, i, j <span class="hljs-type">int</span>) (<span class="hljs-type">float64</span>, <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-comment">// find point (x,y) at corner of cell (i,j).</span><br>x := xyrange * (<span class="hljs-type">float64</span>(i)/cells - <span class="hljs-number">0.5</span>)<br>y := xyrange * (<span class="hljs-type">float64</span>(j)/cells - <span class="hljs-number">0.5</span>)<br><br>z := f(x, y) <span class="hljs-comment">// compute surface height z</span><br><br>sx := width/<span class="hljs-number">2</span> + (x-y)*cos30*xyrange<br>sy := height/<span class="hljs-number">2</span> + (x+y)*sin30*xyscale - z*zscale<br><span class="hljs-keyword">return</span> sx, sy<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">surface</span><span class="hljs-params">(w io.Writer, f <span class="hljs-keyword">func</span>(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span>) &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; &quot;</span>+<br><span class="hljs-string">&quot;style=&#x27;stroke: grey; fill: white; stroke-width: 0.7&#x27; &quot;</span>+<br><span class="hljs-string">&quot;width=&#x27;%d&#x27; height=&#x27;%d&#x27;&gt;&quot;</span>, width, height)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cells; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cells; j++ &#123;<br>ax, ay := corner(f, i+<span class="hljs-number">1</span>, j)<br>bx, by := corner(f, i, j)<br>cx, cy := corner(f, i, j+<span class="hljs-number">1</span>)<br>dx, dy := corner(f, i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;&lt;polygon points=&#x27;%g,%g %g,%g %g,%g %g,%g&#x27;/&gt;\n&quot;</span>,<br>ax, ay, bx, by, cx, cy, dx, dy)<br>&#125;<br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;&lt;/svg&gt;&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseAndCheck</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> (eval.Expr, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;empty expression&quot;</span>)<br>&#125;<br>expr, err := eval.Parse(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>vars := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[eval.Var]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">if</span> err := expr.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> vars &#123;<br><span class="hljs-keyword">if</span> v != <span class="hljs-string">&quot;x&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;y&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;r&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;undefined variable: %s&quot;</span>, v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> expr, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plot</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>req.ParseForm()<br>expr, err := parseAndCheck(req.Form.Get(<span class="hljs-string">&quot;expr&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, <span class="hljs-string">&quot;bad expr:&quot;</span>+err.Error(), http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;image/svg+xml&quot;</span>)<br>surface(w, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>r := math.Hypot(x, y)<br><span class="hljs-keyword">return</span> expr.Eval(eval.Env&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y, <span class="hljs-string">&quot;r&quot;</span>: r&#125;)<br>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/plot&quot;</span>, plot)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是几个表达式形成svg的图：</p><p><img src="/7.9.%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/1692541290123.png" alt="sin(-x)*pow(1.5, -r)"></p><p><img src="/7.9.%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/1692541447313.png" alt="pow(2,sin(y))*pow(2,sin(x))/12"></p><p><img src="/7.9.%20%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC/1692541516092.png" alt="sin(x*y/10)/10"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.13：</strong> 为Expr增加一个String方法来打印美观的语法树。当再一次解析的时候，检查它的结果是否生成相同的语法树。<br>解：<br>ast.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br>Eval(env Env) <span class="hljs-type">float64</span><br>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span><br>String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Var <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> literal <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;<br>op <span class="hljs-type">rune</span> <span class="hljs-comment">// one of +, -</span><br>x  Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;<br>op   <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;,&#x27;/&#x27;</span><br>x, y Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>fn   <span class="hljs-type">string</span> <span class="hljs-comment">// one of sin,pow,sqrt</span><br>args []Expr<br>&#125;<br></code></pre></td></tr></table></figure><p>eval.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> env[v]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> u.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> +u.x.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> -u.x.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported unary operator: %q&quot;</span>, u.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> b.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported binary operator: %q&quot;</span>, b.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> c.fn &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br><span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported function call: %q&quot;</span>, c.fn))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>check.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport unary operator: %q&quot;</span>, u.op)<br>&#125;<br><span class="hljs-keyword">return</span> u.x.Check(vars)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport binary operator: %q&quot;</span>, b.op)<br>&#125;<br><span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> b.y.Check(vars)<br>&#125;<br><br><span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>arity, ok := numParams[c.fn]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function %q &quot;</span>, c.fn)<br>&#125;<br><span class="hljs-keyword">if</span> arity != <span class="hljs-built_in">len</span>(c.args) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call to %s has %d args, want %d&quot;</span>, c.fn, <span class="hljs-built_in">len</span>(c.args), arity)<br>&#125;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br><span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>string.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%c%s&quot;</span>, u.op, u.x)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s)&quot;</span>, b.x, b.op, b.y)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> args []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>args = <span class="hljs-built_in">append</span>(args, arg.String())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s(%s)&quot;</span>, c.fn, strings.Join(args, <span class="hljs-string">&quot;, &quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>parse.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/scanner&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;<br>scan  scanner.Scanner<br>token <span class="hljs-type">rune</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> text() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<br><br><span class="hljs-keyword">type</span> lexPanic <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> describe() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.EOF:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;end of file&quot;</span>)<br><span class="hljs-keyword">case</span> scanner.Ident:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;identifier %s&quot;</span>, lex.text())<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;number %s&quot;</span>, lex.text())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, lex.text())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">precedence</span><span class="hljs-params">(op <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (_ Expr, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> x := <span class="hljs-built_in">recover</span>().(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br><span class="hljs-keyword">case</span> lexPanic:<br>err = fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(x)<br>&#125;<br>&#125;()<br>lex := <span class="hljs-built_in">new</span>(lexer)<br>lex.scan.Init(strings.NewReader(input))<br>lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats<br>lex.next()<br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != scanner.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExpr</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">return</span> parseBinary(lex, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseBinary</span><span class="hljs-params">(lex *lexer, precl <span class="hljs-type">int</span>)</span></span> Expr &#123;<br>lhs := parseUnary(lex)<br><span class="hljs-keyword">for</span> prec := precedence(lex.token); prec &gt;= precl; prec-- &#123;<br><span class="hljs-keyword">for</span> precedence(lex.token) == prec &#123;<br>op := lex.token<br>lex.next()<br>rhs := parseBinary(lex, prec+<span class="hljs-number">1</span>)<br>lhs = binary&#123;op, lhs, rhs&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseUnary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">if</span> lex.token == <span class="hljs-string">&#x27;+&#x27;</span> || lex.token == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>op := lex.token<br>lex.next()<br><span class="hljs-keyword">return</span> unary&#123;<br>op: op,<br>x:  parseUnary(lex),<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> parsePrimary(lex)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrimary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br>id := lex.text()<br>lex.next()<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> Var(id)<br>&#125;<br>lex.next()<br><span class="hljs-keyword">var</span> args []Expr<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>args = <span class="hljs-built_in">append</span>(args, parseExpr(lex))<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>lex.next()<br>&#125;<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %s, want &#x27;)&#x27;&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>&#125;<br>lex.next()<br><span class="hljs-keyword">return</span> call&#123;id, args&#125;<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br>f, err := strconv.ParseFloat(lex.text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(lexPanic(err.Error()))<br>&#125;<br>lex.next()<br><span class="hljs-keyword">return</span> literal(f)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>lex.next()<br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %s, want &#x27;)&#x27;&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>lex.next()<br><span class="hljs-keyword">return</span> e<br>&#125;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br></code></pre></td></tr></table></figure><p>string_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestString</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;<br>expr <span class="hljs-type">string</span><br>want <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;-1 + -x&quot;</span>, <span class="hljs-string">&quot;(-1 + -x)&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;-1 - x&quot;</span>, <span class="hljs-string">&quot;(-1 - x)&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>, <span class="hljs-string">&quot;sqrt((A / pi))&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, <span class="hljs-string">&quot;(pow(x, 3) + pow(y, 3))&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, <span class="hljs-string">&quot;((5 / 9) * (F - 32))&quot;</span>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> i, tt := <span class="hljs-keyword">range</span> tests &#123;<br>expr, err := Parse(tt.expr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Error(err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>got := expr.String()<br><span class="hljs-keyword">if</span> got != tt.want &#123;<br>t.Logf(<span class="hljs-string">&quot;%d. got %s, want %s&quot;</span>, i, got, tt.want)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.14：</strong> 定义一个新的满足Expr接口的具体类型并且提供一个新的操作例如对它运算单元中的最小值的计算。因为Parse函数不会创建这个新类型的实例，为了使用它你可能需要直接构造一个语法树（或者继承parser接口）。<br>解：<br>ast.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br>Eval(env Env) <span class="hljs-type">float64</span><br>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span><br>String() <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Var <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> literal <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;<br>op <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;,&#x27;-&#x27;</span><br>x  Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;<br>op   <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;,&#x27;-&#x27;,&#x27;*&#x27;,&#x27;/&#x27;</span><br>x, y Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>fn   <span class="hljs-type">string</span> <span class="hljs-comment">// one of sqrt, pow, sin</span><br>args []Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> ternary <span class="hljs-keyword">struct</span> &#123;<br>op1, op2 <span class="hljs-type">rune</span> <span class="hljs-comment">// one of &#x27;?&#x27;,&#x27;:&#x27;</span><br>x, y, z  Expr<br>&#125;<br></code></pre></td></tr></table></figure><p>eval.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> env[v]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> u.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> +u.x.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> -u.x.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported unary operator: %q&quot;</span>, u.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> b.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported binary operator: %q&quot;</span>, b.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> c.fn &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br><span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> t.op1 == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; t.op2 == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> t.x.Eval(env) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> t.y.Eval(env)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> t.z.Eval(env)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported ternary operator: %q, %q&quot;</span>, t.op1, t.op2))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>check.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupported unary operator: %q&quot;</span>, u.op)<br>&#125;<br><span class="hljs-keyword">return</span> u.x.Check(vars)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupported binary operator: %q&quot;</span>, b.op)<br>&#125;<br><span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> b.y.Check(vars)<br>&#125;<br><br><span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>arity, ok := numParams[c.fn]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn)<br>&#125;<br><span class="hljs-keyword">if</span> arity != <span class="hljs-built_in">len</span>(c.args) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call to %s has %d args, want %d&quot;</span>, c.fn, <span class="hljs-built_in">len</span>(c.args), arity)<br>&#125;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br><span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;?:&quot;</span>, t.op1) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op1)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> strings.ContainsRune(<span class="hljs-string">&quot;?:&quot;</span>, t.op2) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op2)<br>&#125;<br><span class="hljs-keyword">if</span> err := t.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := t.y.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> t.z.Check(vars)<br>&#125;<br></code></pre></td></tr></table></figure><p>string.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%c%s&quot;</span>, u.op, u.x.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s)&quot;</span>, b.x.String(), b.op, b.y.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> args []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>args = <span class="hljs-built_in">append</span>(args, arg.String())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s(%s)&quot;</span>, c.fn, strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s %c %s)&quot;</span>, t.x, t.op1, t.y, t.op2, t.z)<br>&#125;<br></code></pre></td></tr></table></figure><p>parse.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/scanner&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;<br>scan  scanner.Scanner<br>token <span class="hljs-type">rune</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> text() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<br><br><span class="hljs-keyword">type</span> lexPanic <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> describe() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.EOF:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;end of file&quot;</span>)<br><span class="hljs-keyword">case</span> scanner.Ident:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;identifier %s&quot;</span>, lex.text())<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;number %s&quot;</span>, lex.text())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, <span class="hljs-type">rune</span>(lex.token))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">precedence</span><span class="hljs-params">(op <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;:&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (_ Expr, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> x := <span class="hljs-built_in">recover</span>().(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br><span class="hljs-keyword">case</span> lexPanic:<br>err = fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(x)<br>&#125;<br>&#125;()<br>lex := <span class="hljs-built_in">new</span>(lexer)<br>lex.scan.Init(strings.NewReader(input))<br>lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats<br>lex.next() <span class="hljs-comment">// initial lookahead</span><br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != scanner.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseExpr</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">return</span> parseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseBinaryOrTernary</span><span class="hljs-params">(lex *lexer, precl <span class="hljs-type">int</span>)</span></span> Expr &#123;<br>lhs := parseUnary(lex)<br><span class="hljs-keyword">for</span> prec := precedence(lex.token); prec &gt;= precl; prec-- &#123;<br><span class="hljs-keyword">for</span> precedence(lex.token) == prec &#123;<br>op := lex.token<br><span class="hljs-keyword">if</span> strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, op) &#123;<br>lex.next()<br>rhs := parseBinaryOrTernary(lex, prec+<span class="hljs-number">1</span>)<br>lhs = binary&#123;op, lhs, rhs&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;?&#x27;</span> &#123;<br>lex.next() <span class="hljs-comment">// consume &#x27;?&#x27;</span><br>y := parseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>op2 := lex.token<br>lex.next() <span class="hljs-comment">// consume &#x27;:&#x27;</span><br>z := parseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>lhs = ternary&#123;op, op2, lhs, y, z&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> op == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseUnary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">if</span> lex.token == <span class="hljs-string">&#x27;+&#x27;</span> || lex.token == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>op := lex.token<br>lex.next()<br><span class="hljs-keyword">return</span> unary&#123;op, parseUnary(lex)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> parsePrimary(lex)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parsePrimary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br>id := lex.text()<br>lex.next() <span class="hljs-comment">// consume Ident</span><br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> Var(id)<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br><span class="hljs-keyword">var</span> args []Expr<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>args = <span class="hljs-built_in">append</span>(args, parseExpr(lex))<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;,&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %q, want &#x27;)&#x27; &quot;</span>, lex.token)<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> call&#123;id, args&#125;<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br>f, err := strconv.ParseFloat(lex.text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(lexPanic(err.Error()))<br>&#125;<br>lex.next()<br><span class="hljs-keyword">return</span> literal(f)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br>e := parseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %s, want &#x27;)&#x27; &quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> e<br>&#125;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br></code></pre></td></tr></table></figure><p>print.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Format</span><span class="hljs-params">(expr Expr)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>write(&amp;buf, expr)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(buf *bytes.Buffer, expr Expr)</span></span> &#123;<br><span class="hljs-keyword">switch</span> e := expr.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> Var:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s&quot;</span>, e)<br><span class="hljs-keyword">case</span> literal:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%g&quot;</span>, e)<br><span class="hljs-keyword">case</span> unary:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;(%c&quot;</span>, e.op)<br>write(buf, e.x)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> binary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op)<br>write(buf, e.y)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> call:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s(&quot;</span>, e.fn)<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> e.args &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)<br>&#125;<br>write(buf, arg)<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> ternary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op1)<br>write(buf, e.y)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op2)<br>write(buf, e.z)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.15：</strong> 编写一个从标准输入中读取一个单一表达式的程序，用户及时地提供对于任意变量的值，然后在结果环境变量中计算表达式的值。优雅的处理所有遇到的错误。<br>解：<br>ast.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br>Eval(env Env) <span class="hljs-type">float64</span><br>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span><br>String() <span class="hljs-type">string</span><br>Vars() []Var<br>&#125;<br><br><span class="hljs-keyword">type</span> Var <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> literal <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;<br>op <span class="hljs-type">rune</span><br>x  Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;<br>op   <span class="hljs-type">rune</span><br>x, y Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>fn   <span class="hljs-type">string</span><br>args []Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> ternary <span class="hljs-keyword">struct</span> &#123;<br>op1, op2 <span class="hljs-type">rune</span><br>x, y, z  Expr<br>&#125;<br></code></pre></td></tr></table></figure><p>eval.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> env[v]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> u.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> +u.x.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> -u.x.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected unary operator: %q&quot;</span>, u.x))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> b.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected binary operator: %q&quot;</span>, b.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> c.fn &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br><span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> t.op1 == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; t.op2 == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> t.x.Eval(env) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> t.y.Eval(env)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> t.z.Eval(env)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q and %q&quot;</span>, t.op1, t.op2))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>check.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport unary operator: %q&quot;</span>, u.op)<br>&#125;<br><span class="hljs-keyword">return</span> u.x.Check(vars)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport binary operator: %q&quot;</span>, b.op)<br>&#125;<br><span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> b.y.Check(vars)<br>&#125;<br><br><span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>arity, ok := numParams[c.fn]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn)<br>&#125;<br><span class="hljs-keyword">if</span> arity != <span class="hljs-built_in">len</span>(c.args) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call to %s has %d args, want %d&quot;</span>, c.fn, <span class="hljs-built_in">len</span>(c.args), arity)<br>&#125;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br><span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> t.op1 == <span class="hljs-string">&#x27;?&#x27;</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op1))<br>&#125;<br><span class="hljs-keyword">if</span> t.op2 == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op2))<br>&#125;<br><span class="hljs-keyword">if</span> err := t.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := t.y.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> t.z.Check(vars)<br>&#125;<br></code></pre></td></tr></table></figure><p>string.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%c%s&quot;</span>, u.op, u.x.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s)&quot;</span>, b.x.String(), b.op, b.y.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> args []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>args = <span class="hljs-built_in">append</span>(args, arg.String())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s(%s)&quot;</span>, c.fn, strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s %c %s)&quot;</span>, t.x.String(), t.op1, t.y.String(), t.op2, t.z.String())<br>&#125;<br></code></pre></td></tr></table></figure><p>vars.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> []Var&#123;v&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> []Var&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> u.x.Vars()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(b.x.Vars(), b.y.Vars()...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">var</span> vars []Var<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>vars = <span class="hljs-built_in">append</span>(vars, arg.Vars()...)<br>&#125;<br><span class="hljs-keyword">return</span> vars<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Vars() []Var &#123;<br>vars := <span class="hljs-built_in">append</span>(t.x.Vars(), t.y.Vars()...)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(vars, t.z.Vars()...)<br>&#125;<br></code></pre></td></tr></table></figure><p>parse.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/scanner&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;<br>scan  scanner.Scanner<br>token <span class="hljs-type">rune</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> text() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<br><br><span class="hljs-keyword">type</span> lexPanic <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> describe() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;identifier %q&quot;</span>, lex.token)<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;numbber %q&quot;</span>, lex.token)<br><span class="hljs-keyword">case</span> scanner.EOF:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;end of file&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, <span class="hljs-type">rune</span>(lex.token))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">precedence</span><span class="hljs-params">(op <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;:&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(inputStr <span class="hljs-type">string</span>)</span></span> (_ Expr, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> x := <span class="hljs-built_in">recover</span>().(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br><span class="hljs-keyword">case</span> lexPanic:<br>err = fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(x)<br>&#125;<br>&#125;()<br>lex := <span class="hljs-built_in">new</span>(lexer)<br>lex.scan.Init(strings.NewReader(inputStr))<br>lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats<br>lex.next()<br>e := ParseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != scanner.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseExpr</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">return</span> ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseBinaryOrTernary</span><span class="hljs-params">(lex *lexer, precl <span class="hljs-type">int</span>)</span></span> Expr &#123;<br>lhs := ParseUnary(lex)<br><span class="hljs-keyword">for</span> prec := precedence(lex.token); prec &gt;= precl; prec-- &#123;<br><span class="hljs-keyword">for</span> prec == precedence(lex.token) &#123;<br>op := lex.token<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume operator</span><br>rhs := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>lhs = binary&#123;op, lhs, rhs&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;?&#x27;</span><br>rhs := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>op2 := lex.token<br>lex.next() <span class="hljs-comment">// consume &#x27;:&#x27;</span><br>z := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>lhs = ternary&#123;op, op2, lhs, rhs, z&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseUnary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">if</span> strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, lex.token) &#123;<br>op := lex.token<br>lex.next() <span class="hljs-comment">// consume &#x27;+&#x27; or &#x27;-&#x27;</span><br><span class="hljs-keyword">return</span> unary&#123;op, ParseUnary(lex)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ParsePrimary(lex)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParsePrimary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br>id := lex.text()<br>lex.next() <span class="hljs-comment">// consume Ident</span><br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> Var(id)<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br><span class="hljs-keyword">var</span> args []Expr<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>args = <span class="hljs-built_in">append</span>(args, ParseExpr(lex))<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;,&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %q, want &#x27;)&#x27;&quot;</span>, lex.token)<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> call&#123;id, args&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br>e := ParseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %q, want &#x27;)&#x27;&quot;</span>, lex.token)<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> e<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br>f, err := strconv.ParseFloat(lex.text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(lexPanic(err.Error()))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume number</span><br><span class="hljs-keyword">return</span> literal(f)<br><span class="hljs-keyword">default</span>:<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;unexpected %q&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>print.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Format</span><span class="hljs-params">(expr Expr)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>write(&amp;buf, expr)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(buf *bytes.Buffer, expr Expr)</span></span> &#123;<br><span class="hljs-keyword">switch</span> e := expr.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> Var:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s&quot;</span>, e)<br><span class="hljs-keyword">case</span> literal:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%g&quot;</span>, e)<br><span class="hljs-keyword">case</span> unary:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;(%c&quot;</span>, e.op)<br>write(buf, e.x)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> binary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op)<br>write(buf, e.y)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> call:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s(&quot;</span>, e.fn)<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> e.args &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)<br>&#125;<br>write(buf, arg)<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> ternary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op1)<br>write(buf, e.y)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op2)<br>write(buf, e.z)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex7/ex7.15/eval&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-comment">// control + D mac系统输入结束符 EOF</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Print(<span class="hljs-string">&quot;Expr: &quot;</span>)<br><br>b, err := io.ReadAll(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>expr, err := eval.Parse(<span class="hljs-type">string</span>(b))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>fmt.Print(<span class="hljs-string">&quot;\n&quot;</span>)<br>env := Env(expr)<br>fmt.Printf(<span class="hljs-string">&quot;Expr = %g\n&quot;</span>, expr.Eval(env))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Env</span><span class="hljs-params">(expr eval.Expr)</span></span> eval.Env &#123;<br>env := <span class="hljs-built_in">make</span>(eval.Env)<br>scanner := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> expr.Vars() &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s: &quot;</span>, v)<br><br><span class="hljs-keyword">if</span> !scanner.Scan() &#123;<br>log.Fatal(<span class="hljs-string">&quot;not enough var!&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">if</span> err := scanner.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>f, err := strconv.ParseFloat(scanner.Text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>env[v] = f<br>&#125;<br><span class="hljs-keyword">return</span> env<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.16：</strong> 编写一个基于web的计算器程序。<br>解：<br>ast.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<br>Eval(env Env) <span class="hljs-type">float64</span><br>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span><br>String() <span class="hljs-type">string</span><br>Vars() []Var<br>&#125;<br><br><span class="hljs-keyword">type</span> Var <span class="hljs-type">string</span><br><br><span class="hljs-keyword">type</span> literal <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;<br>op <span class="hljs-type">rune</span><br>x  Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;<br>op   <span class="hljs-type">rune</span><br>x, y Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;<br>fn   <span class="hljs-type">string</span><br>args []Expr<br>&#125;<br><br><span class="hljs-keyword">type</span> ternary <span class="hljs-keyword">struct</span> &#123;<br>op1, op2 <span class="hljs-type">rune</span><br>x, y, z  Expr<br>&#125;<br></code></pre></td></tr></table></figure><p>eval.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> env[v]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">float64</span>(l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> u.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> +u.x.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> -u.x.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected unary operator: %q&quot;</span>, u.x))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> b.op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected binary operator: %q&quot;</span>, b.op))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">switch</span> c.fn &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<br><span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<br><span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Eval(env Env) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> t.op1 == <span class="hljs-string">&#x27;?&#x27;</span> &amp;&amp; t.op2 == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-keyword">if</span> t.x.Eval(env) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> t.y.Eval(env)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> t.z.Eval(env)<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q and %q&quot;</span>, t.op1, t.op2))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>check.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport unary operator: %q&quot;</span>, u.op)<br>&#125;<br><span class="hljs-keyword">return</span> u.x.Check(vars)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupport binary operator: %q&quot;</span>, b.op)<br>&#125;<br><span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> b.y.Check(vars)<br>&#125;<br><br><span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br>arity, ok := numParams[c.fn]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function: %q&quot;</span>, c.fn)<br>&#125;<br><span class="hljs-keyword">if</span> arity != <span class="hljs-built_in">len</span>(c.args) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call to %s has %d args, want %d&quot;</span>, c.fn, <span class="hljs-built_in">len</span>(c.args), arity)<br>&#125;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br><span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-type">bool</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">if</span> t.op1 == <span class="hljs-string">&#x27;?&#x27;</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op1))<br>&#125;<br><span class="hljs-keyword">if</span> t.op2 == <span class="hljs-string">&#x27;:&#x27;</span> &#123;<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected ternary operator: %q&quot;</span>, t.op2))<br>&#125;<br><span class="hljs-keyword">if</span> err := t.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> err := t.y.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">return</span> t.z.Check(vars)<br>&#125;<br></code></pre></td></tr></table></figure><p>string.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(v)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g&quot;</span>, l)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%c%s&quot;</span>, u.op, u.x.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s)&quot;</span>, b.x.String(), b.op, b.y.String())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> args []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>args = <span class="hljs-built_in">append</span>(args, arg.String())<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%s(%s)&quot;</span>, c.fn, strings.Join(args, <span class="hljs-string">&quot;,&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;(%s %c %s %c %s)&quot;</span>, t.x.String(), t.op1, t.y.String(), t.op2, t.z.String())<br>&#125;<br></code></pre></td></tr></table></figure><p>vars.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> []Var&#123;v&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> []Var&#123;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> u.x.Vars()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(b.x.Vars(), b.y.Vars()...)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span></span> Vars() []Var &#123;<br><span class="hljs-keyword">var</span> vars []Var<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<br>vars = <span class="hljs-built_in">append</span>(vars, arg.Vars()...)<br>&#125;<br><span class="hljs-keyword">return</span> vars<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t ternary)</span></span> Vars() []Var &#123;<br>vars := <span class="hljs-built_in">append</span>(t.x.Vars(), t.y.Vars()...)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">append</span>(vars, t.z.Vars()...)<br>&#125;<br></code></pre></td></tr></table></figure><p>parse.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;text/scanner&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;<br>scan  scanner.Scanner<br>token <span class="hljs-type">rune</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> next()        &#123; lex.token = lex.scan.Scan() &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> text() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<br><br><span class="hljs-keyword">type</span> lexPanic <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span></span> describe() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;identifier %q&quot;</span>, lex.token)<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;numbber %q&quot;</span>, lex.token)<br><span class="hljs-keyword">case</span> scanner.EOF:<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;end of file&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, <span class="hljs-type">rune</span>(lex.token))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">precedence</span><span class="hljs-params">(op <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>, <span class="hljs-string">&#x27;:&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(inputStr <span class="hljs-type">string</span>)</span></span> (_ Expr, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> x := <span class="hljs-built_in">recover</span>().(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<br><span class="hljs-keyword">case</span> lexPanic:<br>err = fmt.Errorf(<span class="hljs-string">&quot;%s&quot;</span>, x)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(x)<br>&#125;<br>&#125;()<br>lex := <span class="hljs-built_in">new</span>(lexer)<br>lex.scan.Init(strings.NewReader(inputStr))<br>lex.scan.Mode = scanner.ScanIdents | scanner.ScanInts | scanner.ScanFloats<br>lex.next()<br>e := ParseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != scanner.EOF &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;unexpected %s&quot;</span>, lex.describe())<br>&#125;<br><span class="hljs-keyword">return</span> e, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseExpr</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">return</span> ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseBinaryOrTernary</span><span class="hljs-params">(lex *lexer, precl <span class="hljs-type">int</span>)</span></span> Expr &#123;<br>lhs := ParseUnary(lex)<br><span class="hljs-keyword">for</span> prec := precedence(lex.token); prec &gt;= precl; prec-- &#123;<br><span class="hljs-keyword">for</span> prec == precedence(lex.token) &#123;<br>op := lex.token<br><span class="hljs-keyword">switch</span> op &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume operator</span><br>rhs := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>lhs = binary&#123;op, lhs, rhs&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;?&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;?&#x27;</span><br>rhs := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>op2 := lex.token<br>lex.next() <span class="hljs-comment">// consume &#x27;:&#x27;</span><br>z := ParseBinaryOrTernary(lex, <span class="hljs-number">1</span>)<br>lhs = ternary&#123;op, op2, lhs, rhs, z&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;:&#x27;</span>:<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> lhs<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParseUnary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">if</span> strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, lex.token) &#123;<br>op := lex.token<br>lex.next() <span class="hljs-comment">// consume &#x27;+&#x27; or &#x27;-&#x27;</span><br><span class="hljs-keyword">return</span> unary&#123;op, ParseUnary(lex)&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ParsePrimary(lex)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ParsePrimary</span><span class="hljs-params">(lex *lexer)</span></span> Expr &#123;<br><span class="hljs-keyword">switch</span> lex.token &#123;<br><span class="hljs-keyword">case</span> scanner.Ident:<br>id := lex.text()<br>lex.next() <span class="hljs-comment">// consume Ident</span><br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;(&#x27;</span> &#123;<br><span class="hljs-keyword">return</span> Var(id)<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br><span class="hljs-keyword">var</span> args []Expr<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>args = <span class="hljs-built_in">append</span>(args, ParseExpr(lex))<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;,&#x27;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;,&#x27;</span><br>&#125;<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %q, want &#x27;)&#x27;&quot;</span>, lex.token)<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> call&#123;id, args&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:<br>lex.next() <span class="hljs-comment">// consume &#x27;(&#x27;</span><br>e := ParseExpr(lex)<br><span class="hljs-keyword">if</span> lex.token != <span class="hljs-string">&#x27;)&#x27;</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;got %q, want &#x27;)&#x27;&quot;</span>, lex.token)<br><span class="hljs-built_in">panic</span>(lexPanic(msg))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><br><span class="hljs-keyword">return</span> e<br><span class="hljs-keyword">case</span> scanner.Int, scanner.Float:<br>f, err := strconv.ParseFloat(lex.text(), <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(lexPanic(err.Error()))<br>&#125;<br>lex.next() <span class="hljs-comment">// consume number</span><br><span class="hljs-keyword">return</span> literal(f)<br><span class="hljs-keyword">default</span>:<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;unexpected %q&quot;</span>, lex.describe())<br><span class="hljs-built_in">panic</span>(msg)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>print.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> eval<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Format</span><span class="hljs-params">(expr Expr)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>write(&amp;buf, expr)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">(buf *bytes.Buffer, expr Expr)</span></span> &#123;<br><span class="hljs-keyword">switch</span> e := expr.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> Var:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s&quot;</span>, e)<br><span class="hljs-keyword">case</span> literal:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%g&quot;</span>, e)<br><span class="hljs-keyword">case</span> unary:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;(%c&quot;</span>, e.op)<br>write(buf, e.x)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> binary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op)<br>write(buf, e.y)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> call:<br>fmt.Fprintf(buf, <span class="hljs-string">&quot;%s(&quot;</span>, e.fn)<br><span class="hljs-keyword">for</span> i, arg := <span class="hljs-keyword">range</span> e.args &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)<br>&#125;<br>write(buf, arg)<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br><span class="hljs-keyword">case</span> ternary:<br>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<br>write(buf, e.x)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op1)<br>write(buf, e.y)<br>fmt.Fprintf(buf, <span class="hljs-string">&quot; %c &quot;</span>, e.op2)<br>write(buf, e.z)<br>buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ex/ex7/ex7.16/eval&quot;</span><br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;unicode&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>http.HandleFunc(<span class="hljs-string">&quot;/calc&quot;</span>, calc)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8888&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>templ := template.Must(template.ParseFiles(<span class="hljs-string">&quot;./ex/ex7/ex7.16/index.html&quot;</span>))<br><span class="hljs-keyword">if</span> err := templ.Execute(w, <span class="hljs-literal">nil</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<br>templ := template.Must(template.ParseFiles(<span class="hljs-string">&quot;./ex/ex7/ex7.16/index.html&quot;</span>))<br>exprStr := req.PostFormValue(<span class="hljs-string">&quot;expr&quot;</span>)<br>envStr := req.PostFormValue(<span class="hljs-string">&quot;env&quot;</span>)<br>expr, err := eval.Parse(exprStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>env, err := parseEnv(envStr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := templ.Execute(w, expr.Eval(env)); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseEnv</span><span class="hljs-params">(envStr <span class="hljs-type">string</span>)</span></span> (eval.Env, <span class="hljs-type">error</span>) &#123;<br>env := <span class="hljs-built_in">make</span>(eval.Env)<br>fields := strings.FieldsFunc(envStr, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> strings.ContainsRune(<span class="hljs-string">`&quot;:=,&#123;&#125;\&quot;`</span>, r) ||<br>unicode.IsSpace(r)<br>&#125;)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i+<span class="hljs-number">1</span> &lt; <span class="hljs-built_in">len</span>(fields); i += <span class="hljs-number">2</span> &#123;<br>k := strings.TrimSpace(fields[i])<br>v := strings.TrimSpace(fields[i+<span class="hljs-number">1</span>])<br>val, err := strconv.ParseFloat(v, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>env[eval.Var(k)] = val<br>&#125;<br><span class="hljs-keyword">return</span> env, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Calculator&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;form method=<span class="hljs-string">&quot;post&quot;</span> action=<span class="hljs-string">&quot;/calc&quot;</span>&gt;<br>    &lt;p&gt;Expr: &lt;/p&gt;&lt;textarea name=<span class="hljs-string">&quot;expr&quot;</span>&gt;&lt;/textarea&gt;<br>    &lt;p&gt;Env: &lt;/p&gt;&lt;textarea name=<span class="hljs-string">&quot;env&quot;</span>&gt;&lt;/textarea&gt;<br>    &lt;input <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;submit&quot;</span> value=<span class="hljs-string">&quot;Calculate&quot;</span>&gt;<br>&lt;/form&gt;<br>&lt;p&gt;Result: &#123;&#123;.&#125;&#125;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.8. error接口</title>
      <link href="/posts/21f47e2c8c53/"/>
      <url>/posts/21f47e2c8c53/</url>
      
        <content type="html"><![CDATA[<h1 id="error接口"><a href="#error接口" class="headerlink" title="error接口"></a>error接口</h1><p><code>error</code>接口是<code>interface</code>类型，这个类型只有一个返回错误信息的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> <span class="hljs-type">error</span> <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="创建error"><a href="#创建error" class="headerlink" title="创建error"></a>创建error</h1><h2 id="errors-New"><a href="#errors-New" class="headerlink" title="errors.New"></a>errors.New</h2><p>创建error的最简单方法就是调用<code>errors.New</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123;<br>s <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.s<br>&#125;<br></code></pre></td></tr></table></figure><p><code>errors.New</code>函数根据传入的错误信息返回一个新的<code>error</code>。<br>实现error接口的是<code>errorString</code>结构体指针，而非字符串。<br>原因在于避免其被无意中修改，而且因为<code>*errorString</code>指针类型满足<code>error</code>接口而非<code>errorString</code>，所以每次调用<code>New</code>都会生成不同的实例。<br>如<code>io.EOF</code>和相同的错误信息的<code>error</code>实例不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(io.EOF == errors.New(<span class="hljs-string">&quot;EOF&quot;</span>))            <span class="hljs-comment">// false</span><br>fmt.Println(errors.New(<span class="hljs-string">&quot;EOF&quot;</span>) == errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>一般情况下，使用<code>errors.New</code>函数比较少，我们常用<code>fmt.Errorf</code>函数。</p><h2 id="fmt-Errorf"><a href="#fmt-Errorf" class="headerlink" title="fmt.Errorf"></a>fmt.Errorf</h2><p><code>fmt.Errorf</code>还能格式化错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-type">string</span>, a ...any)</span></span> <span class="hljs-type">error</span> &#123;<br>p := newPrinter()<br>p.wrapErrs = <span class="hljs-literal">true</span><br>p.doPrintf(format, a)<br>s := <span class="hljs-type">string</span>(p.buf)<br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> p.wrappedErr == <span class="hljs-literal">nil</span> &#123;<br>err = errors.New(s)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>err = &amp;wrapError&#123;s, p.wrappedErr&#125;<br>&#125;<br>p.free()<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">type</span> wrapError <span class="hljs-keyword">struct</span> &#123;<br>msg <span class="hljs-type">string</span><br>err <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> e.msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *wrapError)</span></span> Unwrap() <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">return</span> e.err<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="syscall-Errno"><a href="#syscall-Errno" class="headerlink" title="syscall.Errno"></a>syscall.Errno</h1><p><code>syscall</code>包提供了Go语言底层系统调用API。<br>在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Errno <span class="hljs-type">uintptr</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Error() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-type">int</span>(e) &amp;&amp; <span class="hljs-type">int</span>(e) &lt; <span class="hljs-built_in">len</span>(errors) &#123;<br>s := errors[e]<br><span class="hljs-keyword">if</span> s != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;errno &quot;</span> + itoa.Itoa(<span class="hljs-type">int</span>(e))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Is(target <span class="hljs-type">error</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">switch</span> target &#123;<br><span class="hljs-keyword">case</span> oserror.ErrPermission:<br><span class="hljs-keyword">return</span> e == EACCES || e == EPERM<br><span class="hljs-keyword">case</span> oserror.ErrExist:<br><span class="hljs-keyword">return</span> e == EEXIST || e == ENOTEMPTY<br><span class="hljs-keyword">case</span> oserror.ErrNotExist:<br><span class="hljs-keyword">return</span> e == ENOENT<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Temporary() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> e == EINTR || e == EMFILE || e == ENFILE || e.Timeout()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span></span> Timeout() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> e == EAGAIN || e == EWOULDBLOCK || e == ETIMEDOUT<br>&#125;<br><br><span class="hljs-comment">// Do the interface allocations only once for common</span><br><span class="hljs-comment">// Errno values.</span><br><span class="hljs-keyword">var</span> (<br>errEAGAIN <span class="hljs-type">error</span> = EAGAIN<br>errEINVAL <span class="hljs-type">error</span> = EINVAL<br>errENOENT <span class="hljs-type">error</span> = ENOENT<br>)<br><br><span class="hljs-comment">// errnoErr returns common boxed Errno values, to prevent</span><br><span class="hljs-comment">// allocations at runtime.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errnoErr</span><span class="hljs-params">(e Errno)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">switch</span> e &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> EAGAIN:<br><span class="hljs-keyword">return</span> errEAGAIN<br><span class="hljs-keyword">case</span> EINVAL:<br><span class="hljs-keyword">return</span> errEINVAL<br><span class="hljs-keyword">case</span> ENOENT:<br><span class="hljs-keyword">return</span> errENOENT<br>&#125;<br><span class="hljs-keyword">return</span> e<br>&#125;<br><br><span class="hljs-keyword">var</span> errors = [...]<span class="hljs-type">string</span>&#123;<br><span class="hljs-number">1</span>:   <span class="hljs-string">&quot;operation not permitted&quot;</span>,<br><span class="hljs-number">2</span>:   <span class="hljs-string">&quot;no such file or directory&quot;</span>,<br><span class="hljs-number">3</span>:   <span class="hljs-string">&quot;no such process&quot;</span>,<br><span class="hljs-number">4</span>:   <span class="hljs-string">&quot;interrupted system call&quot;</span>,<br><span class="hljs-number">5</span>:   <span class="hljs-string">&quot;input/output error&quot;</span>,<br><span class="hljs-number">6</span>:   <span class="hljs-string">&quot;device not configured&quot;</span>,<br><span class="hljs-number">7</span>:   <span class="hljs-string">&quot;argument list too long&quot;</span>,<br><span class="hljs-number">8</span>:   <span class="hljs-string">&quot;exec format error&quot;</span>,<br><span class="hljs-number">9</span>:   <span class="hljs-string">&quot;bad file descriptor&quot;</span>,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是创建<code>error</code>的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span> = syscall.Errno(<span class="hljs-number">2</span>)<br>fmt.Println(err.Error()) <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br>fmt.Println(err)         <span class="hljs-comment">// &quot;no such file or directory&quot;</span><br></code></pre></td></tr></table></figure><p><code>Errno</code>是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.7. http.Handler接口</title>
      <link href="/posts/fc3145dbfc40/"/>
      <url>/posts/fc3145dbfc40/</url>
      
        <content type="html"><![CDATA[<h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p><code>http.Handler</code>接口用于实现客户端和服务器。具体接口如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;<br>ServeHTTP(ResponseWriter, *Request)<br>&#125;<br></code></pre></td></tr></table></figure><p>而常与<code>func ListenAndServe(address string, h Handler) error</code>结合使用，该方法需要一个服务器地址和接口分派的<code>Handler</code>接口实例。<br>该方法会一直运行，直到服务器因为错误而关闭或启动错误。</p><p>如一个电子商务网站，为了销售它的数据库将它物品的价格映射成美元。下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个ServeHttp方法，这样它可以满足http.Handler接口。这个handler会遍历整个map并输出物品信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">210</span>&#125;<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, db))<br>&#125;<br><br><span class="hljs-keyword">type</span> dollars <span class="hljs-type">float32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span></span> String() <span class="hljs-type">string</span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d) &#125;<br><br><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]dollars<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s&quot;</span>, item, price)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在后台运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./main.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main &amp;</span><br></code></pre></td></tr></table></figure><p>可以在web访问<a href="http://localhost:8080，即可得到以下输出。">http://localhost:8080，即可得到以下输出。</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">shoes:$210.00<br>socks:$5.00<br></code></pre></td></tr></table></figure><p>当然可以使用<code>fetch</code>程序访问。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ch/ch1/fetch http://localhost:8080</span><br>shoes:$210.00<br>socks:$5.00<br></code></pre></td></tr></table></figure><p>目前为止，这个服务器不考虑URL只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用&#x2F;list来调用已经存在的这个行为并且增加另一个&#x2F;price调用表明单个货品的价格，像这样&#x2F;price?item&#x3D;socks来指定一个请求参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">50</span>&#125;<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, db))<br>&#125;<br><br><span class="hljs-keyword">type</span> dollars <span class="hljs-type">float32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d)<br>&#125;<br><br><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]dollars<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">switch</span> req.URL.Path &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/list&quot;</span>:<br><span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s\n&quot;</span>, item, price)<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/price&quot;</span>:<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price, ok := db[item]<br><span class="hljs-keyword">if</span> !ok &#123;<br>w.WriteHeader(http.StatusNotFound)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;not such item:%q\n&quot;</span>, item)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s\n&quot;</span>, item, price)<br><span class="hljs-keyword">default</span>:<br>w.WriteHeader(http.StatusNotFound)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;not such page:%q\n&quot;</span>, req.URL)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中的<code>w.WriteHeader(http.StatusNotFound)</code>实际上是返回一个404的错误状态码。<br>等效于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">msg := fmt.Sprintf(<span class="hljs-string">&quot;not such page:%q\n&quot;</span>, req.URL)<br>http.Error(w, msg, http.StatusNotFound)<br></code></pre></td></tr></table></figure><p>下面是编译运行的结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./ch/ch7/http2</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./http2 &amp;</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ch/ch1/fetch http://localhost:8080/list</span><br>shoes:$100.00<br>socks:$50.00<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ch/ch1/fetch http://localhost:8080/price?item=shoes</span><br>shoes:$100.00<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ch/ch1/fetch http://localhost:8080/price?item=socks</span><br>socks:$50.00<br>./ch/ch1/fetch http://localhost:8080/price?item=hats<br>not such item:&quot;hats&quot;<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./ch/ch1/fetch http://localhost:8080/help</span><br>not such page:&quot;/help&quot;<br></code></pre></td></tr></table></figure><h1 id="ServeMux"><a href="#ServeMux" class="headerlink" title="ServeMux"></a>ServeMux</h1><p>如果有多个接口呢，继续增加<code>case</code>?<br>显然，这样过于臃肿。在实际应用中，我们可以使用将每个case中的逻辑定义到一个分开的方法或函数中。此外，相近的URL可能需要相似的逻辑，例如几个图片文件可能有形如<code>/images/*.png</code>的URL。<br>在Go语言中，<code>net/http</code>提供了提供了请求多路由器<code>ServeMux</code>来简化<code>URL</code>和<code>handlers</code>的联系。<br>一个<code>ServeMux</code>将一批<code>http.Handler</code>聚集到一个单一的<code>http.Handler</code>中。我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的<code>http.Handler</code>而不需要考虑它后面的具体类型。<br>对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。</p><p>在下面的程序中，我们创建一个<code>ServeMux</code>并且使用它将URL和相应处理<code>/list</code>和<code>/price</code>操作的<code>handler</code>联系起来，这些操作逻辑都已经被分到不同的方法中。然后我门在调用<code>ListenAndServe</code>函数中使用<code>ServeMux</code>最为主要的<code>handler</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">50</span>&#125;<br>mux := http.NewServeMux()<br>mux.Handle(<span class="hljs-string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))<br>mux.Handle(<span class="hljs-string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, mux))<br>&#125;<br><br><span class="hljs-keyword">type</span> dollars <span class="hljs-type">float32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d)<br>&#125;<br><br><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]dollars<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price, ok := db[item]<br><span class="hljs-keyword">if</span> !ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;not such item: %q&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)<br>&#125;<br><span class="hljs-string">``</span><span class="hljs-string">``</span><br><br><span class="hljs-string">`list`</span>和<span class="hljs-string">`price`</span>注册到<span class="hljs-string">`handlers`</span>上，<span class="hljs-string">`db.list`</span>实现了handler类似行为的函数，但是却没有实现<span class="hljs-string">`http.handler`</span>接口，所以不能直接传给<span class="hljs-string">`mux.Handle`</span>。<br><span class="hljs-string">`http.HandlerFunc(db.list)`</span>是<span class="hljs-string">`HandlerFunc`</span>类型，该语句为类型转换成<span class="hljs-string">`HandlerFunc`</span>类型。<br><span class="hljs-string">``</span><span class="hljs-string">`go</span><br><span class="hljs-string">type HandlerFunc func(ResponseWriter, *Request)</span><br><span class="hljs-string"></span><br><span class="hljs-string">// ServeHTTP calls f(w, r).</span><br><span class="hljs-string">func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) &#123;</span><br><span class="hljs-string">f(w, r)</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>该类型实现了<code>http.Handler</code>接口，<code>ServeHttp</code>方法内部调用了自身方法<code>f(w, r)</code>。</p><p>其实，<code>ServeMux</code>有一个简化的函数，<code>HandleFunc</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>mux.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)<br></code></pre></td></tr></table></figure><h1 id="DefaultServerMux"><a href="#DefaultServerMux" class="headerlink" title="DefaultServerMux"></a>DefaultServerMux</h1><p>上述例子实现了两个不同的web服务器来监听不同的端口，并且指派了不同的URL给不同的handler。只要构建另外一个<code>ServeMux</code>并且在调用一次ListenAndServe（可能并行的）。<br>此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显示的注册到这个应用的ServeMux实例上会比较麻烦。<br>为了方便，<code>net/http</code>包提供了一个全局的<code>ServeMux</code>实例<code>DefaultServerMux</code>和包级别的<code>http.Handle</code>和<code>http.HandleFunc</code>函数。<br>为了使用<code>DefaultServerMux</code>作为服务器的主handler，我们不需要将它传给ListenAndServe函数；nil值就可以工作。<br>下面是修改后的代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;hats&quot;</span>: <span class="hljs-number">20</span>&#125;<br>http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>http.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.11：</strong> 增加额外的handler让客户端可以创建，读取，更新和删除数据库记录。例如，一个形如 &#x2F;update?item&#x3D;socks&amp;price&#x3D;6 的请求会更新库存清单里一个货品的价格并且当这个货品不存在或价格无效时返回一个错误值。（注意：这个修改会引入变量同时更新的问题）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">50</span>&#125;<br>http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>http.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)<br>http.HandleFunc(<span class="hljs-string">&quot;/create&quot;</span>, db.create)<br>http.HandleFunc(<span class="hljs-string">&quot;/delete&quot;</span>, db.<span class="hljs-built_in">delete</span>)<br>http.HandleFunc(<span class="hljs-string">&quot;/update&quot;</span>, db.update)<br>http.HandleFunc(<span class="hljs-string">&quot;/read&quot;</span>, db.read)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><br><span class="hljs-keyword">type</span> dollars <span class="hljs-type">float32</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d)<br>&#125;<br><br><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]dollars<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;<br><span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s\n&quot;</span>, item, price)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> price(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price, ok := db[item]<br><span class="hljs-keyword">if</span> !ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;not such item:%q&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s\n&quot;</span>, item, price)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> create(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price := req.URL.Query().Get(<span class="hljs-string">&quot;price&quot;</span>)<br>p, err := strconv.ParseFloat(price, <span class="hljs-number">32</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;params err: %s\n&quot;</span>, err)<br>http.Error(w, msg, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>mu.Lock()<br><span class="hljs-keyword">if</span> _, ok := db[item]; ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;%s is exist.\n&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db[item] = dollars(p)<br>&#125;<br>mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> <span class="hljs-built_in">delete</span>(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>mu.Lock()<br><span class="hljs-keyword">if</span> _, ok := db[item]; !ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;%s is not exist.\n&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">delete</span>(db, item)<br>&#125;<br>mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> update(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price := req.URL.Query().Get(<span class="hljs-string">&quot;price&quot;</span>)<br>p, err := strconv.ParseFloat(price, <span class="hljs-number">32</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;params err: %v.\n&quot;</span>, err)<br>http.Error(w, msg, http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>mu.Lock()<br><span class="hljs-keyword">if</span> _, ok := db[item]; !ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;%s is not exist.\n&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>db[item] = dollars(p)<br>&#125;<br>mu.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> read(w http.ResponseWriter, req *http.Request) &#123;<br>item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)<br>price, ok := db[item]<br><span class="hljs-keyword">if</span> !ok &#123;<br>msg := fmt.Sprintf(<span class="hljs-string">&quot;%s is not exist.\n&quot;</span>, item)<br>http.Error(w, msg, http.StatusNotFound)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s:%s\n&quot;</span>, item, price)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.12：</strong> 修改&#x2F;list的handler让它把输出打印成一个HTML的表格而不是文本。html&#x2F;template包(§4.6)可能会对你有帮助。<br>解：<br>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>list<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: left&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Item<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Price<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  &#123;&#123;range $item, $price := .&#125;&#125;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">tr</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;$item&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123;$price&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  &#123;&#123;end&#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>程序</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">10</span>&#125;<br>http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span></span> list(w http.ResponseWriter, req *http.Request) &#123;<br>tmpl := template.Must(template.ParseFiles(<span class="hljs-string">&quot;./ex/ex7/ex7.12/list.html&quot;</span>))<br><span class="hljs-keyword">if</span> err := tmpl.Execute(w, db); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.6. sort.Interface接口</title>
      <link href="/posts/8d8e98ca9007/"/>
      <url>/posts/8d8e98ca9007/</url>
      
        <content type="html"><![CDATA[<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p><code>sort</code>包内包含对任何序列进行排序的接口，<code>sort.Interface</code>接口。<br>该接口规定了序列的排序算法和对序列类型之间的约定。<br>排序算法包含了以下三个要点：</p><ul><li>序列长度</li><li>元素比较的结果</li><li>交换元素的方式</li></ul><p>三个要点也对应着<code>sort.Interface</code>的三个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br>Len() <span class="hljs-type">int</span><br>Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span><br>Swap(i, j <span class="hljs-type">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是应用该接口的简单例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> StringSlice<br><br><span class="hljs-keyword">type</span> StringSlice []<span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringSlice)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringSlice)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> s[i] &gt; s[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s StringSlice)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接着就是直接调用<code>sort.Sort()</code>方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := StringSlice&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;<br>sort.Sort(s) <span class="hljs-comment">// [c b a]</span><br></code></pre></td></tr></table></figure><h1 id="复杂结构的排序"><a href="#复杂结构的排序" class="headerlink" title="复杂结构的排序"></a>复杂结构的排序</h1><p>下面的例子是对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。<br>音乐播放列表模型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Track <span class="hljs-keyword">struct</span> &#123;<br>Title  <span class="hljs-type">string</span><br>Artist <span class="hljs-type">string</span><br>Album  <span class="hljs-type">string</span><br>Year   <span class="hljs-type">int</span><br>Length time.Duration<br>&#125;<br><br><span class="hljs-keyword">var</span> tracks = []*Track&#123;<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Delilah&quot;</span>, <span class="hljs-string">&quot;From the Roots Up&quot;</span>, <span class="hljs-number">2012</span>, length(<span class="hljs-string">&quot;3m38s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-number">1992</span>, length(<span class="hljs-string">&quot;3m37s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go Ahead&quot;</span>, <span class="hljs-string">&quot;Alicia Keys&quot;</span>, <span class="hljs-string">&quot;As I Am&quot;</span>, <span class="hljs-number">2007</span>, length(<span class="hljs-string">&quot;4m36s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Ready 2 Go&quot;</span>, <span class="hljs-string">&quot;Martin Solveig&quot;</span>, <span class="hljs-string">&quot;Smash&quot;</span>, <span class="hljs-number">2011</span>, length(<span class="hljs-string">&quot;4m24s&quot;</span>)&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">length</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> time.Duration &#123;<br>d, err := time.ParseDuration(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(s)<br>&#125;<br><span class="hljs-keyword">return</span> d<br>&#125;<br></code></pre></td></tr></table></figure><p>定义<code>printTracks</code>函数，音乐播放列表打印成表格。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTracks</span><span class="hljs-params">(tracks []*Track)</span></span> &#123;<br><span class="hljs-keyword">const</span> format = <span class="hljs-string">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span><br>tw := <span class="hljs-built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprintf(tw, format, <span class="hljs-string">&quot;Title&quot;</span>, <span class="hljs-string">&quot;Artist&quot;</span>, <span class="hljs-string">&quot;Album&quot;</span>, <span class="hljs-string">&quot;Year&quot;</span>, <span class="hljs-string">&quot;Length&quot;</span>)<br>fmt.Fprintf(tw, format, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>)<br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> tracks &#123;<br>fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)<br>&#125;<br>tw.Flush()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>text/tabwriter</code>包可以生成列是对齐且隔开的表格。<br><code>*tabwriter.Write</code>实现了<code>io.Writer</code>接口，所以能收集其数据。<br>其<code>Flush()</code>方法会格式化整个表格且使用<code>os.Stdout</code>输出。</p><p>按<code>Artist</code>字段对音乐播放列表排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> byArtist []*Track<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x[i].Artist &lt; x[j].Artist<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>x[i], x[j] = x[j], x[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>将<code>track</code>类型转换成<code>byArtist</code>，并继续排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Sort(byArtist(tracks))<br></code></pre></td></tr></table></figure><p>打印排序后的列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">printTracks(tracks)<br></code></pre></td></tr></table></figure><p>输出内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">byArtist:<br>Title       Artist          Album              Year   Length  <br>-----       -----           -----              -----  -----   <br>Go Ahead    Alicia Keys     As I Am            2007   4m36s   <br>Go          Delilah         From the Roots Up  2012   3m38s   <br>Ready 2 Go  Martin Solveig  Smash              2011   4m24s   <br>Go          Moby            Moby               1992   3m37s  <br></code></pre></td></tr></table></figure><p>对排序后的播放列表进行逆向排序，<code>printTracks</code>输出如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Sort(sort.Reverse(byArtist(tracks)))<br>printTracks(tracks)<br><br>----------------------------------------<br>Title       Artist          Album              Year   Length  <br>-----       -----           -----              -----  -----   <br>Go          Moby            Moby               <span class="hljs-number">1992</span>   <span class="hljs-number">3</span>m37s   <br>Ready <span class="hljs-number">2</span> Go  Martin Solveig  Smash              <span class="hljs-number">2011</span>   <span class="hljs-number">4</span>m24s   <br>Go          Delilah         From the Roots Up  <span class="hljs-number">2012</span>   <span class="hljs-number">3</span>m38s   <br>Go Ahead    Alicia Keys     As I Am            <span class="hljs-number">2007</span>   <span class="hljs-number">4</span>m36s <br></code></pre></td></tr></table></figure><p>按<code>Year</code>进行排序，首先实现接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> byYear []*Track<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x[i].Year &lt; x[j].Year<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>x[i], x[j] = x[j], x[i]<br>&#125;<br><br>......<br><br>sort.Sort(byYear(tracks))<br>printTracks(tracks)<br><br>打印内容：<br>Title       Artist          Album              Year   Length  <br>-----       -----           -----              -----  -----   <br>Go          Moby            Moby               <span class="hljs-number">1992</span>   <span class="hljs-number">3</span>m37s   <br>Go Ahead    Alicia Keys     As I Am            <span class="hljs-number">2007</span>   <span class="hljs-number">4</span>m36s   <br>Ready <span class="hljs-number">2</span> Go  Martin Solveig  Smash              <span class="hljs-number">2011</span>   <span class="hljs-number">4</span>m24s   <br>Go          Delilah         From the Roots Up  <span class="hljs-number">2012</span>   <span class="hljs-number">3</span>m38s   <br><br></code></pre></td></tr></table></figure><p>接下来，思考一个问题。<br>如果要对列表进行多个排序，难道要实现多个<code>sort.Interface</code>接口？<br>如果要继续多重排序呢？</p><p>我们可以定义一个自定义排序，只要实现比较接口就可以实现上述问题。<br>而且，非slice也可以实现<code>sort.Interface</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> customSort <span class="hljs-keyword">struct</span> &#123;<br>t    []*Track<br>less <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span></span> Len() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x.t)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.less(x.t[i], x.t[j])<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span></span> Swap(i, j <span class="hljs-type">int</span>) &#123;<br>x.t[i], x.t[j] = x.t[j], x.t[i]<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码并未实现具体字段排序。<br>可以看出<code>customSort</code>类型有两个成员变量，slice列表<code>t []*Track</code>和比较函数<code>less func(x,y *Track) bool</code>。 <code>customSort</code>类型实现了<code>sort.Interface</code>，并在<code>Less</code>方法中调用成员变量中的<code>less</code>函数。<br>实现比较方法<code>less</code>即可进行排序，当然也可以进行多重排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">sort.Sort(customSort&#123;tracks, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> x.Title != y.Title &#123;<br><span class="hljs-keyword">return</span> x.Title &lt; y.Title<br>&#125;<br><span class="hljs-keyword">if</span> x.Year != y.Year &#123;<br><span class="hljs-keyword">return</span> x.Year &lt; y.Year<br>&#125;<br><span class="hljs-keyword">if</span> x.Length != y.Length &#123;<br><span class="hljs-keyword">return</span> x.Length &lt; y.Length<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;&#125;)<br></code></pre></td></tr></table></figure><p>上述代码为多重排序，以<code>Title</code>从小到大、<code>Year</code>从小到大、<code>Length</code>从小到大排序。打印如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">Title       Artist          Album              Year   Length  <br>-----       -----           -----              -----  -----   <br>Go          Moby            Moby               1992   3m37s   <br>Go          Delilah         From the Roots Up  2012   3m38s   <br>Go Ahead    Alicia Keys     As I Am            2007   4m36s   <br>Ready 2 Go  Martin Solveig  Smash              2011   4m24s   <br><br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.8：</strong> 很多图形界面提供了一个有状态的多重排序表格插件：主要的排序键是最近一次点击过列头的列，第二个排序键是第二最近点击过列头的列，等等。定义一个sort.Interface的实现用在这样的表格中。比较这个实现方式和重复使用sort.Stable来排序的方式。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br><span class="hljs-string">&quot;text/tabwriter&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Track <span class="hljs-keyword">struct</span> &#123;<br>Title  <span class="hljs-type">string</span><br>Artist <span class="hljs-type">string</span><br>Album  <span class="hljs-type">string</span><br>Year   <span class="hljs-type">int</span><br>Length time.Duration<br>&#125;<br><br><span class="hljs-keyword">var</span> tracks = []*Track&#123;<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Delilah&quot;</span>, <span class="hljs-string">&quot;From the Roots Up&quot;</span>, <span class="hljs-number">2012</span>, length(<span class="hljs-string">&quot;3m38s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-number">1992</span>, length(<span class="hljs-string">&quot;3m37s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go Ahead&quot;</span>, <span class="hljs-string">&quot;Alicia Keys&quot;</span>, <span class="hljs-string">&quot;As I Am&quot;</span>, <span class="hljs-number">2007</span>, length(<span class="hljs-string">&quot;4m36s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Ready 2 Go&quot;</span>, <span class="hljs-string">&quot;Martin Solveig&quot;</span>, <span class="hljs-string">&quot;Smash&quot;</span>, <span class="hljs-number">2011</span>, length(<span class="hljs-string">&quot;4m24s&quot;</span>)&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">length</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> time.Duration &#123;<br>d, err := time.ParseDuration(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(s)<br>&#125;<br><span class="hljs-keyword">return</span> d<br>&#125;<br><br><span class="hljs-keyword">type</span> CustomSort <span class="hljs-keyword">struct</span> &#123;<br>t    []*Track<br>less <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span><br>swap <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(c.t) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> c.less(c.t[i], c.t[j]) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; c.t[i], c.t[j] = c.t[j], c.t[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTracks</span><span class="hljs-params">(tracks []*Track)</span></span> &#123;<br><span class="hljs-keyword">const</span> format = <span class="hljs-string">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span><br>tw := <span class="hljs-built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)<br>fmt.Fprintf(tw, format, <span class="hljs-string">&quot;Title&quot;</span>, <span class="hljs-string">&quot;Artist&quot;</span>, <span class="hljs-string">&quot;Album&quot;</span>, <span class="hljs-string">&quot;Year&quot;</span>, <span class="hljs-string">&quot;Length&quot;</span>)<br>fmt.Fprintf(tw, format, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>)<br><span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> tracks &#123;<br>fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)<br>&#125;<br>tw.Flush()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">click</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Title&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Title &lt; y.Title<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Title, y.Title = y.Title, x.Title<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Artist&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Artist &lt; y.Artist<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Artist, y.Artist = y.Artist, x.Artist<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Album&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Album &lt; y.Album<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Album, y.Album = y.Album, x.Album<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Year&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Year &lt; y.Year<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Year, y.Year = y.Year, x.Year<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Length&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Length &lt; y.Length<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Length, y.Length = y.Length, x.Length<br>&#125;,<br>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>click(<span class="hljs-string">&quot;Title&quot;</span>)<br>printTracks(tracks)<br><br>click(<span class="hljs-string">&quot;Artist&quot;</span>)<br>printTracks(tracks)<br><br>click(<span class="hljs-string">&quot;Album&quot;</span>)<br>printTracks(tracks)<br><br>click(<span class="hljs-string">&quot;Year&quot;</span>)<br>printTracks(tracks)<br><br>click(<span class="hljs-string">&quot;Length&quot;</span>)<br>printTracks(tracks)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.9：</strong> 使用html&#x2F;template包 (§4.6) 替代printTracks将tracks展示成一个HTML表格。将这个解决方案用在前一个练习中，让每次点击一个列的头部产生一个HTTP请求来排序这个表格。<br>解：<br>index.html</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Track&lt;/title&gt;<br>    &lt;link rel=<span class="hljs-string">&quot;icon&quot;</span> href=<span class="hljs-string">&quot;data:;&quot;</span>&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;table&gt;<br>    &lt;tr style=<span class="hljs-string">&quot;text-align: left&quot;</span>&gt;<br>        &lt;th&gt;&lt;a href=<span class="hljs-string">&quot;/title&quot;</span>&gt;Title&lt;/a&gt;&lt;/th&gt;<br>        &lt;th&gt;&lt;a href=<span class="hljs-string">&quot;/artist&quot;</span>&gt;Artist&lt;/a&gt;&lt;/th&gt;<br>        &lt;th&gt;&lt;a href=<span class="hljs-string">&quot;/album&quot;</span>&gt;Album&lt;/a&gt;&lt;/th&gt;<br>        &lt;th&gt;&lt;a href=<span class="hljs-string">&quot;/year&quot;</span>&gt;Year&lt;/a&gt;&lt;/th&gt;<br>        &lt;th&gt;&lt;a href=<span class="hljs-string">&quot;/length&quot;</span>&gt;Length&lt;/a&gt;&lt;/th&gt;<br>    &lt;/tr&gt;<br>    &#123;&#123;<span class="hljs-keyword">range</span> .&#125;&#125;<br>    &lt;tr&gt;<br>        &lt;td&gt;&#123;&#123;.Title&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Artist&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Album&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Year&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Length&#125;&#125;&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &#123;&#123;end&#125;&#125;<br>&lt;/table&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;:8888&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">switch</span> r.URL.Path &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/title&quot;</span>:<br>click(<span class="hljs-string">&quot;Title&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/artist&quot;</span>:<br>click(<span class="hljs-string">&quot;Artist&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/album&quot;</span>:<br>click(<span class="hljs-string">&quot;Album&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/year&quot;</span>:<br>click(<span class="hljs-string">&quot;Year&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/length&quot;</span>:<br>click(<span class="hljs-string">&quot;Length&quot;</span>)<br>&#125;<br><br>tmpl := template.Must(template.ParseFiles(<span class="hljs-string">&quot;./ex/ex7/ex7.9/index.html&quot;</span>))<br><span class="hljs-keyword">if</span> err := tmpl.Execute(w, &amp;tracks); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">click</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Title&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Title &lt; y.Title<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Title, y.Title = y.Title, x.Title<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Artist&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Artist &lt; y.Artist<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Artist, y.Artist = y.Artist, x.Artist<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Album&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Album &lt; y.Album<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Album, y.Album = y.Album, x.Album<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Year&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Year &lt; y.Year<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Year, y.Year = y.Year, x.Year<br>&#125;,<br>&#125;)<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Length&quot;</span>:<br>sort.Stable(CustomSort&#123;<br>t: tracks,<br>less: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> x.Length &lt; y.Length<br>&#125;,<br>swap: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> &#123;<br>x.Length, y.Length = y.Length, x.Length<br>&#125;,<br>&#125;)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Track <span class="hljs-keyword">struct</span> &#123;<br>Title  <span class="hljs-type">string</span><br>Artist <span class="hljs-type">string</span><br>Album  <span class="hljs-type">string</span><br>Year   <span class="hljs-type">int</span><br>Length time.Duration<br>&#125;<br><br><span class="hljs-keyword">var</span> tracks = []*Track&#123;<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Delilah&quot;</span>, <span class="hljs-string">&quot;From the Roots Up&quot;</span>, <span class="hljs-number">2012</span>, length(<span class="hljs-string">&quot;3m38s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-number">1992</span>, length(<span class="hljs-string">&quot;3m37s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Go Ahead&quot;</span>, <span class="hljs-string">&quot;Alicia Keys&quot;</span>, <span class="hljs-string">&quot;As I Am&quot;</span>, <span class="hljs-number">2007</span>, length(<span class="hljs-string">&quot;4m36s&quot;</span>)&#125;,<br>&#123;<span class="hljs-string">&quot;Ready 2 Go&quot;</span>, <span class="hljs-string">&quot;Martin Solveig&quot;</span>, <span class="hljs-string">&quot;Smash&quot;</span>, <span class="hljs-number">2011</span>, length(<span class="hljs-string">&quot;4m24s&quot;</span>)&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">length</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> time.Duration &#123;<br>duration, err := time.ParseDuration(s)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(s)<br>&#125;<br><span class="hljs-keyword">return</span> duration<br>&#125;<br><br><span class="hljs-keyword">type</span> CustomSort <span class="hljs-keyword">struct</span> &#123;<br>t    []*Track<br>less <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span> <span class="hljs-type">bool</span><br>swap <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(c.t) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> c.less(c.t[i], c.t[j]) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c CustomSort)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; c.swap(c.t[i], c.t[j]) &#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.10：</strong> sort.Interface类型也可以适用在其它地方。编写一个IsPalindrome(s sort.Interface) bool函数表明序列s是否是回文序列，换句话说反向排序不会改变这个序列。假设如果!s.Less(i, j) &amp;&amp; !s.Less(j, i)则索引i和j上的元素相等。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> str []<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s str)</span></span> Len() <span class="hljs-type">int</span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s str)</span></span> Less(i, j <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123; <span class="hljs-keyword">return</span> s[i] &lt; s[j] &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s str)</span></span> Swap(i, j <span class="hljs-type">int</span>)      &#123; s[i], s[j] = s[j], s[i] &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s sort.Interface)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, s.Len()<span class="hljs-number">-1</span>; i &lt;= j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">if</span> s.Less(i, j) || s.Less(j, i) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;abccba&quot;</span><br>fmt.Println(IsPalindrome(str(s)))<br>s1 := <span class="hljs-string">&quot;abccbad&quot;</span><br>fmt.Println(IsPalindrome(str(s1)))<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.5 接口值</title>
      <link href="/posts/b8be0b651295/"/>
      <url>/posts/b8be0b651295/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>接口值由两部分组成，具体类型和类型的值，也称为动态类型和动态值。<br>如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout<br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>w = <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>4个语句中，变量w得到了3个不同的值。<br>在Go语言中，变量在声明中会被初始化为其类型的零值。<br>对于接口类型，同样会被初始化为零值，一个接口的零值指的是接口的类型和值都是nil。<br>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。<br>同样的，可以使用<code>w==nil</code>和<code>w!=nil</code>判断接口值是否为空。<br>需要注意的是，调用空接口值的任何方法都会导致Panic。</p><p>在上述的例子中，第二条语句<code>w = os.Stdout</code>的赋值过程，具体类型隐式转换到接口类型，和显式转换<code>w = io.Writer(os.Stdout)</code>是等价的。<br>无论隐式转换和显式转换，接口的动态类型为具体类型的指针类型<code>*os.File</code>，动态值为<code>os.Stdout</code>的拷贝。</p><p><img src="/7.5%20%E6%8E%A5%E5%8F%A3%E5%80%BC/1688959129573.png"><br>上图是<code>w = os.Stdout</code>的内存解析图，可知接口类型的变量w，具体类型为<code>os.Stdout</code>的类型<code>*os.File</code>，值为stdout的输出值。</p><p>调用方法，如下面的例子，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">w.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>接口类型的变量w调用<code>*os.File</code>的方法<code>Write</code>，即<code>(*os.File).Write</code>方法被调用，并输出hello。</p><p>在编译过程中，编译器并不知道接口值的动态类型是什么，所以在接口的调用必然是动态分配，而不是直接调用。所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。<br>调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Stdout.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>第三个语句<code>w = new(bytes.Buffer)</code>，给接口值赋值了<code>*bytes.Buffer</code>类型的值。<br>解析图如下，<br><img src="/7.5%20%E6%8E%A5%E5%8F%A3%E5%80%BC/1688960089162.png"></p><p>接口值的动态类型为<code>*bytes.Buffer</code>，动态值为一个指向新分配的缓冲区的指针。<br><code>w.Write([]byte(&quot;hello&quot;))</code>方法调用与第二条语句一样的机制。<br>这次类型描述符是<code>*bytes.Buffer</code>，所以调用了<code>(*bytes.Buffer).Write</code>方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p><p>最后，第四个语句<code>w = nil</code>是把nil赋值给了接口值。<br>它把接口值所有部分重置为nil，如下图，<br><img src="/7.5%20%E6%8E%A5%E5%8F%A3%E5%80%BC/1688960372400.png"></p><h1 id="任意大的接口值"><a href="#任意大的接口值" class="headerlink" title="任意大的接口值"></a>任意大的接口值</h1><p><code>一个接口值可以持有任意大的动态值。</code><br>如<code>time.Time</code>类型，有几个不公开的字段，如下，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = time.Now()<br></code></pre></td></tr></table></figure><p>从概念上讲，不论接口值多大，动态值总是可以容下它。（这只是一个概念上的模型；具体的实现可能会非常不同）下图仅是相似：<br><img src="/7.5%20%E6%8E%A5%E5%8F%A3%E5%80%BC/1688961015374.png"></p><h1 id="接口值的比较"><a href="#接口值的比较" class="headerlink" title="接口值的比较"></a>接口值的比较</h1><p>接口值可以使用<code>==</code>和<code>!=</code>来进行比较。<br>两个接口值相同的条件：</p><ul><li>都为nil值。</li><li>动态类型相同且动态值也能使用<code>==</code>匹配。</li></ul><p>如果动态类型相同，但动态类型不能进行比较，如<code>slice</code>，将它们进行比较式，会产生panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(x == x) <span class="hljs-comment">// panic: runtime error: comparing uncomparable type []int</span><br></code></pre></td></tr></table></figure><p>可比较类型有<code>基本类型和指针</code>，不可比较类型<code>slice</code>，<code>map</code>和<code>函数</code>。<br>但在比较接口值包含聚合类型时，必须要考虑可能会出现的异常。同样的，当接口值当做map的键或者switch的操作数时，要考虑到动态值的是否可以比较。</p><h1 id="获取接口值的类型"><a href="#获取接口值的类型" class="headerlink" title="获取接口值的类型"></a>获取接口值的类型</h1><p>在fmt包内，我们可以使用<code>%T</code>的输出格式符用于输出接口值的类型，便于处理错误和调试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// &lt;nil&gt;</span><br>w = os.Stdout<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// *os.File</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// *bytes.Buffer</span><br></code></pre></td></tr></table></figure><h1 id="7-5-1-警告：一个包含nil指针的接口不是nil接口"><a href="#7-5-1-警告：一个包含nil指针的接口不是nil接口" class="headerlink" title="7.5.1.  警告：一个包含nil指针的接口不是nil接口"></a>7.5.1.  警告：一个包含nil指针的接口不是nil接口</h1><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。<br>下面例子，可以很好说明两者的区别。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> debug = <span class="hljs-literal">true</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> buf *bytes.Buffer<br><span class="hljs-keyword">if</span> debug &#123;<br>buf = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>&#125;<br>f(buf)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">if</span> out != <span class="hljs-literal">nil</span> &#123;<br>out.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;done!\n&quot;</span>)) <span class="hljs-comment">// if debug = false, panic: runtime error: invalid memory address or nil pointer dereference</span><br><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>声明buf指针变量，即空指针，当debug为true时，<code>new(bytes.Buffer)</code>创建了空间， buf又指向了该空间。<br>随后当调用f函数，将buf变量赋予给out接口值，out的动态类型为<code>*bytes.Buffer</code>，动态值为new创建的变量，最后是调用了<code>bytes.Buffer</code>的write方法。<br>而当debug为false时，buf未被重新赋值，仍是空指针，调用f函数时，out参数被赋值为<code>*bytes.Buffer</code>的空指针，即out的动态值为nil，动态类型为<code>*bytes.Buffer</code>，也就是说out是包含空指针值的非空接口，如下图，<br><img src="/7.5%20%E6%8E%A5%E5%8F%A3%E5%80%BC/1688978957852.png"><br>动态分配机制使得out仍然会调用<code>(*bytes.Buffer)Write</code>方法，但是接收者为nil，对于<code>*os.File</code>类型，nil依然是有效的接收者，显然<code>*bytes.Buffer</code>类型不是。方法被调用后，尝试获取缓冲区的内容导致异常。</p><p>虽然nil的<code>*bytes.Buffer</code>指针可以实现<code>io.Write</code>接口的方法，但是却不满足具体方法<code>(*bytes.Buffer).Write</code>接收者不能为nil的先决条件。<br>将<code>*bytes.Buffer</code>改成<code>io.Writer</code>类型即可，避免将不完全的值赋值给<code>io.Writer</code>这个接口即可解决这个问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> debug = <span class="hljs-literal">false</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//var buf *bytes.Buffer</span><br><span class="hljs-keyword">var</span> buf io.Writer<br><span class="hljs-keyword">if</span> debug &#123;<br>buf = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>&#125;<br>f(buf)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">if</span> out != <span class="hljs-literal">nil</span> &#123;<br>out.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;done!\n&quot;</span>)) <span class="hljs-comment">// if debug = false, panic: runtime error: invalid memory address or nil pointer dereference</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.4 flag.Value接口</title>
      <link href="/posts/146b263d555d/"/>
      <url>/posts/146b263d555d/</url>
      
        <content type="html"><![CDATA[<p>使用<code>flag.Value</code>接口，可以定义新的命令行符号。<br>下面是休眠特定时间的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> period = flag.Duration(<span class="hljs-string">&quot;period&quot;</span>, <span class="hljs-number">1</span>*time.Second, <span class="hljs-string">&quot;sleep period&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>fmt.Printf(<span class="hljs-string">&quot;Sleeping for %v...&quot;</span>, *period)<br>time.Sleep(*period)<br>fmt.Println()<br>&#125;<br></code></pre></td></tr></table></figure><p>在休眠前，打印出休眠的时长。<br>fmt包调用time.Duration的String方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> build /sleep/main.<span class="hljs-keyword">go</span><br>$ ./main<br>Sleeping <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>s...<br></code></pre></td></tr></table></figure><p>flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./sleep -period 50ms</span><br>Sleeping for 50ms...<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./sleep -period 2m30s</span><br>Sleeping for 2m30s...<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./sleep -period 1.5h</span><br>Sleeping for 1h30m0s...<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./sleep -period <span class="hljs-string">&quot;1 day&quot;</span></span><br>invalid value &quot;1 day&quot; for flag -period: time: invalid duration 1 day<br></code></pre></td></tr></table></figure><p>定义新的命令行标记符号，只需要实现<code>flag.Value</code>接口即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;<br>String() <span class="hljs-type">string</span><br>Set(<span class="hljs-type">string</span>) <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>String</code>方法是格式化<code>flag.Value</code>，使得每个<code>flag.Value</code>都是一个<code>fmt.Stringer</code>。<br><code>Set</code>方法解析字符串参数并且更新<code>flag.Value</code>的值。</p><p>定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9.0</span>/<span class="hljs-number">5.0</span> + <span class="hljs-number">32.0</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32.0</span>) * <span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c)<br>&#125;<br><br><span class="hljs-keyword">type</span> celsiusFlag <span class="hljs-keyword">struct</span> &#123;<br>Celsius<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *celsiusFlag)</span></span> Set(s <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-type">uint</span> <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> value <span class="hljs-type">float64</span><br>fmt.Sscanf(s, <span class="hljs-string">&quot;%f%s&quot;</span>, &amp;value, &amp;<span class="hljs-type">uint</span>)<br><span class="hljs-keyword">switch</span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;°C&quot;</span>:<br>f.Celsius = Celsius(value)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;°F&quot;</span>:<br>f.Celsius = FToC(Fahrenheit(value))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;invalid temperature %q&quot;</span>, s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CelsiusFlag</span><span class="hljs-params">(name <span class="hljs-type">string</span>, value Celsius, usage <span class="hljs-type">string</span>)</span></span> *Celsius &#123;<br>f := celsiusFlag&#123;value&#125;<br>flag.CommandLine.Var(&amp;f, name, usage)<br><span class="hljs-keyword">return</span> &amp;f.Celsius<br>&#125;<br></code></pre></td></tr></table></figure><p>Celsius类型实现了String方法，celsiusFlag实现了Set方法。<br>flag.CommandLine.Var调用Var方法将一个celsiusFlag参数赋值给一个flag.Value参数,导致编译器去检查celsiusFlag是否有必须的方法。</p><p>下面是使用新命令行的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch7/tempconv&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> temp = tempconv.CelsiusFlag(<span class="hljs-string">&quot;temp&quot;</span>, <span class="hljs-number">20.0</span>, <span class="hljs-string">&quot;the temperature&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>fmt.Println(*temp)<br>&#125;<br></code></pre></td></tr></table></figure><p>上方例子中，可根据输入的温度转换为摄氏度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build tempflag.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./tempflag</span><br>20°C<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./tempflag -temp -18C</span><br>-18°C<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./tempflag -temp 212°F</span><br>100°C<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.6：</strong> 对tempFlag加入支持开尔文温度。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Kelvin <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9.0</span>/<span class="hljs-number">5.0</span> + <span class="hljs-number">32.0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32.0</span>) * <span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToK</span><span class="hljs-params">(c Celsius)</span></span> Kelvin &#123;<br><span class="hljs-keyword">return</span> Kelvin(c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KToC</span><span class="hljs-params">(k Kelvin)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius(k)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c)<br>&#125;<br><br><span class="hljs-keyword">type</span> celsiusFlag <span class="hljs-keyword">struct</span> &#123;<br>Celsius<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f celsiusFlag)</span></span> Set(s <span class="hljs-type">string</span>) <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-type">uint</span> <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> value <span class="hljs-type">float64</span><br>fmt.Sscanf(s, <span class="hljs-string">&quot;%s%g&quot;</span>, &amp;<span class="hljs-type">uint</span>, &amp;value)<br><span class="hljs-keyword">switch</span> <span class="hljs-type">uint</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;°C&quot;</span>:<br>f.Celsius = Celsius(value)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;°F&quot;</span>:<br>f.Celsius = FToC(Fahrenheit(value))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;K&quot;</span>:<br>f.Celsius = KToC(Kelvin(value))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;invaild temperature %q&quot;</span>, s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CelsiusFlag</span><span class="hljs-params">(name <span class="hljs-type">string</span>, value Celsius, usage <span class="hljs-type">string</span>)</span></span> *Celsius &#123;<br>f := celsiusFlag&#123;value&#125;<br>flag.CommandLine.Var(&amp;f, name, usage)<br><span class="hljs-keyword">return</span> &amp;f.Celsius<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 7.7：</strong> 解释为什么帮助信息在它的默认值是20.0没有包含°C的情况下输出了°C。<br>解：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">因为默认值类型为*Celsius, 而Celsius类型实现了String()方法，<br>所以在fmt.Println(*temp)时，按照String()方法格式化输出了20°C。<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.3 实现接口的条件</title>
      <link href="/posts/001ff23c523b/"/>
      <url>/posts/001ff23c523b/</url>
      
        <content type="html"><![CDATA[<h1 id="实现接口的规则"><a href="#实现接口的规则" class="headerlink" title="实现接口的规则"></a>实现接口的规则</h1><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。<br>如果一个类型属于某个接口，只要这个类型实现这个接口。<br>如果某类型能够赋值或new对象赋值给接口类型，那么说明该类型实现了接口的所有方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer<br>w = os.Stdout         <span class="hljs-comment">// *File 实现了Write方法</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// *bytes.Buffer 实现了Write方法</span><br><span class="hljs-comment">//w = time.Second       // 编译错误，time.Duration 没有实现Write方法</span><br>fmt.Println(w)<br><br><span class="hljs-keyword">var</span> rwc io.ReadWriteCloser<br>rwc = os.Stdout <span class="hljs-comment">// *File实现了Read,Write,Close方法</span><br><span class="hljs-comment">//rwc = new(bytes.Buffer) // 编译错误， *bytes.Buffer没有实现Close方法</span><br>fmt.Println(rwc)<br></code></pre></td></tr></table></figure><p>这个规则也可以适用于两个接口类。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">w = rwc <span class="hljs-comment">// rwc实现了w接口的方法</span><br>rwc = w <span class="hljs-comment">// 编译错误，w未实现rwc接口的所有方法</span><br></code></pre></td></tr></table></figure><h1 id="类型的指针与类型实现接口"><a href="#类型的指针与类型实现接口" class="headerlink" title="类型的指针与类型实现接口"></a>类型的指针与类型实现接口</h1><p>类型T的方法的接收器可以是类型<code>T</code>本身，也可以<code>*T</code>指针类型。<br>类型T的变量调用T类型的方法是合法。<br>T类型的值不拥有所有<code>*T</code>指针的方法，那这样T类型就可能只实现更少的接口。<br>对于<code>*T</code>指针实现接口，在T类型变量调用时，编译器可以隐式获取地址，即在变量前加上<code>&amp;</code>。<br>如下例子，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span></span> String() <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> _ = IntSet&#123;&#125;.String() <span class="hljs-comment">// compile error: String requires *IntSet receiver</span><br></code></pre></td></tr></table></figure><p>但是可以在IntSet值上调用该方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s IntSet<br><span class="hljs-keyword">var</span> _ = s.String() <span class="hljs-comment">// OK: s is a variable and &amp;s has a String method</span><br></code></pre></td></tr></table></figure><p>然而，只有<code>*IntSet</code>拥有<code>String() string</code>方法，所以也有<code>*IntSet</code>类型实现了<code>fmt.Stringer</code>接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ fmt.Stringer = &amp;s <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">var</span> _ fmt.Stringer = s  <span class="hljs-comment">// compile error: IntSet lacks String method</span><br></code></pre></td></tr></table></figure><h1 id="空接口类型"><a href="#空接口类型" class="headerlink" title="空接口类型"></a>空接口类型</h1><p><code>interface&#123;&#125;</code>为空接口类型，对类型没有要求，其变量则可以被任意类型的值赋值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;<br>any = <span class="hljs-literal">true</span><br>any = <span class="hljs-number">12.34</span><br>any = <span class="hljs-string">&quot;hello&quot;</span><br>any = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>&#125;<br>any = <span class="hljs-built_in">new</span>(bytes.Buffer)<br></code></pre></td></tr></table></figure><p>由于空类型拥有任意类型，但不能对空类型持有的值进行直接操作，因为空类型没有任何方法。</p><h1 id="nil实现接口"><a href="#nil实现接口" class="headerlink" title="nil实现接口"></a>nil实现接口</h1><p>因为接口实现只依赖于判断的两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。<br>下面的定义在编译期断言一个<code>*bytes.Buffer</code>的值实现了io.Writer接口类型:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// *bytes.Buffer must satisfy io.Writer</span><br><span class="hljs-keyword">var</span> w io.Writer = <span class="hljs-built_in">new</span>(bytes.Buffer)<br></code></pre></td></tr></table></figure><p>任意bytes.Buffer的值，甚至包括nil通过(bytes.Buffer)(nil)进行显示的转换都实现了这个接口。<br>即：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// *bytes.Buffer must satisfy io.Writer</span><br><span class="hljs-keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="hljs-literal">nil</span>)<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.2. 接口类型</title>
      <link href="/posts/55bc49f4b7cc/"/>
      <url>/posts/55bc49f4b7cc/</url>
      
        <content type="html"><![CDATA[<p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p><h1 id="单方法接口命名"><a href="#单方法接口命名" class="headerlink" title="单方法接口命名"></a>单方法接口命名</h1><p>在Go语言中，单方法接口的命名习惯是很常见的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> io<br><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>&#125;<br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>    Close() <span class="hljs-type">error</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="接口内嵌"><a href="#接口内嵌" class="headerlink" title="接口内嵌"></a>接口内嵌</h1><p>和结构内嵌相似，我们可以用这种方式以一个简写命名另一个接口，而不用声明它所有的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>&#125;<br><span class="hljs-keyword">type</span> ReadWriteCloser <span class="hljs-keyword">interface</span> &#123;<br>    Reader<br>    Writer<br>    Closer<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="混合接口命名"><a href="#混合接口命名" class="headerlink" title="混合接口命名"></a>混合接口命名</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>    Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>)<br>    Writer<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上述三种方法，都是一样的效果。方法的顺序变化不影响，主要是接口那的方法。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.4：</strong> strings.NewReader函数通过读取一个string参数返回一个满足io.Reader接口类型的值（和其它值）。实现一个简单版本的NewReader，并用它来构造一个接收字符串输入的HTML解析器（§5.2）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>_, err := html.Parse(NewReader(<span class="hljs-string">&quot;&lt;h1&gt;Hello&lt;/h1&gt;&quot;</span>))<br><span class="hljs-keyword">for</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;html parse err: %v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> StringReader <span class="hljs-type">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *StringReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-built_in">copy</span>(p, *s)<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(*s), io.EOF<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> io.Reader &#123;<br>sr := StringReader(s)<br><span class="hljs-keyword">return</span> &amp;sr<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 7.5：</strong> io包里面的LimitReader函数接收一个io.Reader接口类型的r和字节数n，并且返回另一个从r中读取字节但是当读完n个字节后就表示读到文件结束的Reader。实现这个LimitReader函数：</p><blockquote><p>func LimitReader(r io.Reader, n int64) io.Reader</p></blockquote><p>解:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lr := LimitReader(strings.NewReader(<span class="hljs-string">&quot;12345&quot;</span>), <span class="hljs-number">1</span>)<br>b, err := io.ReadAll(lr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;err: %v&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, b)<br>&#125;<br><br><span class="hljs-keyword">type</span> LimitedReader <span class="hljs-keyword">struct</span> &#123;<br>underlyingReader io.Reader<br>remainBytes      <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *LimitedReader)</span></span> Read(p []<span class="hljs-type">byte</span>) (n <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> r.remainBytes &lt;= <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, io.EOF<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(<span class="hljs-built_in">len</span>(p)) &gt; r.remainBytes &#123;<br>p = p[:r.remainBytes]<br>&#125;<br>n, err = r.underlyingReader.Read(p)<br>r.remainBytes -= <span class="hljs-type">int64</span>(n)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LimitReader</span><span class="hljs-params">(r io.Reader, n <span class="hljs-type">int64</span>)</span></span> io.Reader &#123;<br><span class="hljs-keyword">return</span> &amp;LimitedReader&#123;r, n&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7.1. 接口约定</title>
      <link href="/posts/8e657f0750ec/"/>
      <url>/posts/8e657f0750ec/</url>
      
        <content type="html"><![CDATA[<p>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会展示出它们自己的方法。</p><p>下面<code>*ByteCounter</code>类型里的Write方法，仅仅在丢失写向它的字节前统计它们的长度。(在这个+&#x3D;赋值语句中，让<code>len(p)</code>的类型和<code>*c</code>的类型匹配的转换是必须的。)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Bytecounter demonstrates an implementation of io.Writer that counts bytes.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> ByteCounter <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ByteCounter)</span></span> Write(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>*c += ByteCounter(<span class="hljs-built_in">len</span>(p))<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c ByteCounter<br>c.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>))<br>fmt.Println(c) <span class="hljs-comment">// 5</span><br><br>c = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Dolly&quot;</span><br>fmt.Fprintf(&amp;c, <span class="hljs-string">&quot;hello, %s&quot;</span>, name)<br>fmt.Println(c) <span class="hljs-comment">// 12</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>因为<code>*ByteCounter</code>满足<code>io.Writer</code>的约定，我们可以把它传入Fprintf函数中；Fprintf函数执行字符串格式化的过程不会去关注ByteCounter正确的累加结果的长度。<br>除了<code>io.Writer</code>这个接口，还有<code>fmt.Stringer</code>。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>String() <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只要类型实现了该接口，则在fmt下既可以输出实现的返回值。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 7.1：</strong> 使用来自ByteCounter的思路，实现一个针对对单词和行数的计数器。你会发现bufio.ScanWords非常的有用。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;Hello, World!\nHello, 世界！&quot;</span><br><br><span class="hljs-keyword">var</span> wc WordCounter<br>fmt.Fprintf(&amp;wc, s)<br>fmt.Println(wc)<br><br><span class="hljs-keyword">var</span> lc LineCounter<br>fmt.Fprintf(&amp;lc, s)<br>fmt.Println(lc)<br>&#125;<br><br><span class="hljs-keyword">type</span> WordCounter <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *WordCounter)</span></span> Write(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>scanner := bufio.NewScanner(bytes.NewReader(p))<br>scanner.Split(bufio.ScanWords)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>*c++<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">type</span> LineCounter <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *LineCounter)</span></span> Write(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>scanner := bufio.NewScanner(bytes.NewReader(p))<br>scanner.Split(bufio.ScanLines)<br><span class="hljs-keyword">for</span> scanner.Scan() &#123;<br>*c++<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 7.2：</strong> 写一个带有如下函数签名的函数CountingWriter，传入一个io.Writer接口类型，返回一个新的Writer类型把原来的Writer封装在里面和一个表示写入新的Writer字节数的int64类型指针</p><blockquote><p>func CountingWriter(w io.Writer) (io.Writer, *int64)</p></blockquote><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>w, c := CountingWriter(io.Discard)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Hello, World!\n&quot;</span>)<br>fmt.Println(*c)<br>&#125;<br><br><span class="hljs-keyword">type</span> ByteCounter <span class="hljs-keyword">struct</span> &#123;<br>w       io.Writer<br>written <span class="hljs-type">int64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ByteCounter)</span></span> Write(p []<span class="hljs-type">byte</span>) (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>n, err := c.w.Write(p)<br>c.written += <span class="hljs-type">int64</span>(n)<br><span class="hljs-keyword">return</span> n, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountingWriter</span><span class="hljs-params">(w io.Writer)</span></span> (io.Writer, *<span class="hljs-type">int64</span>) &#123;<br>c := ByteCounter&#123;w, <span class="hljs-number">0</span>&#125;<br><span class="hljs-keyword">return</span> &amp;c, &amp;c.written<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 7.3：</strong> 为在<code>gopl.io/ch4/treesort (§4.4)</code>的<code>*tree</code>类型实现一个String方法去展示tree类型的值序列。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> treesort<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;strconv&quot;</span><br><br><span class="hljs-keyword">type</span> tree <span class="hljs-keyword">struct</span> &#123;<br>value       <span class="hljs-type">int</span><br>left, right *tree<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> root *tree<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>root = add(root, v)<br>&#125;<br>appendValues(values[:<span class="hljs-number">0</span>], root)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendValues</span><span class="hljs-params">(values []<span class="hljs-type">int</span>, t *tree)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> t != <span class="hljs-literal">nil</span> &#123;<br>values = appendValues(values, t.left)<br>values = <span class="hljs-built_in">append</span>(values, t.value)<br>values = appendValues(values, t.right)<br>&#125;<br><span class="hljs-keyword">return</span> values<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(t *tree, value <span class="hljs-type">int</span>)</span></span> *tree &#123;<br><span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br>t = <span class="hljs-built_in">new</span>(tree)<br>t.value = value<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-keyword">if</span> value &lt; t.value &#123;<br>t.left = add(t.left, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.right = add(t.right, value)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *tree)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><br>s += t.left.String()<br>s += strconv.Itoa(t.value)<br>s += t.right.String()<br><br><span class="hljs-keyword">return</span> s<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *tree)</span></span> Values() []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> vals []<span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> vals<br>&#125;<br><br>vals = <span class="hljs-built_in">append</span>(vals, t.left.Values()...)<br>vals = <span class="hljs-built_in">append</span>(vals, t.value)<br>vals = <span class="hljs-built_in">append</span>(vals, t.right.Values()...)<br><br><span class="hljs-keyword">return</span> vals<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第七章 接口</title>
      <link href="/posts/f2552a5080b3/"/>
      <url>/posts/f2552a5080b3/</url>
      
        <content type="html"><![CDATA[<p>接口类型是对其它类型行为的抽象和概括。<br>Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</p><p><a href="/posts/8e657f0750ec/">7.1. 接口约定</a><br><a href="/posts/55bc49f4b7cc/">7.2. 接口类型</a><br><a href="">7.3. 实现接口的条件</a><br><a href="">7.4. flag.Value接口</a><br><a href="">7.5. 接口值</a><br><a href="/posts/8d8e98ca9007/">7.6. sort.Interface接口</a><br><a href="/posts/fc3145dbfc40/">7.7. http.Handler接口</a><br><a href="/posts/21f47e2c8c53/">7.8. error接口</a><br><a href="/posts/d3aed5deb5f5/">7.9. 示例：表达式求值</a><br><a href="/posts/fcef06327bd8/">7.10. 类型断言</a><br><a href="">7.11. 基于类型断言识别错误类型</a><br><a href="">7.12. 通过类型断言查询接口</a><br><a href="">7.13. 类型分支</a><br><a href="">7.14. 示例：基于标志的XML解码</a><br><a href="">7.15. 补充几点</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.6. 封装</title>
      <link href="/posts/387bb90cfe97/"/>
      <url>/posts/387bb90cfe97/</url>
      
        <content type="html"><![CDATA[<p>一个对象的方法和字段对调用方不可见，定义为封装。<br>封装也叫信息隐藏。</p><p>Go语言只有一种方法来控制可见性：<code>大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。</code><br>一般情况下，Go语言内，封装一个对象，只有定义为struct类型。<br>如<code>IntSet</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint</span><br>&#125;<br></code></pre></td></tr></table></figure><p>words只能在包内访问，所以能很好地隐藏。</p><p>封装的三个优点：</p><ul><li>因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</li><li>隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</li><li>阻止了外部调用方对对象内部的值任意地进行修改。</li></ul>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.5. 示例：Bit数组</title>
      <link href="/posts/aaab166a7bb7/"/>
      <url>/posts/aaab166a7bb7/</url>
      
        <content type="html"><![CDATA[<p>下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package intset provides a set of integers based on a bit vector.</span><br><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// An IntSet is a set of small non-negative integers.</span><br><span class="hljs-comment">// Its zero value represents the empty set.</span><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Add adds the non-negative value x to the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><p>因为每一个字都有64个二进制位，所以为了定位x的bit位，我们用了x&#x2F;64的商作为字的下标，并且用x%64得到的值作为这个字内的bit的所在位置。UnionWith这个方法里用到了bit位的“或”逻辑操作符号|来一次完成64个元素的或计算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y IntSet<br>x.Add(<span class="hljs-number">1</span>)<br>x.Add(<span class="hljs-number">144</span>)<br>x.Add(<span class="hljs-number">9</span>)<br>fmt.Println(x.String()) <span class="hljs-comment">// &#123;1 9 144&#125;</span><br><br>y.Add(<span class="hljs-number">9</span>)<br>y.Add(<span class="hljs-number">42</span>)<br>fmt.Println(y.String()) <span class="hljs-comment">// &#123;9 42&#125;</span><br><br>x.UnionWith(&amp;y)<br>fmt.Println(x.String()) <span class="hljs-comment">// &#123;1 9 42 144&#125;</span><br><br>fmt.Println(x.Has(<span class="hljs-number">9</span>), x.Has(<span class="hljs-number">123</span>)) <span class="hljs-comment">// true false</span><br></code></pre></td></tr></table></figure><p>String方法定义在IntSet指针上，所以当我们的变量是IntSet类型而不是IntSet指针时，可能会有下面这样让人意外的情况：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x IntSet<br>x.Add(<span class="hljs-number">1</span>)<br>x.Add(<span class="hljs-number">144</span>)<br>x.Add(<span class="hljs-number">9</span>)<br>x.Add(<span class="hljs-number">42</span>)<br><br><span class="hljs-comment">//!+note</span><br>fmt.Println(&amp;x)         <span class="hljs-comment">// &#123;1 9 42 144&#125;</span><br>fmt.Println(x.String()) <span class="hljs-comment">// &#123;1 9 42 144&#125;</span><br>fmt.Println(x)          <span class="hljs-comment">// &#123;[4398046511618 0 65536]&#125;</span><br><span class="hljs-comment">//!-note</span><br></code></pre></td></tr></table></figure><p>第一个Println中，打印的是<code>*IntSet</code>指针，这个指针类型有自定义的String方法。<br>第二个Println中，直接调用的变量<code>x</code>的<code>String()</code>方法，这种情况下编译器会隐式地在x前插入&amp;操作符，相当于调用的是<code>*IntSet</code>指针的<code>String()</code>。<br>第三个Println中，因为变量x的类型<code>IntSet</code>没有<code>String()</code>的方法，所以Println会直接按原始的方式打印。<br>所以在这种情况下，将<code>String()</code>绑定到<code>IntSet</code>类型上更合适，而不是绑定在<code>*IntSet</code>指针上。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习6.1:</strong> 为bit数组实现下面这些方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span></span> Len() <span class="hljs-type">int</span>      <span class="hljs-comment">// return the number of elements</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span></span> Remove(x <span class="hljs-type">int</span>)  <span class="hljs-comment">// remove x from the set</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span></span> Clear()        <span class="hljs-comment">// remove all elements from the set</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span></span> Copy() *IntSet <span class="hljs-comment">// return a copy of the set</span><br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Add adds the non-negative value x to the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words); i &lt;= word; i++ &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-comment">// Len return the number of elements.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mask := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mask &lt; <span class="hljs-number">64</span>; mask++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;mask) != <span class="hljs-number">0</span> &#123;<br>count++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-comment">// Remove x from the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Remove(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> word &gt; <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>s.words[word] &amp;^= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// Clear remove all element of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Clear() &#123;<br>s.words = <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Copy return a copy of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Copy() *IntSet &#123;<br>c := &amp;IntSet&#123;&#125;<br>c.words = <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, <span class="hljs-built_in">len</span>(s.words))<br><span class="hljs-built_in">copy</span>(c.words, s.words)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 6.2：</strong> 定义一个变参方法<code>(*IntSet).AddAll(...int)</code>，这个方法可以为一组IntSet值求和，比如s.AddAll(1,2,3)。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Add adds the non-negative value x to the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words); i &lt;= word; i++ &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-comment">// Len return the number of elements.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mask := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mask &lt; <span class="hljs-number">64</span>; mask++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;mask) != <span class="hljs-number">0</span> &#123;<br>count++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-comment">// Remove x from the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Remove(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> word &gt; <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>s.words[word] &amp;^= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// Clear remove all element of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Clear() &#123;<br>s.words = <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Copy return a copy of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Copy() *IntSet &#123;<br>c := &amp;IntSet&#123;&#125;<br>c.words = <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, <span class="hljs-built_in">len</span>(s.words))<br><span class="hljs-built_in">copy</span>(c.words, s.words)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> AddAll(ints ...<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ints &#123;<br>s.Add(x)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 6.3：</strong> <code>(*IntSet).UnionWith</code>会用|操作符计算两个集合的并集，我们再为IntSet实现另外的几个函数IntersectWith(交集：元素在A集合B集合均出现),<code>DifferenceWith</code>(差集：元素出现在A集合，未出现在B集合),<code>SymmetricDifference</code>(并差集：元素出现在A但没有出现在B，或者出现在B没有出现在A)。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Add adds the non-negative value x to the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words); i &lt;= word; i++ &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-comment">// Len return the number of elements.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mask := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mask &lt; <span class="hljs-number">64</span>; mask++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;mask) != <span class="hljs-number">0</span> &#123;<br>count++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-comment">// Remove x from the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Remove(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> word &gt; <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>s.words[word] &amp;^= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// Clear remove all element of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Clear() &#123;<br>s.words = <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Copy return a copy of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Copy() *IntSet &#123;<br>c := &amp;IntSet&#123;&#125;<br>c.words = <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, <span class="hljs-built_in">len</span>(s.words))<br><span class="hljs-built_in">copy</span>(c.words, s.words)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> AddAll(ints ...<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ints &#123;<br>s.Add(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> IntersectWith(t *IntSet) &#123;<br>minLen := <span class="hljs-built_in">len</span>(s.words)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.words) &lt; minLen &#123;<br>minLen = <span class="hljs-built_in">len</span>(t.words)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minLen; i++ &#123;<br>s.words[i] &amp;= t.words[i]<br>&#125;<br><br><span class="hljs-comment">// 去零 -1标识默认值，如果未改变，表示没有0</span><br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := minLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 差集 s有t没有 按t清除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> DifferenceWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(t.words) &#123;<br>s.words[i] &amp;^= t.words[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果存在交集的集合，即一样的数，位清空后为0，则需要清除为0的数</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 并差集: s有t没有或者t有s没有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> SymmetricDifference(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] ^= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果存在交集的集合，即一样的数，位清空后为0，则需要清除为0的数</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习6.4：</strong> 实现一个Elems方法，返回集合中的所有元素，用于做一些range之类的遍历操作。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint64</span><br>&#125;<br><br><span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// Add adds the non-negative value x to the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words); i &lt;= word; i++ &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> UnionWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-type">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br><span class="hljs-comment">// Len return the number of elements.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Len() <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mask := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mask &lt; <span class="hljs-number">64</span>; mask++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;mask) != <span class="hljs-number">0</span> &#123;<br>count++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-comment">// Remove x from the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Remove(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-type">uint</span>(x%<span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>s.words[word] &amp;^= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-comment">// Clear remove all element of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Clear() &#123;<br>s.words = <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Copy return a copy of the set.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Copy() *IntSet &#123;<br>c := &amp;IntSet&#123;&#125;<br>c.words = <span class="hljs-built_in">make</span>([]<span class="hljs-type">uint64</span>, <span class="hljs-built_in">len</span>(s.words))<br><span class="hljs-built_in">copy</span>(c.words, s.words)<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> AddAll(ints ...<span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> ints &#123;<br>s.Add(x)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 交集</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> IntersectWith(t *IntSet) &#123;<br>minLen := <span class="hljs-built_in">len</span>(s.words)<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(t.words) &lt; minLen &#123;<br>minLen = <span class="hljs-built_in">len</span>(t.words)<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; minLen; i++ &#123;<br>s.words[i] &amp;= t.words[i]<br>&#125;<br><br><span class="hljs-comment">// 去零 -1标识默认值，如果未改变，表示没有0</span><br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := minLen - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] == <span class="hljs-number">0</span> &#123;<br>l = i<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 差集 s有t没有 按t清除</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> DifferenceWith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(t.words) &#123;<br>s.words[i] &amp;^= t.words[i]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果存在交集的集合，即一样的数，位清空后为0，则需要清除为0的数</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 并差集: s有t没有或者t有s没有</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> SymmetricDifference(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] ^= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 如果存在交集的集合，即一样的数，位清空后为0，则需要清除为0的数</span><br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.words) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">var</span> l = <span class="hljs-number">-1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s.words[i] != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>l = i<br>&#125;<br><br><span class="hljs-keyword">if</span> l != <span class="hljs-number">-1</span> &#123;<br>s.words = s.words[:l]<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Elems() []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> elems []<span class="hljs-type">int</span><br>x := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">for</span> mask := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); mask &lt; <span class="hljs-number">64</span>; mask++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;mask) != <span class="hljs-number">0</span> &#123;<br>elems = <span class="hljs-built_in">append</span>(elems, x)<br>x++<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> elems<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 6.5：</strong> 我们这章定义的IntSet里的每个字都是用的uint64类型，但是64位的数值可能在32位的平台上不高效。修改程序，使其使用uint类型，这种类型对于32位平台来说更合适。当然了，这里我们可以不用简单粗暴地除64，可以定义一个常量来决定是用32还是64，这里你可能会用到平台的自动判断的一个智能表达式：<code>32 &lt;&lt; (^uint(0) &gt;&gt; 63)</code>。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intset<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-comment">// 当uint为64位时，^uint(0)为64个1，右移63位变成1，32再左移1位就变成64</span><br><span class="hljs-comment">// 当uint为32位时，^uint(0)为32个1，右移63位变成0，32再左移0位就变成32</span><br><span class="hljs-keyword">const</span> uintSize = <span class="hljs-number">32</span> &lt;&lt; (^<span class="hljs-type">uint</span>(<span class="hljs-number">0</span>) &gt;&gt; <span class="hljs-number">63</span>)<br><br><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;<br>words []<span class="hljs-type">uint</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Has(x <span class="hljs-type">int</span>) <span class="hljs-type">bool</span> &#123;<br>word, bit := x/uintSize, x%uintSize<br><span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Add(x <span class="hljs-type">int</span>) &#123;<br>word, bit := x/uintSize, x%uintSize<br><span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s.words); i &lt;= word; i++ &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)<br>&#125;<br>&#125;<br>s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> Unionwith(t *IntSet) &#123;<br><span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<br><span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;<br>s.words[i] |= tword<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>s.words = <span class="hljs-built_in">append</span>(s.words, tword)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<br><span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<br><span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; uintSize; j++ &#123;<br><span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;j) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, uintSize*i+j)<br>&#125;<br>&#125;<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.4. 方法值和方法表达式</title>
      <link href="/posts/4fa1929ae9d9/"/>
      <url>/posts/4fa1929ae9d9/</url>
      
        <content type="html"><![CDATA[<h1 id="方法值定义"><a href="#方法值定义" class="headerlink" title="方法值定义"></a>方法值定义</h1><p>通常情况下，调用一个方法，如<code>p.Distance()</code>，实际上可以分为两步来执行。<code>p.Distance</code>是方法选择器，返回一个方法值-&gt;一个将方法（Point.Distance）绑定到特定接收器变量的函数。<br>调用时，不再需要指定接收器，只要传入函数参数即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br><br>distanceFromP := p.Distance   <span class="hljs-comment">// 方法值</span><br>fmt.Println(distanceFromP(q)) <span class="hljs-comment">// 5</span><br><span class="hljs-keyword">var</span> origin Point<br>fmt.Println(distanceFromP(origin)) <span class="hljs-comment">// 2.23606797749979 sqrt(5)</span><br><br>scaleP := p.ScaleBy<br>scaleP(<span class="hljs-number">2</span>)  <span class="hljs-comment">// &#123;2,4&#125;</span><br>scaleP(<span class="hljs-number">3</span>)  <span class="hljs-comment">// &#123;6,12&#125;</span><br>scaleP(<span class="hljs-number">10</span>) <span class="hljs-comment">// &#123;60,120&#125;</span><br></code></pre></td></tr></table></figure><h1 id="方法值当参数"><a href="#方法值当参数" class="headerlink" title="方法值当参数"></a>方法值当参数</h1><p>当一个函数或方法需要方法值当做参数时，使用方法值当做参数，则非常便利。<br>如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Rocket <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Rocket)</span></span> Launch() &#123; <span class="hljs-comment">/* ... */</span> &#125;<br>r := <span class="hljs-built_in">new</span>(Rocket)<br>time.AfterFunc(<span class="hljs-number">10</span>*time.Second, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>r.Launch()<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用方法值传参则更加简明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">time.AfterFunc(<span class="hljs-number">10</span>*time.Second, r.Launch)<br></code></pre></td></tr></table></figure><p>即将匿名函数改成方法值。</p><h1 id="类型的方法值"><a href="#类型的方法值" class="headerlink" title="类型的方法值"></a>类型的方法值</h1><p>和方法”值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器(p.Distance)语法来指定方法的接收器。<br>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数”值”，这种函数会将其第一个参数用作接收器，所以可以用通常(译注：不写选择器)的方式来对其进行调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>distance := Point.Distance   <span class="hljs-comment">// method expression</span><br>fmt.Println(distance(p, q))  <span class="hljs-comment">// 5</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, distance) <span class="hljs-comment">// func(main.Point, main.Point) float64</span><br><br>scale := (*Point).ScaleBy<br>scale(&amp;p, <span class="hljs-number">2</span>)<br>fmt.Println(p)            <span class="hljs-comment">// &#123;2 4&#125;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, scale) <span class="hljs-comment">// func(*main.Point, float64)</span><br></code></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> point<br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Add(q Point) Point &#123;<br><span class="hljs-keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Sub(q Point) Point &#123;<br><span class="hljs-keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125;<br>&#125;<br><br><span class="hljs-keyword">type</span> Path []Point<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span></span> TranslateBy(offset Point, add <span class="hljs-type">bool</span>) &#123;<br><span class="hljs-keyword">var</span> op <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p, q Point)</span></span> Point<br><span class="hljs-keyword">if</span> add &#123;<br>op = Point.Add<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>op = Point.Sub<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<br>path[i] = op(path[i], offset)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.3. 通过嵌入结构体来扩展类型</title>
      <link href="/posts/3d2bce45dc58/"/>
      <url>/posts/3d2bce45dc58/</url>
      
        <content type="html"><![CDATA[<h1 id="内嵌结构体"><a href="#内嵌结构体" class="headerlink" title="内嵌结构体"></a>内嵌结构体</h1><p>下面是一个ColoredPoint的嵌入结构体，</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br>Point<br>color color.RGBA<br>&#125;<br></code></pre></td></tr></table></figure><p>由结构体特性可知，内嵌可使得ColoredPoint包含Point的所有字段，并附加自身的一些字段。即可以直接访问Point的字段，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> cp ColoredPoint<br>cp.X = <span class="hljs-number">1</span><br>fmt.Println(cp.Point.X) <span class="hljs-comment">// 1</span><br>cp.Point.Y = <span class="hljs-number">2</span><br>fmt.Println(cp.Y) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>类似的，ColoredPoint也可以直接访问Point的方法，即使ColoredPoint未声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br>blue := color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;<br><span class="hljs-keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;<br><span class="hljs-keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;<br>fmt.Println(p.Distance(q.Point)) <span class="hljs-comment">// 5</span><br>p.ScaleBy(<span class="hljs-number">2</span>)<br>q.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p.Distance(q.Point)) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>使用此特性，可以定义字段多的复杂类型，然后把字段按照类型进行分组，定义小类型的方法，再组合起来。</p><p>同比其它编程语言，可将Point当做一个基类，ColoredPoint看作Point的子类或继承类，或者把ColoredPoint看作Point类。但是在Go语言中，这种理解是有误差的。如上例子中，<code>p.Distance(q.Point)</code>，如果q看作Point类，那么可以写成<code>p.Distance(q)</code>，但运行时，发现<code>“compile error: cannot use q (ColoredPoint) as Point</code>的错误。可知，ColoredPoint并非Point类，只是包含Point这个嵌入类型。</p><p>ColoredPoint并不是Point，但是拥有一个内嵌的Point，并且有由Point类引入的<code>Distance</code>和<code>ScaleBy</code>。<br>其实在编译过程中，内嵌字段会使得编译器去生成额外的包装方法来委托已经声明好的方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p ColoredPoint)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> p.Point.Distance(q)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p ColoredPoint)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>p.Point.ScaleBy(factor)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="指针匿名字段"><a href="#指针匿名字段" class="headerlink" title="指针匿名字段"></a>指针匿名字段</h1><p>在结构体类型中，内嵌的匿名字段也可能是一个命名类型的指针。<br>这种情况下，字段和方法会被简接引入到当前的类型中，但需要使用指针指向的对象去访问。<br>下面的<code>ColoredPoint</code>类内嵌了一个<code>*Point</code>的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br>*Point<br>Color color.RGBA<br>&#125;<br><br>red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;<br>blue := color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;<br>p := ColoredPoint&#123;&amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;<br>q := ColoredPoint&#123;&amp;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;<br>fmt.Println(p.Distance(*q.Point))<br>q.Point = p.Point <span class="hljs-comment">// q and p now share the same Point.</span><br><br>p.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(*p.Point, *q.Point) <span class="hljs-comment">// &#123;2,2&#125; &#123;2,2&#125;</span><br></code></pre></td></tr></table></figure><p>指针类型可以使得共享同一个对象，如q.Point和p.Point共享{2,2}。</p><h1 id="匿名字段"><a href="#匿名字段" class="headerlink" title="匿名字段"></a>匿名字段</h1><p>struct类型也可以拥有多个匿名字段，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;<br>Point<br>color.RGBA<br>&#125;<br></code></pre></td></tr></table></figure><p>如上类型的对象包含Point和color.RGBA类型的方法，以及直接定义在ColoredPoint中的方法。<br>当编译器解析一个选择器的方法时，如<code>p.ScaleBy</code>，编译器首先会去找直接在这个类ColorPoint中定义的方法，然后再去找ColoredPoint的内嵌字段引入的方法，接着就再去找Point和color.RGBA的内嵌字段引入的方法，然后再一直递归向下找。<br>如果存在二义性，即同一级内存在两个或以上的同名方法，编译器就会报错。</p><p>方法只能在命名类型(像Point)或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。<br>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量(§9.2)和它所操作的cache：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>mu      sync.Mutex<br>mapping = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>mu.Lock()<br>v := mapping[key]<br>mu.Unlock()<br><span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>下面版本是将字段整合到struct中，将方法引入到新的对象中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>mapping <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span><br>&#125;&#123;<br>mapping: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>),<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>cache.Lock()<br>v := cache.mapping[key]<br>cache.Unlock()<br><span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例子，因为sync.Mutex被引入到cache中，那么Lock和Unlock方法也被引入到cache的结构体中。使得，加锁解锁的操作更加简明。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.2. 基于指针对象的方法</title>
      <link href="/posts/8633284a6bad/"/>
      <url>/posts/8633284a6bad/</url>
      
        <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>当调用一个函数时，会对每一个参数值进行拷贝。<br>如果函数的需要更新一个变量，或函数中的某个参数过于大，则希望避免进行默认的拷贝，这种情况可以用到指针。<br>相对应到方法接受器，当接受者过于大，也可以使用指针而非接受者对象本身来声明方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span></span> ScaleBy(factor <span class="hljs-type">float64</span>) &#123;<br>    p.X *= factor<br>    p.Y *= factor<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的方法名为：<code>(*Point).ScaleBy</code>，这里的括号是不能省略的。</p><p>一般情况下，当某类拥有一个指针作为接收器的方法，那么该类的所有方法也应以指针作为接收器，即使是哪些不需要指针接收器的函数。</p><p>此外，为了避免歧义，在声明方法时，<code>如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的</code>，比如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p P)</span></span> f()  &#123; &#125; <span class="hljs-comment">// Invalid receiver type &#x27;P&#x27; (&#x27;P&#x27; is a pointer type)</span><br></code></pre></td></tr></table></figure><h1 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h1><p>调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可，像下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">r := &amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>r.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(*r) <span class="hljs-comment">// &quot;&#123;2, 4&#125;”</span><br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>pptr := &amp;p<br>pptr.ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p) <span class="hljs-comment">// &quot;&#123;2, 4&#125;”</span><br></code></pre></td></tr></table></figure><p>再或者</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>(&amp;p).ScaleBy(<span class="hljs-number">2</span>)<br>fmt.Println(p) <span class="hljs-comment">// &quot;&#123;2, 4&#125;”</span><br></code></pre></td></tr></table></figure><p>上述方法看起来比较笨拙，在Go语言中，如果接收器p是指针类型的，那么可以直接调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>编译器会隐式用<code>&amp;p</code>去调用<code>ScaleBy</code>，这种简写仅适用于<code>变量</code>。“包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// compile error: can&#x27;t take address of Point literal</span><br></code></pre></td></tr></table></figure><p>同理，当<code>*p</code>取值时，调用其方法，编译器会隐式插入<code>*</code>，则可以进行简写。<br>如下例子中，两种写法是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">pptr.Distance(q)<br>(*pptr).Distance(q)<br></code></pre></td></tr></table></figure><p>在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：<br>1、接收器的实际参数和其接收器的形式参数相同，比如两者都是类型<code>T</code>或者都是类型<code>*T</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.Distance(q) <span class="hljs-comment">//  Point</span><br>pptr.ScaleBy(<span class="hljs-number">2</span>)         <span class="hljs-comment">// *Point</span><br></code></pre></td></tr></table></figure><p>2 、接收器形参是类型T，但接收器实参是类型<code>*T</code>，这种情况下编译器会隐式地为我们取变量的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// implicit (&amp;p)</span><br></code></pre></td></tr></table></figure><p>3、接收器形参是类型<code>*T</code>，实参是类型<code>T</code>。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pptr.Distance(q) <span class="hljs-comment">// implicit (*pptr)</span><br></code></pre></td></tr></table></figure><p>在声明方法的receiver该是指针类型或非指针类型时，需要考虑2个方面。<br>第一个方面是，该对象占用内存是不是特别大，如果声明为非指针类型，调用时会产生一次拷贝，考虑其耗能问题。<br>第二方面是，如果是用指针类型为receiver的类型时，要注意的是，指针指向的是内存空间，就算进行拷贝，也是指向同一块内存空间，要注意拷贝后的修改会改变原变量的值。</p><h1 id="6-2-1-Nil也是一个合法的接收器类型"><a href="#6-2-1-Nil也是一个合法的接收器类型" class="headerlink" title="6.2.1. Nil也是一个合法的接收器类型"></a>6.2.1. Nil也是一个合法的接收器类型</h1><p>一些函数允许其参数为nil，相同的，也可以使用nil当做其接收器。<br>尤其对于对象而已，nil为合法的零值，如map或slice。<br>在下面的简单int链表的例子里，nil代表的是空链表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> intlist<br><br><span class="hljs-comment">// An IntList is a linked list of integers.</span><br><span class="hljs-comment">// A nil *IntList represents an empty list.</span><br><span class="hljs-keyword">type</span> IntList <span class="hljs-keyword">struct</span> &#123;<br>Value <span class="hljs-type">int</span><br>Tail  *IntList<br>&#125;<br><br><span class="hljs-comment">// Sum returns the sum of the list elements.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *IntList)</span></span> Sum() <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> list == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><span class="hljs-keyword">return</span> list.Value + list.Tail.Sum()<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> urlvalues<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/url&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>m := url.Values&#123;<span class="hljs-string">&quot;len&quot;</span>: &#123;<span class="hljs-string">&quot;en&quot;</span>&#125;&#125;<br>m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br><br>fmt.Println(m.Get(<span class="hljs-string">&quot;lang&quot;</span>)) <span class="hljs-comment">// &quot;en&quot;</span><br>fmt.Println(m.Get(<span class="hljs-string">&quot;q&quot;</span>))    <span class="hljs-comment">// &quot;&quot;</span><br>fmt.Println(m.Get(<span class="hljs-string">&quot;item&quot;</span>)) <span class="hljs-comment">// &quot;1&quot;      (first value)</span><br>fmt.Println(m[<span class="hljs-string">&quot;item&quot;</span>])     <span class="hljs-comment">// &quot;[1 2]&quot;  (direct map access)</span><br><br>m = <span class="hljs-literal">nil</span><br>fmt.Println(m.Get(<span class="hljs-string">&quot;item&quot;</span>)) <span class="hljs-comment">// &quot;&quot;</span><br>m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)         <span class="hljs-comment">// panic: assignment to entry in nil map</span><br>&#125;<br></code></pre></td></tr></table></figure><p>最后一次调用m，m为nil，等价于<code>Value(nil).Get(&quot;item&quot;)</code>。如果写为<code>nil.Get(&quot;item&quot;)</code>，则无法通过编译，因为编译器无法判断其准备类型。<br>而在<code>m.Add(&quot;item&quot;,&quot;3&quot;)</code>中，因为m为nil，则出抛出panic异常，因为试图更新一个nil的map。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>6.1. 方法声明</title>
      <link href="/posts/627a83e633ba/"/>
      <url>/posts/627a83e633ba/</url>
      
        <content type="html"><![CDATA[<p>在函数声明前加上一个变量，就是方法。<br>第一个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> geometry<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// traditional function</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br><br><span class="hljs-comment">// same thing, but as a method of the Point type</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span></span> Distance(q Point) <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)<br>&#125;<br></code></pre></td></tr></table></figure><p>方法前的参数p，被称为函数接收器（receiver），通常使用类型的首字母。</p><p>方法调用时，直接使用该变量点语法连接方法名即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;<br>fmt.Println(Distance(p, q))<br>fmt.Println(p.Distance(q))<br></code></pre></td></tr></table></figure><p>因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A Path is a journey connecting the points with straight lines.</span><br><span class="hljs-keyword">type</span> Path []Point<br><br><span class="hljs-comment">// Distance returns the distance traveled along the path.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span></span> Distance() <span class="hljs-type">float64</span> &#123;<br>sum := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>sum += path[i<span class="hljs-number">-1</span>].Distance(path[i])<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure><p>Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。<br>在Go中，能够给任意类型定义方法。<br>下面例子是计算三角形的周长。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">perim := Path&#123;<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-number">4</span>,<span class="hljs-number">2</span>&#125;,<br>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">1</span>&#125;,<br>&#125;<br>fmt.Println(perim.Distance())<br></code></pre></td></tr></table></figure><p>在包外，使用方法比通过包调用方法要简短些。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">perim := geometry.Path&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;<br>fmt.Println(geometry.PathDistance(perim))<br>fmt.Println(perim.Distance())<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 方法</title>
      <link href="/posts/b376389fd346/"/>
      <url>/posts/b376389fd346/</url>
      
        <content type="html"><![CDATA[<p><a href="/posts/627a83e633ba/">6.1. 方法声明</a></p><p><a href="/posts/8633284a6bad/">6.2. 基于指针对象的方法</a></p><p><a href="">6.3. 通过嵌入式结构体来扩展类型</a></p><p><a href="/posts/4fa1929ae9d9/">6.4. 方法值和方法表达式</a></p><p><a href="/posts/aaab166a7bb7/">6.5. 示例：Bit数组</a></p><p><a href="/posts/387bb90cfe97/">6.6. 封装</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.9. Panic异常</title>
      <link href="/posts/b0cbde1e1f43/"/>
      <url>/posts/b0cbde1e1f43/</url>
      
        <content type="html"><![CDATA[<p>一般而言，当<code>panic</code>异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数(<code>defer</code>机制)，随后，程序崩溃并输出日志信息。<br>日志信息包括<code>panic value</code>和函数调用的堆栈跟踪信息。<br>不是所有的<code>panic</code>异常都来自运行时，直接调用内置的<code>panic</code>函数也会引起<code>panic</code>异常。<br>panic函数可接受任何值作为参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> s := suit(drawCard()); s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Spades&quot;</span>:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Hearts&quot;</span>:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Diamonds&quot;</span>:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Clubs&quot;</span>:<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;invalid suit %q&quot;</span>, s))<br>&#125;<br></code></pre></td></tr></table></figure><p>运行<code>panic</code>函数的前提是满足前置条件，但切勿滥用。<br>除非提供更多的错误信息，或更快的发现错误，否则不需要<code>panic</code>，编译器在运行时会检查代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reset</span><span class="hljs-params">(x *Buffer)</span></span> &#123;<br><span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;x is nil&quot;</span>)<br>&#125;<br>x.elements = <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><h2 id="regexp-Compile函数"><a href="#regexp-Compile函数" class="headerlink" title="regexp.Compile函数"></a>regexp.Compile函数</h2><p><code>regexp.Compile</code>函数将正则表达式编译成有效的可匹配格式。当输入的正则表达式不合法时，该函数会返回一个错误。当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。<br>在程序源码中，大多数正则表达式是字符串字面值（<code>string literals</code>），因此<code>regexp</code>包提供了包装函数<code>regexp.MustCompile</code>检查输入的合法性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> regexp<br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MustCompile</span><span class="hljs-params">(str <span class="hljs-type">string</span>)</span></span> *Regexp &#123;<br>regexp, err := Compile(str)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">`regexp: Compile(`</span> + quote(str) + <span class="hljs-string">`): `</span> + err.Error())<br>&#125;<br><span class="hljs-keyword">return</span> regexp<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，<code>MustCompile</code>不能接收不合法的输入。<br>函数名中的<code>Must</code>前缀是一种针对此类函数的命名。</p><h2 id="panic信息和堆栈信息"><a href="#panic信息和堆栈信息" class="headerlink" title="panic信息和堆栈信息"></a>panic信息和堆栈信息</h2><p>在下面的例子，会输出其程序崩溃的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;f(%d)\n&quot;</span>, x+<span class="hljs-number">0</span>/x)<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;defer %d\n&quot;</span>, x)<br>f(x - <span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序运行后输出的内容如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">f(<span class="hljs-number">3</span>)<br>f(<span class="hljs-number">2</span>)<br>f(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">defer</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>当<code>f(0)</code>执行到<code>x+0/x</code>时，触发panic异常，之前被延迟执行的3个<code>fmt.Printf</code>被调用。程序中断执行后，panic信息和堆栈信息会被输出（下面是简化的输出）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">panic</span>: runtime <span class="hljs-type">error</span>: integer divide by zero<br><br>goroutine <span class="hljs-number">1</span> [running]:<br>main.f(<span class="hljs-number">0x0</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ex/demo.<span class="hljs-keyword">go</span>:<span class="hljs-number">26</span> +<span class="hljs-number">0x1e6</span><br>main.f(<span class="hljs-number">0x1</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ex/demo.<span class="hljs-keyword">go</span>:<span class="hljs-number">28</span> +<span class="hljs-number">0x1b6</span><br>main.f(<span class="hljs-number">0x2</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ex/demo.<span class="hljs-keyword">go</span>:<span class="hljs-number">28</span> +<span class="hljs-number">0x1b6</span><br>main.f(<span class="hljs-number">0x3</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ex/demo.<span class="hljs-keyword">go</span>:<span class="hljs-number">28</span> +<span class="hljs-number">0x1b6</span><br>main.main()<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ex/demo.<span class="hljs-keyword">go</span>:<span class="hljs-number">22</span> +<span class="hljs-number">0x1e</span><br>Exiting.<br></code></pre></td></tr></table></figure><h2 id="手动输出堆栈信息"><a href="#手动输出堆栈信息" class="headerlink" title="手动输出堆栈信息"></a>手动输出堆栈信息</h2><p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> printStack()<br>f(<span class="hljs-number">3</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">4096</span>]<span class="hljs-type">byte</span><br>n := runtime.Stack(buf[:], <span class="hljs-literal">false</span>)<br>os.Stdout.Write(buf[:n])<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;f(%d)\n&quot;</span>, x+<span class="hljs-number">0</span>/x)<br><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;defer %d\n&quot;</span>, x)<br>f(x - <span class="hljs-number">1</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>printStack的简化输出如下（下面只是printStack的输出，不包括panic的日志信息）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">goroutine <span class="hljs-number">1</span> [running]:<br>main.printStack()<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">16</span> +<span class="hljs-number">0x39</span><br><span class="hljs-built_in">panic</span>(&#123;<span class="hljs-number">0x10995c0</span>, <span class="hljs-number">0x1139180</span>&#125;)<br>        /usr/local/<span class="hljs-keyword">go</span>/src/runtime/<span class="hljs-built_in">panic</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">884</span> +<span class="hljs-number">0x212</span><br>main.f(<span class="hljs-number">0x10c7da8</span>?)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">21</span> +<span class="hljs-number">0x113</span><br>main.f(<span class="hljs-number">0x1</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span> +<span class="hljs-number">0xf5</span><br>main.f(<span class="hljs-number">0x2</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span> +<span class="hljs-number">0xf5</span><br>main.f(<span class="hljs-number">0x3</span>)<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">23</span> +<span class="hljs-number">0xf5</span><br>main.main()<br>        /Users/huangfuwang/Desktop/Code/Go/<span class="hljs-keyword">go</span>-learn-gopl/ch/ch5/defer2/<span class="hljs-keyword">defer</span>.<span class="hljs-keyword">go</span>:<span class="hljs-number">11</span> +<span class="hljs-number">0x45</span><br></code></pre></td></tr></table></figure><p><code>runtime.Stack</code>为何能输出已经被释放函数的信息？<br>得益于Go的defer机制，defer函数在释放堆栈信息之前执行。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.8. Deferred函数</title>
      <link href="/posts/6f685641f7fc/"/>
      <url>/posts/6f685641f7fc/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>在普通函数前加上关键字<code>defer</code>时，当<code>defer</code>语句被执行时，其后面的函数会被延迟执行。<br>直到包含该<code>defer</code>语句的函数执行完毕时，<code>defer</code>后的函数才会被执行，无论是包含<code>defer</code>的函数通过<code>return</code>正常结束或由于<code>panic</code>导致的异常结束。<br>一个函数中可以执行多条<code>defer</code>语句，它们的执行顺序与声明的顺序相反。</p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><p><code>defer</code>语句常用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。<br>通过<code>defer</code>机制，无论函数逻辑多复杂，都能保证在任何执行路径下，资源能被释放。<br>释放资源的<code>defer</code>语句应该直接跟着请求资源的语句后。</p><h2 id="关闭网络连接"><a href="#关闭网络连接" class="headerlink" title="关闭网络连接"></a>关闭网络连接</h2><p>下面例子获取HTML页面并输出页面的标题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> err := title(arg); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;title: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">title</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>ct := resp.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br><span class="hljs-keyword">if</span> ct != <span class="hljs-string">&quot;text/html&quot;</span> &amp;&amp; !strings.HasPrefix(ct, <span class="hljs-string">&quot;text/html&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s has type %s, not text/html&quot;</span>, url, ct)<br>&#125;<br><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)<br>&#125;<br><br>visitNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;title&quot;</span> &amp;&amp; n.FirstChild != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;title:%s&quot;</span>, n.Data)<br>&#125;<br>&#125;<br><br>foreachNode(doc, visitNode, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>foreachNode(c, pre, post)<br>&#125;<br><br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是代码的运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./title1 http://gopl.io</span><br>The Go Programming Language<br>./title1 https://inews.gtimg.com/news_ls/OExtuAtUKTNazpSOqxmuLgKRPO6wJk6nwVNAfixgCGtOAAA_640330/0<br>title: https://inews.gtimg.com/news_ls/OExtuAtUKTNazpSOqxmuLgKRPO6wJk6nwVNAfixgCGtOAAA_640330/0 has type image/jpeg, not text/html<br></code></pre></td></tr></table></figure><h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><p>如<code>io.util</code>包中，读取文件<code>ReadFile</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-keyword">return</span> ReadAll(f)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="处理互斥锁"><a href="#处理互斥锁" class="headerlink" title="处理互斥锁"></a>处理互斥锁</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookup</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>mu.Lock()<br><span class="hljs-keyword">defer</span> mu.Unlock()<br><span class="hljs-keyword">return</span> m[key]<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="记录函数运行时间"><a href="#记录函数运行时间" class="headerlink" title="记录函数运行时间"></a>记录函数运行时间</h2><p>在调试复杂程序时，<code>defer</code>机制也可用于记录何时进入和退出函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>bigSlowOperation()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bigSlowOperation</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> trace(<span class="hljs-string">&quot;bigSlowOperation&quot;</span>)()<br><span class="hljs-comment">// lots of work</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br><span class="hljs-comment">// operation by sleeping</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(msg <span class="hljs-type">string</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>log.Printf(<span class="hljs-string">&quot;enter %s&quot;</span>, msg)<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>log.Printf(<span class="hljs-string">&quot;exit %s (%s)&quot;</span>, msg, time.Since(start))<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>需要注意的是，不要漏掉<code>defer</code>语句后的圆括号，即调用<code>trace</code>返回的函数，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远执行不了。<br>下面是例子的运行结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">2023</span>/<span class="hljs-number">06</span>/<span class="hljs-number">11</span> <span class="hljs-number">04</span>:<span class="hljs-number">07</span>:<span class="hljs-number">48</span> enter bigSlowOperation<br><span class="hljs-number">2023</span>/<span class="hljs-number">06</span>/<span class="hljs-number">11</span> <span class="hljs-number">04</span>:<span class="hljs-number">07</span>:<span class="hljs-number">58</span> exit bigSlowOperation (<span class="hljs-number">10.001382207</span>s)<br></code></pre></td></tr></table></figure><h2 id="使用匿名函数观察返回值"><a href="#使用匿名函数观察返回值" class="headerlink" title="使用匿名函数观察返回值"></a>使用匿名函数观察返回值</h2><p><code>defer</code>语句中的函数会在<code>return</code>语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用<code>defer</code>机制，可以使其观察函数的返回值。<br>如下函数<code>double</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> x + x<br>&#125;<br></code></pre></td></tr></table></figure><p>只需要命名<code>double</code>函数的返回值，再增加<code>defer</code>语句，就可以在<code>double</code>每次被调用时，输出参数以及返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;double(%d) = %d\n&quot;</span>, x, result)<br>&#125;()<br><span class="hljs-keyword">return</span> x + x<br>&#125;<br><br>double(<span class="hljs-number">2</span>) <span class="hljs-comment">// double(2) = 4</span><br></code></pre></td></tr></table></figure><p>另外一个小技巧，被延迟执行的匿名函数甚至可以修改函数返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">triple</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> (result <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>result += x<br>&#125;()<br><span class="hljs-keyword">return</span> double(x)<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;triple(%d) = %d\n&quot;</span>, <span class="hljs-number">2</span>, triple(<span class="hljs-number">2</span>)) <span class="hljs-comment">// triple(2) = 6</span><br></code></pre></td></tr></table></figure><h2 id="注意循环体中的defer机制"><a href="#注意循环体中的defer机制" class="headerlink" title="注意循环体中的defer机制"></a>注意循环体中的defer机制</h2><p>在循环体中的<code>defer</code>语句要特别注意，因为只有函数执行完毕后，被延迟的函数才会执行。<br>下面的代码导致系统的文件并没有关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeFiles</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span>  &#123;<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> filenames &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> f.Close() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> could run out of file</span><br><span class="hljs-comment">// ...process f...</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解决方法是将循环体中的<code>defer</code>语句移到另外一个函数。每次循环时，调用该函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">closeFiles</span><span class="hljs-params">(filenames []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> filenames &#123;<br><span class="hljs-keyword">if</span> err := doFile(filename); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>f, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><span class="hljs-comment">// ...process f...</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="传递函数反馈信息"><a href="#传递函数反馈信息" class="headerlink" title="传递函数反馈信息"></a>传递函数反馈信息</h2><p>下面代码是<code>fetch</code>的改进版，将http响应信息写入本地文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> fetch<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path&quot;</span><br>)<br><br><span class="hljs-comment">// Fetch downloads the URL and returns the name and length of the local file.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (filename <span class="hljs-type">string</span>, n <span class="hljs-type">int64</span>, err <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>local := path.Base(resp.Request.URL.Path)<br><span class="hljs-keyword">if</span> local == <span class="hljs-string">&quot;/&quot;</span> &#123;<br>local = <span class="hljs-string">&quot;index.html&quot;</span><br>&#125;<br><br>f, err := os.Create(local)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err<br>&#125;<br>n, err = io.Copy(f, resp.Body)<br><span class="hljs-keyword">if</span> closeErr := f.Close(); err == <span class="hljs-literal">nil</span> &#123;<br>err = closeErr<br>&#125;<br><span class="hljs-keyword">return</span> local, n, err<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子使用<code>defer</code>机制对<code>resp.Body.Close</code>进行延迟调用。<br>但未对<code>f.Close()</code>进行延迟调用，原因是会产生一些微妙的错误。<br>当写入文件时发生的错误被延迟到文件关闭时反馈，如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。<br>如果<code>io.Copy</code>和<code>f.close</code>都失败了，我们倾向于将<code>io.Copy</code>的错误信息反馈给调用者，因为它先于<code>f.close</code>发生，更有可能接近问题的本质。</p><h1 id="defer、return和返回值"><a href="#defer、return和返回值" class="headerlink" title="defer、return和返回值"></a>defer、return和返回值</h1><p><code>defer</code>、<code>return</code>和返回值的执行顺序如何呢？<br>其实呢，在一般情况下，即<code>defer</code>写于<code>return</code>前（为什么要强调呢，后面再议），<code>return</code>语句非原子性，<code>return</code>先给返回值赋值；接着<code>defer</code>语句开始执行；最后执行<code>RET</code>指令携带返回值返回函数。<br>那么问题来了，<code>defer</code>可以修改返回值么？<br>下面几个例子足以说明：</p><ol><li><code>defer</code>不能修改匿名返回值 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i = <span class="hljs-number">10</span><br>&#125;()<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> i<br>&#125;<br>fmt.Println(testDefer()) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure> <code>i</code>初始化为0，然后赋值1，<code>defer</code>语句中i&#x3D;10，结果返回值为1，显然<code>defer</code>语句无法修改匿名返回值。</li><li><code>defer</code>可以修改非匿名返回值 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">testDefer</span><span class="hljs-params">()</span></span> (i <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>i = <span class="hljs-number">10</span><br>&#125;()<br>i = <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> i<br>&#125;<br>fmt.Println(testDefer()) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure> <code>return</code>语句返回的是1，<code>defer</code>语句修改返回值i&#x3D;10，结果返回值为10，显然<code>defer</code>语句是可以修改非匿名返回值。</li></ol><h1 id="defer和return的书写顺序"><a href="#defer和return的书写顺序" class="headerlink" title="defer和return的书写顺序"></a>defer和return的书写顺序</h1><p>先看个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun2</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> (i <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i = <span class="hljs-number">10</span> &#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子，当参数n&#x3D;0时，返回值是多少呢？<br>第一反应是应该是10吧，非也，返回值为1。<br>那就奇了怪了，根据<code>defer</code>、<code>return</code>和<code>返回值</code>的执行顺序，<code>defer</code>语句应该修改了<code>return</code>修改后的命名返回值i为10。<br>个人理解啊，虽然有<code>defer</code>语句存在，但是函数根本没运行到<code>defer</code>语句，在之前就之前返回了，所以就没被修改到。<br>并没有找到官方的有关文档，纯属个人猜测。</p><p>所以在设计函数时，要注意<code>defer</code>语句和<code>return</code>语句的书写顺序，如在协程关闭另外一个协程时。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>&lt;-sema<br>&#125;() <span class="hljs-comment">// release token</span><br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="hljs-comment">// acquire token</span><br><span class="hljs-keyword">case</span> &lt;-done:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>sema channel</code>在容量满时，同时也没接收到<code>done channel</code>的信息时，<code>select</code>进行堵塞，等待释放资源， 一旦此时<code>done channel</code>接收到值时，<code>return</code>语句执行了，再执行<code>defer</code>语句，导致<code>sema channel</code>一直在堵塞。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习5.18：</strong> 不修改fetch的行为，重写fetch函数，要求使用defer机制关闭文件。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (filename <span class="hljs-type">string</span>, n <span class="hljs-type">int64</span>, err <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>local := path.Base(resp.Request.URL.Path)<br><span class="hljs-keyword">if</span> local == <span class="hljs-string">&quot;/&quot;</span> &#123;<br>local = <span class="hljs-string">&quot;index.html&quot;</span><br>&#125;<br><br>f, err := os.Create(local)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>closeErr := f.Close()<br><span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>err = closeErr<br>&#125;<br>&#125;()<br><br>n, err = io.Copy(f, resp.Body)<br><span class="hljs-keyword">return</span> local, n, err<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>f, n, err := fetch(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch: %serror: %v\n&quot;</span>, arg, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch: %sfilename: %s  count: %d\n&quot;</span>, arg, f, n)<br>&#125;<br>&#125;<br> <br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.7. 可变参数</title>
      <link href="/posts/f16f86776a10/"/>
      <url>/posts/f16f86776a10/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>参数数量可变的函数称为<code>可变参数函数</code>。<br>如<code>fmt.Printf</code>和类似参数。</p><p> 在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号<code>...</code>，表示该函数会接受任何数量的该类型参数。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>  &#123;<br>total := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;<br>total += val<br>&#125;<br><span class="hljs-keyword">return</span> total<br>&#125;<br></code></pre></td></tr></table></figure><p> sum函数返回任意个int类型参数的和。<br> 在函数体中，vals被看作是类型为[]int的切片。<br> sum可以接受任意数量的int类型参数。<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(sum())                              <span class="hljs-comment">// 0</span><br>fmt.Println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>)) <span class="hljs-comment">// 55</span><br>fmt.Println(sum(<span class="hljs-number">1</span>))                             <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure></p><h1 id="切片写法"><a href="#切片写法" class="headerlink" title="切片写法"></a>切片写法</h1><p> 在上面的例子中，调用者隐式地创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。<br> 如原始参数已经是切片类型，该如何传递给sum?<br> <code>在最后一个参数后加上省略符号...</code><br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">values := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>fmt.Println(sum(values...)) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><br> 直接写入参数和传递切片加省略号的方式效果相同。</p><p> 虽然在可变参数函数内部，…int类型参数的行为很像切片类型，但实际上，可变参数函数和以切片作为参数的函数的类型是不同的。<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(...<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">([]<span class="hljs-type">int</span>)</span></span> &#123;&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// func(...int)</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, g) <span class="hljs-comment">// func([]int)</span><br></code></pre></td></tr></table></figure></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p> <code>可变参数函数常用于格式化字符串。</code><br> 下面的errorf函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorf</span><span class="hljs-params">(linenum <span class="hljs-type">int</span>, format <span class="hljs-type">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Line %d: &quot;</span>, linenum)<br>fmt.Fprintf(os.Stderr, format, args...)<br>fmt.Fprintln(os.Stderr)<br>&#125;<br>linenum, name := <span class="hljs-number">12</span>, <span class="hljs-string">&quot;count&quot;</span><br>errorf(linenum, <span class="hljs-string">&quot;undefined: %s&quot;</span>, name) <span class="hljs-comment">// Line 12: undefined: count</span><br></code></pre></td></tr></table></figure></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p> <strong>练习5.15：</strong> 编写类似sum的可变参数函数max和min。考虑不传参时，max和min该如何处理，再编写至少接收1个参数的版本。<br> 解：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>fmt.Println(max(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 5 &lt;nil&gt;</span><br>fmt.Println(min(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>)) <span class="hljs-comment">// 1 &lt;nil&gt;</span><br>fmt.Println(max())              <span class="hljs-comment">// 0 vals can not be nill or empty! []</span><br>fmt.Println(min())              <span class="hljs-comment">// 0 vals can not be nill or empty! []</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">max</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> vals == <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(vals) == <span class="hljs-number">0</span> &#123;<br>err := fmt.Errorf(<span class="hljs-string">&quot;vals can not be nill or empty! %v&quot;</span>, vals)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>&#125;<br><br>m := vals[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(vals); i++ &#123;<br><span class="hljs-keyword">if</span> m &lt; vals[i] &#123;<br>m = vals[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> m, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">min</span><span class="hljs-params">(vals ...<span class="hljs-type">int</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> vals == <span class="hljs-literal">nil</span> || <span class="hljs-built_in">len</span>(vals) == <span class="hljs-number">0</span> &#123;<br>err := fmt.Errorf(<span class="hljs-string">&quot;vals can not be nill or empty! %v&quot;</span>, vals)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>&#125;<br><br>m := vals[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(vals); i++ &#123;<br><span class="hljs-keyword">if</span> m &gt; vals[i] &#123;<br>m = vals[i]<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> m, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>练习5.16：</strong> 编写多参数版本的strings.Join。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(Join(<span class="hljs-string">&quot;,&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>)) <span class="hljs-comment">// 1,2,3,4,5,6,7,8,9</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(sep <span class="hljs-type">string</span>, elems ...<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> str <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i, elem := <span class="hljs-keyword">range</span> elems &#123;<br><span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(elems)<span class="hljs-number">-1</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><br>tem := elem<br><span class="hljs-keyword">if</span> i != <span class="hljs-number">0</span> &#123;<br>tem = sep + elem<br>&#125;<br>str += tem<br>&#125;<br><span class="hljs-keyword">return</span> str<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习5.17：</strong> 编写多参数版本的ElementsByTagName，函数接收一个HTML结点树以及任意数量的标签名，返回与这些标签名匹配的所有元素。下面给出了2个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsByTagName</span><span class="hljs-params">(doc *html.Node, name...<span class="hljs-type">string</span>)</span></span> []*html.Node<br>images := ElementsByTagName(doc, <span class="hljs-string">&quot;img&quot;</span>)<br>headings := ElementsByTagName(doc, <span class="hljs-string">&quot;h1&quot;</span>, <span class="hljs-string">&quot;h2&quot;</span>, <span class="hljs-string">&quot;h3&quot;</span>, <span class="hljs-string">&quot;h4&quot;</span>)<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>resp, err := http.Get(<span class="hljs-string">&quot;https://www.apple.com.cn&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>nodes := ElementsByTagName(doc, <span class="hljs-string">&quot;img&quot;</span>, <span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-string">&quot;title&quot;</span>)<br><span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> nodes &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v    &quot;</span>, node.Data)<br>fmt.Println(node.Attr)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsByTagName</span><span class="hljs-params">(doc *html.Node, name ...<span class="hljs-type">string</span>)</span></span> []*html.Node &#123;<br><br><span class="hljs-keyword">var</span> nodes []*html.Node<br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> name &#123;<br><span class="hljs-keyword">if</span> doc.Data == s &#123;<br>nodes = <span class="hljs-built_in">append</span>(nodes, doc)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> c := doc.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>nodes = <span class="hljs-built_in">append</span>(nodes, ElementsByTagName(c, name...)...)<br>&#125;<br><br><span class="hljs-keyword">return</span> nodes<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.6. 匿名函数</title>
      <link href="/posts/f29c530bb54f/"/>
      <url>/posts/f29c530bb54f/</url>
      
        <content type="html"><![CDATA[<h1 id="匿名函数的定义"><a href="#匿名函数的定义" class="headerlink" title="匿名函数的定义"></a>匿名函数的定义</h1><p>拥有函数名的函数只能在包级语法块中被声明。<br>可以通过函数字面量（function literal），可以绕过限制，在任何表达式内表示函数值。<br>没有名字的函数，即函数值字面量，被称为匿名函数（anonymous function）。</p><p>函数字面量可以在使用函数时，再定义。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">strings.Map(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">rune</span> &#123;<br><span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span><br>&#125;, <span class="hljs-string">&quot;HAL-9000&quot;</span>)<br></code></pre></td></tr></table></figure><p>匿名函数可以正常访问所在语法块中的变量。例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The squares program demonstrates a function value with state.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">()</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>x++<br><span class="hljs-keyword">return</span> x * x<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := squares()<br>fmt.Println(f()) <span class="hljs-comment">// 1</span><br>fmt.Println(f()) <span class="hljs-comment">// 4</span><br>fmt.Println(f()) <span class="hljs-comment">// 9</span><br>fmt.Println(f()) <span class="hljs-comment">// 16</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数<code>squares</code>返回类型为<code>func()int</code>的函数。<br>调用一次<code>squares</code>函数就会生成一个局部变量<code>x</code>并返回一个匿名函数。<br>每次调用匿名函数，该函数就会先使x的值加1，再返回x的平方。</p><p>函数值记录了函数状态，在squares中定义的匿名函数可以访问和更新squares中的局部变量，即存在变量引用。这也是函数值属于引用类型和函数值不可比较的原因。<br>Go使用闭包（closures）技术实现函数值，也把函数值称为闭包。</p><p>例子中，变量x的生命周期不由x的作用域决定：squares函数返回后，变量x仍然隐式存在于函数值变量f中。</p><p>给定一些计算机课程，每个课程都有前置课程，只有完成了前置课程才可以开始当前课程的学习；我们的目标是选择出一组课程，这组课程必须确保按顺序学习时，能全部被完成。每个课程的前置课程如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The toposort program prints the nodes of a DAG in topological order.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-comment">// prereqs maps computes science courses to their prerequisites.</span><br><span class="hljs-keyword">var</span> prereqs = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;algorithms&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;calculus&quot;</span>:   &#123;<span class="hljs-string">&quot;linear algebra&quot;</span>&#125;,<br><span class="hljs-string">&quot;compilers&quot;</span>: &#123;<br><span class="hljs-string">&quot;data structures&quot;</span>,<br><span class="hljs-string">&quot;format languages&quot;</span>,<br><span class="hljs-string">&quot;computer organization&quot;</span>,<br>&#125;,<br><span class="hljs-string">&quot;data structures&quot;</span>:       &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;databases&quot;</span>:             &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;discrete math&quot;</span>:         &#123;<span class="hljs-string">&quot;intro to programming&quot;</span>&#125;,<br><span class="hljs-string">&quot;format languages&quot;</span>:      &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;networks&quot;</span>:              &#123;<span class="hljs-string">&quot;operating systems&quot;</span>&#125;,<br><span class="hljs-string">&quot;operating systems&quot;</span>:     &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br><span class="hljs-string">&quot;programming languages&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> topoSort(prereqs) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d:\t%s\n&quot;</span>, i+<span class="hljs-number">1</span>, c)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topoSort</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// 声明目标数组</span><br><span class="hljs-keyword">var</span> order []<span class="hljs-type">string</span><br><span class="hljs-comment">// 创建已收录的课程map, key-课程，value-是否出现过</span><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-comment">// 声明匿名函数 搜索图  参数为课程数组</span><br><span class="hljs-keyword">var</span> visitAll <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">([]<span class="hljs-type">string</span>)</span></span><br><br><span class="hljs-comment">// 实现匿名函数</span><br>visitAll = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-comment">// 遍历课程数组</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-comment">// 如果未出现过的课程，进行下一步；如果已出现，忽略</span><br><span class="hljs-keyword">if</span> !seen[item] &#123;<br><span class="hljs-comment">// 进行对课程的标识，以免再次进入</span><br>seen[item] = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 进行对该课程所需的先决条件进行递归</span><br>visitAll(m[item])<br><span class="hljs-comment">// 将课程收录到目标数组中</span><br>order = <span class="hljs-built_in">append</span>(order, item)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获取先决条件中的课程keys</span><br><span class="hljs-keyword">var</span> keys []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, key)<br>&#125;<br><span class="hljs-comment">// 进行对keys课程排序 其实无关紧要 排不排序都不影响课程先决条件的最终走向</span><br><span class="hljs-comment">// 但由于map是无序的，将导致每次运算都可能出现不相同的结果，所以进行排序，使的每次输出一致。</span><br>sort.Strings(keys)<br>visitAll(keys)<br><span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子被称为<code>拓扑排序</code>，即前置条件构成有向图。<br>图中的顶点表示课程，边表示课程间的依赖关系。<br>而且此有向图不存在环，也就是说从某点出发的边，最终不会回到该点。<br>其输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">1:      intro to programming<br>2:      discrete math<br>3:      data structures<br>4:      algorithms<br>5:      linear algebra<br>6:      calculus<br>7:      format languages<br>8:      computer organization<br>9:      compilers<br>10:     databases<br>11:     operating systems<br>12:     networks<br>13:     programming languages<br></code></pre></td></tr></table></figure><p>其关系图如下：<br><img src="/5.6.%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/1683489266098.png" alt="1683489266098"></p><p>让我们回到findLinks这个例子。我们将代码移动到了links包下，将函数重命名为Extract，在第八章我们会再次用到这个函数。新的匿名函数被引入，用于替换原来的visit函数。该匿名函数负责将新连接添加到切片中。在Extract中，使用forEachNode遍历HTML页面，由于Extract只需要在遍历结点前操作结点，所以forEachNode的post参数被传入nil。<br>findlinks.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Findlinks3 crawls the web, starting with the URls on the command line.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// breadthFirst calls f for each item in the worklist.</span><br><span class="hljs-comment">// Any items returned by f are added to the worklist.</span><br><span class="hljs-comment">// f is called at most once for each item.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">breadthFirst</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(item <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span>, worklist []<span class="hljs-type">string</span>) &#123;<br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(worklist) &gt; <span class="hljs-number">0</span> &#123;<br>items := worklist<br>worklist = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> !seen[item] &#123;<br>seen[item] = <span class="hljs-literal">true</span><br>worklist = <span class="hljs-built_in">append</span>(worklist, f(item)...)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>fmt.Println(url)<br>list, err := links.Extract(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// Crawl the web breadth-first.</span><br><span class="hljs-comment">// starting from the command-line arguments.</span><br>breadthFirst(crawl, os.Args[<span class="hljs-number">1</span>:])<br>&#125;<br><br></code></pre></td></tr></table></figure><p>links.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package links provides a link-extraction function.</span><br><span class="hljs-keyword">package</span> links<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-comment">// Extract makes an HTTP GET request to the specified URL,</span><br><span class="hljs-comment">// parses the response as HTML, and returns the links in the HTML document.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Extract</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-comment">// 1.Get请求url</span><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 如果非200状态码 关闭resp.Body并输出错误信息</span><br><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %s&quot;</span>, url, resp.Status)<br>&#125;<br><span class="hljs-comment">// 2.将请求的内容转换成html.Node</span><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-comment">// 关闭resp.Body</span><br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)<br>&#125;<br><br><span class="hljs-comment">// 声明匿名函数visitNode和数组变量links</span><br><span class="hljs-comment">// 匿名函数visitNode用于遍历节点并收集url存储在数组变量links中</span><br><span class="hljs-keyword">var</span> links []<span class="hljs-type">string</span><br>visitNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-comment">// 非href的属性跳过</span><br><span class="hljs-keyword">if</span> a.Key != <span class="hljs-string">&quot;href&quot;</span> &#123;<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-comment">// 校验url是否合法</span><br>link, err := resp.Request.URL.Parse(a.Val)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">continue</span> <span class="hljs-comment">// ignore bad URLs</span><br>&#125;<br>links = <span class="hljs-built_in">append</span>(links, link.String())<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 3.进行遍历图</span><br>forEachNode(doc, visitNode, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">return</span> links, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>forEachNode(c, pre, post)<br>&#125;<br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序输出结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./findlinks.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./findlinks http://go.dev</span><br>http://go.dev<br>https://go.dev/<br>https://go.dev/solutions/case-studies<br>https://go.dev/solutions/use-cases<br>https://go.dev/security/<br>https://go.dev/learn/<br>https://go.dev/doc/effective_go<br>https://go.dev/doc<br>https://pkg.go.dev/std<br>https://go.dev/doc/devel/release<br>https://pkg.go.dev<br>https://go.dev/talks/<br>https://www.meetup.com/pro/<br></code></pre></td></tr></table></figure><p>当爬过所有链接或内存耗尽时，程序才运行结束。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习5.10：</strong> 重写topoSort函数，用map代替切片并移除对key的排序代码。验证结果的正确性（结果不唯一）。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> prereqs = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;algorithms&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;calculus&quot;</span>:   &#123;<span class="hljs-string">&quot;linear algebra&quot;</span>&#125;,<br><br><span class="hljs-string">&quot;compilers&quot;</span>: &#123;<br><span class="hljs-string">&quot;data structures&quot;</span>,<br><span class="hljs-string">&quot;formal languages&quot;</span>,<br><span class="hljs-string">&quot;computer organization&quot;</span>,<br>&#125;,<br><br><span class="hljs-string">&quot;data structures&quot;</span>:       &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;database&quot;</span>:              &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;discrete math&quot;</span>:         &#123;<span class="hljs-string">&quot;intro to programming&quot;</span>&#125;,<br><span class="hljs-string">&quot;formal languages&quot;</span>:      &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;networks&quot;</span>:              &#123;<span class="hljs-string">&quot;operating systems&quot;</span>&#125;,<br><span class="hljs-string">&quot;operating systems&quot;</span>:     &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br><span class="hljs-string">&quot;programming languages&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> topoSort(prereqs) &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d:\t%s\n&quot;</span>, i, c)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topoSort</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)</span></span> <span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span> &#123;<br>order := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>)<br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> visitAll <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span><br><br>visitAll = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> !seen[item] &#123;<br>seen[item] = <span class="hljs-literal">true</span><br>visitAll(m[item])<br>order[<span class="hljs-built_in">len</span>(order)] = item<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> keys []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> m &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, k)<br>&#125;<br>visitAll(keys)<br><span class="hljs-keyword">return</span> order<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习5.11：</strong> 现在线性代数的老师把微积分设为了前置课程。完善topSort，使其能检测有向图中的环。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;sort&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> prereqs = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;algorithms&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;calculus&quot;</span>:   &#123;<span class="hljs-string">&quot;linear algebra&quot;</span>&#125;,<br><br><span class="hljs-string">&quot;compilers&quot;</span>: &#123;<br><span class="hljs-string">&quot;data structures&quot;</span>,<br><span class="hljs-string">&quot;formal languages&quot;</span>,<br><span class="hljs-string">&quot;computer organization&quot;</span>,<br>&#125;,<br><br><span class="hljs-string">&quot;data structures&quot;</span>:       &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;database&quot;</span>:              &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;discrete math&quot;</span>:         &#123;<span class="hljs-string">&quot;intro to programming&quot;</span>&#125;,<br><span class="hljs-string">&quot;formal languages&quot;</span>:      &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;networks&quot;</span>:              &#123;<span class="hljs-string">&quot;operating systems&quot;</span>&#125;,<br><span class="hljs-string">&quot;operating systems&quot;</span>:     &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br><span class="hljs-string">&quot;programming languages&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br><br><span class="hljs-string">&quot;linear algebra&quot;</span>: &#123;<span class="hljs-string">&quot;calculus&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>sorted, err := topoSort(prereqs)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">for</span> i, c := <span class="hljs-keyword">range</span> sorted &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d:\t%s\n&quot;</span>, i+<span class="hljs-number">1</span>, c)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topoSort</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">var</span> order []<span class="hljs-type">string</span><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">var</span> visitAll <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span><br><br>visitAll = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> !seen[item] &#123;<br>seen[item] = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 如果发现有闭环错误，则返回</span><br><span class="hljs-keyword">if</span> err := visitAll(m[item]); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>order = <span class="hljs-built_in">append</span>(order, item)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 是否闭环 默认true</span><br>hasCycle := <span class="hljs-literal">true</span><br><span class="hljs-comment">// 遍历已排好的课程列表，如果order存在item,则说明item对应的前提课程已经递归完毕，不存在闭环</span><br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> order &#123;<br><span class="hljs-keyword">if</span> item == s &#123;<br>hasCycle = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> hasCycle &#123;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;has cycle: %s&quot;</span>, item)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-keyword">var</span> keys []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, key)<br>&#125;<br><br>sort.Strings(keys)<br><br><span class="hljs-keyword">if</span> err := visitAll(keys); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> order, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习5.12：</strong> gopl.io&#x2F;ch5&#x2F;outline2（5.5节）的startElement和endElement共用了全局变量depth，将它们修改为匿名函数，使其共享outline中的局部变量。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>outline(url)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-keyword">var</span> depth <span class="hljs-type">int</span><br><span class="hljs-keyword">var</span> startElement = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>depth++<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot; &quot;</span>, n.Data)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> endElement = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;/%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot; &quot;</span>, n.Data)<br>depth--<br>&#125;<br>&#125;<br><br>foreachNode(doc, startElement, endElement)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foreachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>foreachNode(c, pre, post)<br>&#125;<br><br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习5.13：</strong> 修改crawl，使其能保存发现的页面，必要时，可以创建目录来保存这些页面。只保存来自原始域名下的页面。假设初始页面在golang.org下，就不要保存vimeo.com下的页面。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch5/links&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> base = flag.String(<span class="hljs-string">&quot;base&quot;</span>, <span class="hljs-string">&quot;https://gitee.com/&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> crawl(*base) &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> download(*base, url)<br>&#125;<br><br>done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Wait()<br>done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br><br>&lt;-done<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">download</span><span class="hljs-params">(base, url <span class="hljs-type">string</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><br><span class="hljs-keyword">if</span> !strings.HasPrefix(url, base) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>dir := strings.TrimPrefix(strings.TrimPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>), <span class="hljs-string">&quot;https://&quot;</span>)<br><span class="hljs-keyword">if</span> err := os.MkdirAll(dir, <span class="hljs-number">0755</span>); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><br>filename := dir + <span class="hljs-string">&quot;index.html&quot;</span><br>f, err := os.Create(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br>_, err = io.Copy(f, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span> &#123;<br>list, err := links.Extract(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br><span class="hljs-keyword">return</span> list<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习5.14：</strong> 使用breadthFirst遍历其他数据结构。比如，topoSort例子中的课程依赖关系（有向图）,个人计算机的文件层次结构（树），你所在城市的公交或地铁线路（无向图）。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> prereqs = <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>][]<span class="hljs-type">string</span>&#123;<br><span class="hljs-string">&quot;algorithms&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;calculus&quot;</span>:   &#123;<span class="hljs-string">&quot;linear algebra&quot;</span>&#125;,<br><br><span class="hljs-string">&quot;compilers&quot;</span>: &#123;<br><span class="hljs-string">&quot;data structures&quot;</span>,<br><span class="hljs-string">&quot;formal languages&quot;</span>,<br><span class="hljs-string">&quot;computer organization&quot;</span>,<br>&#125;,<br><br><span class="hljs-string">&quot;data structures&quot;</span>:       &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;database&quot;</span>:              &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<br><span class="hljs-string">&quot;discrete math&quot;</span>:         &#123;<span class="hljs-string">&quot;intro to programming&quot;</span>&#125;,<br><span class="hljs-string">&quot;formal languages&quot;</span>:      &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<br><span class="hljs-string">&quot;networks&quot;</span>:              &#123;<span class="hljs-string">&quot;operating systems&quot;</span>&#125;,<br><span class="hljs-string">&quot;operating systems&quot;</span>:     &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br><span class="hljs-string">&quot;programming languages&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> keys []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> prereqs &#123;<br>keys = <span class="hljs-built_in">append</span>(keys, key)<br>&#125;<br>breathFirst(keys)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">breathFirst</span><span class="hljs-params">(worklist []<span class="hljs-type">string</span>)</span></span> &#123;<br>n := <span class="hljs-number">1</span><br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(worklist) &gt; <span class="hljs-number">0</span> &#123;<br>items := worklist<br>worklist = <span class="hljs-literal">nil</span><br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<br><span class="hljs-keyword">if</span> !seen[item] &#123;<br>seen[item] = <span class="hljs-literal">true</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%d: %s\n&quot;</span>, n, item)<br>n++<br><br>worklist = <span class="hljs-built_in">append</span>(worklist, prereqs[item]...)<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="5-6-1-警告：-捕获迭代变量"><a href="#5-6-1-警告：-捕获迭代变量" class="headerlink" title="5.6.1. 警告： 捕获迭代变量"></a>5.6.1. 警告： 捕获迭代变量</h1><p>问题：你被要求首先创建一些目录，再将目录删除。在下面的例子中我们用函数值来完成删除操作。下面的示例代码需要引入os包。为了使代码简单，我们忽略了所有的异常处理。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">for</span> _, d := <span class="hljs-keyword">range</span> tempDirs() &#123;<br>    dir := d <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> necessary!</span><br>    os.MkdirAll(dir, <span class="hljs-number">0755</span>) <span class="hljs-comment">// creates parent directories too</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dir)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// ...do some work…</span><br><span class="hljs-keyword">for</span> _, rmdir := <span class="hljs-keyword">range</span> rmdirs &#123;<br>    rmdir() <span class="hljs-comment">// clean up</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为什么要在循环体中重新定义局部变量dir并用循环变量d赋值？<br>而不像下面代码中一样直接使用循环变量dir?</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br><span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> tempDirs() &#123;<br>    os.MkdirAll(dir, <span class="hljs-number">0755</span>)<br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dir) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子是错误的，函数append中的匿名函数，使用了最后一个循环变量dir，导致对os.RemoveAll调用删除都是相同的目录。为什么呢？<br>循环变量dir在for循环语句中声明，那么所有函数值都共享相同的循环变量，注意的是，函数值中的dir，记录的是变量dir的内存地址，而不是循环变量某一时刻的值。在迭代中，dir的值不断被更新，当删除操作执行时，for循环已经完成，那么dir的值为最后一次迭代的值。<br>所以，在循环中，重新声明一个新的变量，作为循环变量的副本，即可解决该问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, dir := <span class="hljs-keyword">range</span> tempDirs() &#123;<br>    dir := dir <span class="hljs-comment">// declares inner dir, initialized to outer dir</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该问题不仅存在于基于range的循环，还存在于for循环中，循环变量i的使用也存在同样的问题，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> rmdirs []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>dirs := tempDirs()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(dirs); i++ &#123;<br>    os.MkdirAll(dirs[i], <span class="hljs-number">0755</span>) <span class="hljs-comment">// OK</span><br>    rmdirs = <span class="hljs-built_in">append</span>(rmdirs, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        os.RemoveAll(dirs[i]) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>同样的，在go语句，defer语句也会存在该问题，并非其本身导致，而是因为它们都是等循环结束后，再执行函数值。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.5. 函数值</title>
      <link href="/posts/e0d18dccf0bc/"/>
      <url>/posts/e0d18dccf0bc/</url>
      
        <content type="html"><![CDATA[<p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。<br>例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">square</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> n * n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">negative</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> -n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">product</span><span class="hljs-params">(m, n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> m * n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := square<br>fmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 9</span><br><br>f = negative<br>fmt.Println(f(<span class="hljs-number">3</span>))     <span class="hljs-comment">// -3</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// func(int) int</span><br><br>f = product <span class="hljs-comment">// cannot use product (value of type func(m int, n int) int) as type func(n int) int in assignment</span><br>&#125;<br></code></pre></td></tr></table></figure><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br>f(<span class="hljs-number">3</span>) <span class="hljs-comment">// panic: runtime error: invalid memory address or nil pointer dereference</span><br></code></pre></td></tr></table></figure><p>函数值可以与nil比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-keyword">if</span> f != <span class="hljs-literal">nil</span> &#123;<br>f(<span class="hljs-number">3</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>但函数值之间不可以比较，也不能用函数值作为map的key。<br>可以继续参数化函数，如下例子。<code>strings.Map</code>对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add1</span><span class="hljs-params">(r <span class="hljs-type">rune</span>)</span></span> <span class="hljs-type">rune</span> &#123;<br><span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;HAL-9000&quot;</span>)) <span class="hljs-comment">// IBM.:111</span><br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;VMS&quot;</span>))      <span class="hljs-comment">// WNT</span><br>fmt.Println(strings.Map(add1, <span class="hljs-string">&quot;Admix&quot;</span>))    <span class="hljs-comment">// Benjy</span><br>&#125;<br></code></pre></td></tr></table></figure><p>5.2节的findLinks函数使用了辅助函数visit,遍历和操作了HTML页面的所有结点。使用函数值，我们可以将遍历结点的逻辑和操作结点的逻辑分离，使得我们可以复用遍历的逻辑，从而对结点进行不同的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Outline prints the outline of an HTML document tree.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>outline(url)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">//!+call</span><br>forEachNode(doc, startElement, endElement)<br><span class="hljs-comment">//!-call</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// !+forEachNode</span><br><span class="hljs-comment">// forEachNode calls the functions pre(x) and post(x) for each node</span><br><span class="hljs-comment">// x in the tree rooted at n. Both functions are optional.</span><br><span class="hljs-comment">// pre is called before the children are visits (preorder) and</span><br><span class="hljs-comment">// post is called after (postorder).</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>forEachNode(c, pre, post)<br>&#125;<br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//!-forEachNode</span><br><br><span class="hljs-comment">// !+startend</span><br><span class="hljs-keyword">var</span> depth <span class="hljs-type">int</span><br><br><span class="hljs-comment">// 控制输出的缩进，%*s中的*会在字符串之前填充一些空格。 每次输出会先填充depth*2数量的空格，在输出&quot;&quot;，最后再输出HTML标签。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)<br>depth++<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>depth--<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;/%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//!-startend</span><br></code></pre></td></tr></table></figure><p><code>forEachNode</code>函数有两个函数值的参数，<code>pre</code>和<code>post</code>，它们的类型都是<code>func(n *html.Node)</code>，表示一前一后的处理操作。<br>代码编译运行后，输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./outline.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go ./outline http://go.dev</span><br>&lt;html&gt;<br>  &lt;head&gt;<br>    &lt;link&gt;<br>    &lt;/link&gt;<br>    &lt;script&gt;<br>    &lt;/script&gt;<br>    &lt;meta&gt;<br>    &lt;/meta&gt;<br>...<br>  &lt;/head&gt;<br>&lt;/html&gt; <br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 5.7：</strong> 完善startElement和endElement函数，使其成为通用的HTML输出器。要求：输出注释结点，文本结点以及每个元素的属性（&lt; a href&#x3D;’…’&gt;）。使用简略格式输出没有孩子结点的元素（即用<img/>代替<img></img>）。编写测试，验证程序输出的格式正确。（详见11章）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>outline(url)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>forEachNode(doc, startElement, endElement)<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>forEachNode(c, pre, post)<br>&#125;<br><br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> depth <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;%s&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br>fmt.Printf(<span class="hljs-string">&quot; %s=%q&quot;</span>, a.Key, a.Val)<br>&#125;<br><span class="hljs-keyword">if</span> n.Data == <span class="hljs-string">&quot;img&quot;</span> &amp;&amp; n.FirstChild == <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;/&gt;&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;&gt;&quot;</span>)<br>&#125;<br>depth++<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n.Type == html.CommentNode &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;!--%s--&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>depth--<br><span class="hljs-keyword">if</span> n.Data != <span class="hljs-string">&quot;img&quot;</span> || n.FirstChild != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%*s&lt;/%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 5.8：</strong> 修改pre和post函数，使其返回布尔类型的返回值。返回false时，中止forEachNoded的遍历。使用修改后的代码编写ElementByID函数，根据用户输入的id查找第一个拥有该id元素的HTML元素，查找成功后，停止遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementByID</span><span class="hljs-params">(doc *html.Node, id <span class="hljs-type">string</span>)</span></span> *html.Node<br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> id = flag.String(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment">// $ go build ./outline.go</span><br><span class="hljs-comment">// $ ./outline -id quote_slide0 http://go.dev</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><br><span class="hljs-keyword">var</span> nodes []*html.Node<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">3</span>:] &#123;<br>node, err := outline(url, *id)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>nodes = <span class="hljs-built_in">append</span>(nodes, node)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, node := <span class="hljs-keyword">range</span> nodes &#123;<br>fmt.Println(node.Data)<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> node.Attr &#123;<br>fmt.Println(a.Key, a.Val)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(url, id <span class="hljs-type">string</span>)</span></span> (*html.Node, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-keyword">var</span> node *html.Node<br><span class="hljs-keyword">if</span> node = ElementByID(doc, id); node == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;node not found&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> node, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementByID</span><span class="hljs-params">(n *html.Node, id <span class="hljs-type">string</span>)</span></span> *html.Node &#123;<br><span class="hljs-keyword">return</span> forEachNode(n, id, findElement, findElement)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, id <span class="hljs-type">string</span>, pre, post <span class="hljs-keyword">func</span>(n *html.Node, id <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span>) *html.Node &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> pre(n, id) &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br><span class="hljs-keyword">if</span> node := forEachNode(c, id, pre, post); node != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> node<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> post(n, id) &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findElement</span><span class="hljs-params">(n *html.Node, id <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;id&quot;</span> &amp;&amp; a.Val == id &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./outline.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./outline -<span class="hljs-built_in">id</span> quote_slide0 http://go.dev</span><br></code></pre></td></tr></table></figure><p><strong>练习 5.9：</strong> 编写函数expand，将s中的”foo”替换为f(“foo”)的返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">expand</span><span class="hljs-params">(s <span class="hljs-type">string</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>foo := <span class="hljs-string">&quot;foo&quot;</span><br>fmt.Println(expand(foo, replace))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">expand</span><span class="hljs-params">(s <span class="hljs-type">string</span>, f <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>) <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> f(s)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">replace</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> s + <span class="hljs-string">&quot;-next&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.4. 错误</title>
      <link href="/posts/b269706cb426/"/>
      <url>/posts/b269706cb426/</url>
      
        <content type="html"><![CDATA[<p>函数对于运行失败预期结果，都会返回一个额外的返回值，通常是最后一个，用于传递错误信息。<br>额外的返回值可以是一个布尔值，通常被命名为ok。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">value, ok := cache.Lookup(key)<br><span class="hljs-keyword">if</span> !ok &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以返回error类型的返回值。当error为nil，则代表运行成功，error为non-nil时表示失败。<br>对于non-nil的error类型，可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(err)<br>fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)<br></code></pre></td></tr></table></figure><p>通常，当函数返回non-nil的error时，其他返回值是未定义的（undefined），未定义的返回值应该被忽略。但也有函数发生错误时，仍然会返回一些有用的返回值。如，读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。</p><h1 id="5-4-1-错误处理策略"><a href="#5-4-1-错误处理策略" class="headerlink" title="5.4.1. 错误处理策略"></a>5.4.1. 错误处理策略</h1><p>常用的五种方式：</p><ul><li>传播错误</li><li>重试</li><li>输出错误信息并结束程序</li><li>只输出错误信息</li><li>忽略错误</li></ul><h2 id="传播错误"><a href="#传播错误" class="headerlink" title="传播错误"></a>传播错误</h2><p>当函数发生错误时，可以讲函数错误返回给调用者。<br><code>fmt.Errorf</code>函数使用<code>fmt.Sprintf</code>格式化错误信息并返回。<br>当在传播错误时，应该错误信息前缀添加额外的上下文信息到原始错误信息中，最后错误最终有main函数处理时，错误信息应提供清晰地从原因到后果的因果链。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">genesis: crashed: no parachute: G-<span class="hljs-keyword">switch</span> failed: bad relay orientation<br></code></pre></td></tr></table></figure><p>编写错误信息时，确保错误信息对问题细节的描述是详尽的，要注意错误信息表达的一致性，即相同函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。如OS包。</p><h2 id="重试"><a href="#重试" class="headerlink" title="重试"></a>重试</h2><p>如果错误的发生是偶然的，或由不可预知的问题导致的，则可以进行重试。<br>在重试时，需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// The wait program waits for an HTTP server to start responding.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// !+</span><br><span class="hljs-comment">// WaitForServer attempts to contact the server of a URL.</span><br><span class="hljs-comment">// It tries for one minute using exponential back-off.</span><br><span class="hljs-comment">// It reports an error if all attempt fail.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WaitForServer</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span> &#123;<br><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1</span> * time.Minute<br>deadline := time.Now().Add(timeout)<br><span class="hljs-keyword">for</span> tries := <span class="hljs-number">0</span>; time.Now().Before(deadline); tries++ &#123;<br>_, err := http.Head(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// success</span><br>&#125;<br>log.Printf(<span class="hljs-string">&quot;server not responding (%v); retrying...&quot;</span>, err)<br>time.Sleep(time.Second &gt;&gt; <span class="hljs-type">uint</span>(tries)) <span class="hljs-comment">// exponential back-off</span><br>&#125;<br><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)<br>&#125;<br><br><span class="hljs-comment">//!-</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(os.Args) != <span class="hljs-number">2</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;usage: wait url\n&quot;</span>)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>url := os.Args[<span class="hljs-number">1</span>]<br><span class="hljs-comment">//!+main</span><br><span class="hljs-comment">// (In function main.)</span><br><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-comment">//!-main</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="输出错误信息并结束程序"><a href="#输出错误信息并结束程序" class="headerlink" title="输出错误信息并结束程序"></a>输出错误信息并结束程序</h2><p>输出错误信息并结束程序，这种策略只应在main中执行。<br>对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性。即遇到了bug，才能在库函数中结束程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>调用log.Fatalf可以更简洁的代码达到与上文相同的效果。<br>log中的所有函数，都默认会在错误信息之前输出时间信息。<br>长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">2023/05/05 05:47:46 Site is down:server https://go.dev failed to respond after 1m0s<br></code></pre></td></tr></table></figure><p>当然，还可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">log.SetPrefix(<span class="hljs-string">&quot;wait:&quot;</span>)<br>log.SetFlags(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><h2 id="只输出错误信息"><a href="#只输出错误信息" class="headerlink" title="只输出错误信息"></a>只输出错误信息</h2><p>有时候，只需要输出错误信息即可，而不中断程序的运行。<br>如log包中输出函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := Ping(); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Printf(<span class="hljs-string">&quot;ping failed: %v; networking disabled&quot;</span>,err)<br>&#125;<br></code></pre></td></tr></table></figure><p>或者标准错误流输出错误信息：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> err := Ping(); err != <span class="hljs-literal">nil</span> &#123;<br>    fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;ping failed: %v; networking disabled\n&quot;</span>, err)<br>&#125;<br></code></pre></td></tr></table></figure><p>log包中的所有函数会为没有换行符的字符串增加换行符。</p><h2 id="忽略错误"><a href="#忽略错误" class="headerlink" title="忽略错误"></a>忽略错误</h2><p>如下例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">dir, err := ioutil.TempDir(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;scratch&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to create temp dir: %v&quot;</span>,err)<br>&#125;<br><span class="hljs-comment">// ...use temp dir…</span><br>os.RemoveAll(dir) <span class="hljs-comment">// ignore errors; $TMPDIR is cleaned periodically</span><br></code></pre></td></tr></table></figure><p>尽管<code>os.RemoveAll</code>会失败，但例子中并没有做错误处理。<br>因为操作系统会定期的清理临时目录。所以，程序没有处理错误。<br>当决定忽略某个错误时，应该清晰记录原因。</p><h2 id="错误处理编码风格"><a href="#错误处理编码风格" class="headerlink" title="错误处理编码风格"></a>错误处理编码风格</h2><p>检查某个子函数是否失败后，通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。<br>如上忽略错误的例子。</p><h1 id="5-4-2-文件结尾错误（EOF）"><a href="#5-4-2-文件结尾错误（EOF）" class="headerlink" title="5.4.2. 文件结尾错误（EOF）"></a>5.4.2. 文件结尾错误（EOF）</h1><p><code>io包</code>保证任何由文件结束引起的读取失败都返回同一个错误——<code>io.EOF</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> io<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><br><br><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span><br><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)<br></code></pre></td></tr></table></figure><p>下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">in := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">for</span> &#123;<br>    r, _, err := in.ReadRune()<br>    <span class="hljs-keyword">if</span> err == io.EOF &#123;<br>        <span class="hljs-keyword">break</span> <span class="hljs-comment">// finished reading</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read failed:%v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-comment">// ...use r…</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.3. 多返回值</title>
      <link href="/posts/3b104e15a027/"/>
      <url>/posts/3b104e15a027/</url>
      
        <content type="html"><![CDATA[<p>在Go中，一个函数可以返回多个值。</p><p>下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。这意味着如果findlinks函数失败了，很可能是由于I&#x2F;O的错误导致的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//for _, url := range os.Args[1:] &#123;</span><br><span class="hljs-comment">//links, err := findLinks(url)</span><br><span class="hljs-comment">//if err != nil &#123;</span><br><span class="hljs-comment">//fmt.Fprintf(os.Stderr, &quot;findlinks2: %v\n&quot;, err)</span><br><span class="hljs-comment">//continue</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//for _, link := range links &#123;</span><br><span class="hljs-comment">//fmt.Println(link)</span><br><span class="hljs-comment">//&#125;</span><br><span class="hljs-comment">//&#125;</span><br><br>links, err := findLinks(<span class="hljs-string">&quot;http://go.dev&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks2: %v\n&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> links &#123;<br>fmt.Println(link)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// findLinks performs an HTTP GET request for url, parses the</span><br><span class="hljs-comment">// response as HTML, and extracts and returns the links.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLinks</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %s&quot;</span>, url, resp.Status)<br>&#125;<br>doc, err := html.Parse(resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)<br>&#125;<br><span class="hljs-keyword">return</span> visit(<span class="hljs-literal">nil</span>, doc), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(links []<span class="hljs-type">string</span>, n *html.Node)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;<br>links = <span class="hljs-built_in">append</span>(links, a.Val)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>links = visit(links, c)<br>&#125;<br><span class="hljs-keyword">return</span> links<br>&#125;<br></code></pre></td></tr></table></figure><p>准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Size</span><span class="hljs-params">(rect image.Rectangle)</span></span>(width, height <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><p>虽然良好的命名很重要，但也不必为每一个返回值都取一个名字。<br>按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，所以不必进行命名。</p><p>如果一个函数将所有的返回值都显示的变量名，那么该函数的return语句可以省略操作数。这称之为<code>bare return</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// CountWordsAndImages does an HTTP GET request for the HTML</span><br><span class="hljs-comment">// document url and returns the number of words and images in it.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountWordsAndImages</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (words, images <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>    resp, err := http.Get(url)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span><br>    &#125;<br>    doc, err := html.Parse(resp.Body)<br>    resp.Body.Close()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        err = fmt.Errorf(<span class="hljs-string">&quot;parsing HTML: %s&quot;</span>, err)<br>    <span class="hljs-keyword">return</span><br>    &#125;<br>    words, images = countWordsAndImages(doc)<br>    <span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countWordsAndImages</span><span class="hljs-params">(n *html.Node)</span></span> (words, images <span class="hljs-type">int</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;<br></code></pre></td></tr></table></figure><p>即赋值返回值的命名，则可以直接return，等价于</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">return</span> words, images, err<br></code></pre></td></tr></table></figure><p>但当函数有多处return语句以及许多返回值是，<code>bare return</code>可以减少代码的重复，但降低代码的可读性，所以不宜过度使用<code>bare return</code>。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 5.5：</strong> 实现countWordsAndImages。（参考练习4.9如何分词）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>images, words, err := CountWordsAndImages(<span class="hljs-string">&quot;http://go.dev&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;err: %v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;images: %d\nwords: %d\n&quot;</span>, images, words)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountWordsAndImages</span><span class="hljs-params">(url <span class="hljs-type">string</span>)</span></span> (images, words <span class="hljs-type">int</span>, err <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;parsing HTML: %s&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>images, words = countWordsAndImages(doc)<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countWordsAndImages</span><span class="hljs-params">(n *html.Node)</span></span> (images, words <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">if</span> n.Type == html.TextNode &#123;<br>words += <span class="hljs-built_in">len</span>(strings.Fields(n.Data))<br>&#125;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;img&quot;</span> &#123;<br>images++<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>imgs, ws := countWordsAndImages(c)<br>words += ws<br>images += imgs<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><br></code></pre></td></tr></table></figure><p><strong>练习 5.6：</strong> 修改gopl.io&#x2F;ch3&#x2F;surface (§3.2) 中的corner函数，将返回值命名，并使用bare return。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Surface computes an SVG rendering of a 3-D surface function.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>width, height = <span class="hljs-number">600</span>, <span class="hljs-number">320</span>            <span class="hljs-comment">// canvas size in pixels</span><br>cells         = <span class="hljs-number">100</span>                 <span class="hljs-comment">// number of grid cells</span><br>xyrange       = <span class="hljs-number">30.0</span>                <span class="hljs-comment">// axis ranges(-xyrange...+xyrange)</span><br>xyscale       = width / <span class="hljs-number">2</span> / xyrange <span class="hljs-comment">// pixels per x or y unit</span><br>zscale        = height * <span class="hljs-number">0.4</span>        <span class="hljs-comment">// pixels per z unit</span><br>angle         = math.Pi / <span class="hljs-number">6</span>         <span class="hljs-comment">// angle of x, y axes (=30°)</span><br>)<br><br><span class="hljs-keyword">var</span> sin30, cos30 = math.Sin(angle), math.Cos(angle) <span class="hljs-comment">// sin(30°) cos(30°)</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;&lt;svg xmlns=&#x27;http://www.w3.org/2000/svg&#x27; &quot;</span>+<br><span class="hljs-string">&quot;style=&#x27;stroke: grey; fill: white; stroke-width: 0.7&#x27; &quot;</span>+<br><span class="hljs-string">&quot;width=&#x27;%d&#x27; height=&#x27;%d&#x27;&gt;&quot;</span>, width, height)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; cells; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; cells; j++ &#123;<br>ax, ay := corner(i+<span class="hljs-number">1</span>, j)<br>bx, by := corner(i, j)<br>cx, cy := corner(i, j+<span class="hljs-number">1</span>)<br>dx, dy := corner(i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>)<br>fmt.Printf(<span class="hljs-string">&quot;&lt;polygon points=&#x27;%g,%g,%g,%g,%g,%g,%g,%g&#x27;/&gt;\n&quot;</span>, ax, ay, bx, by, cx, cy, dx, dy)<br>&#125;<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;&lt;/svg&gt;&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">corner</span><span class="hljs-params">(i, j <span class="hljs-type">int</span>)</span></span> (sx, sy <span class="hljs-type">float64</span>) &#123;<br><span class="hljs-comment">// Find point(x,y) at corner of cell(i,j).</span><br>x := xyrange * (<span class="hljs-type">float64</span>(i)/cells - <span class="hljs-number">0.5</span>)<br>y := xyrange * (<span class="hljs-type">float64</span>(j)/cells - <span class="hljs-number">0.5</span>)<br><br><span class="hljs-comment">// Compute surface height z.</span><br>z := f(x, y)<br><br><span class="hljs-comment">// Project(x,y,z) isometrically onto 2-D SVG canvas(sx,sy)</span><br>sx = width/<span class="hljs-number">2</span> + (x-y)*cos30*xyscale<br>sy = height/<span class="hljs-number">2</span> + (x+y)*sin30*xyscale - z*zscale<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x, y <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>r := math.Hypot(x, y) <span class="hljs-comment">// distance from (0,0)</span><br><span class="hljs-keyword">return</span> math.Sin(r) / r<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.2. 递归</title>
      <link href="/posts/3e816bbb7aaa/"/>
      <url>/posts/3e816bbb7aaa/</url>
      
        <content type="html"><![CDATA[<p>函数递归：函数直接或间接地调用自身。<br>例子中调用<code>golang.org/x/net/html</code>的部分api如下所示。html.Parse函数读入一组bytes.解析后，返回html.node类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）,commnets（注释）类型，在下面的例子中，我们 只关注&lt; name key&#x3D;’value’ &gt;形式的结点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Findlinks1 prints the links in an HTML document read from standard input.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">$ go build ./../../ch1/fetch.go</span><br><span class="hljs-comment">$ go build ./main.go</span><br><span class="hljs-comment">$ ./fetch https://go.dev | ./main</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks1: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> visit(<span class="hljs-literal">nil</span>, doc) &#123;<br>fmt.Println(link)<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">// visit appends to links each link found in n and returns the result.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(links []<span class="hljs-type">string</span>, n *html.Node)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;<br>links = <span class="hljs-built_in">append</span>(links, a.Val)<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>links = visit(links, c)<br>&#125;<br><span class="hljs-keyword">return</span> links<br>&#125;<br></code></pre></td></tr></table></figure><p>使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./../../ch1/fetch.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./main.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch https://go.dev | ./main</span><br></code></pre></td></tr></table></figure><p>为了遍历节点n的所有后代节点，每次遇到n的孩子节点时，visit递归调用自身。<br>可以得出页面内的链接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">/<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">/solutions/case-studies</span><br>/solutions/use-cases<br>/security/<br>/learn/<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">/doc/effective_go</span><br>/doc<br>https://pkg.go.dev/std<br>/doc/devel/release<br>https://pkg.go.dev<br><span class="hljs-meta prompt_">#</span><span class="language-bash"></span><br><span class="language-bash">/talks/</span><br>https://www.meetup.com/pro/go<br>https://github.com/golang/go/wiki/Conferences<br>/blog<br>/help<br>https://groups.google.com/g/golang-nuts<br>https://github.com/golang<br>https://twitter.com/golang<br>https://www.reddit.com/r/golang/<br>https://invite.slack.golangbridge.org/<br>https://stackoverflow.com/tags/go<br><br></code></pre></td></tr></table></figure><p>在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;outline: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>outline(<span class="hljs-literal">nil</span>, doc)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(stack []<span class="hljs-type">string</span>, n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>stack = <span class="hljs-built_in">append</span>(stack, n.Data)<br>fmt.Println(stack)<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>outline(stack, c)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./main.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch https://go.dev | ./main</span><br></code></pre></td></tr></table></figure><p>得到以下输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">[html]<br>[html head]<br>[html head link]<br>[html head script]<br>[html head meta]<br>[html head meta]<br>[html head meta]<br>[html head link]<br>[html head link]<br>[html head link]<br>[html head link]<br>[html head link]<br>[html head script]<br>[html head script]<br>...<br></code></pre></td></tr></table></figure><p>编程语言大部分会限制使用栈的大小，如64KB到2MB不等。<br>固定大小的栈会限制递归的深度，递归处理大量数据时，需要考虑栈溢出的问题，甚至会导致安全问题。<br>相反，Go语言使用可变栈，即栈的大小按需增加，使得使用递归时不必考虑溢出和安全问题。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 5.1：</strong> 修改findlinks代码中遍历n.FirstChild链表的部分，将循环调用visit，改成递归调用。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks1: %v\n&quot;</span>, err) <br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> visit(<span class="hljs-literal">nil</span>, doc) &#123;<br>fmt.Println(link)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(links []<span class="hljs-type">string</span>, n *html.Node)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> n == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> links<br>&#125;<br><br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;<br>links = <span class="hljs-built_in">append</span>(links, a.Val)<br>&#125;<br>&#125;<br>&#125;<br><br>links = visit(links, n.FirstChild)<br>links = visit(links, n.NextSibling)<br><br><span class="hljs-keyword">return</span> links<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 5.2：</strong> 编写函数，记录在HTML树中出现的同名元素的次数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> count = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;html parse: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>visit(doc)<br><span class="hljs-keyword">for</span> v, c := <span class="hljs-keyword">range</span> count &#123;<br>fmt.Println(v, c)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;<br>count[n.Data]++<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>visit(c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 5.3：</strong> 编写函数输出所有text结点的内容。注意不要访问<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code>元素,因为这些元素对浏览者是不可见的。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">for</span> _, text := <span class="hljs-keyword">range</span> visit(<span class="hljs-literal">nil</span>, doc) &#123;<br>fmt.Println(text)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(texts []<span class="hljs-type">string</span>, n *html.Node)</span></span> []<span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data != <span class="hljs-string">&quot;script&quot;</span> &amp;&amp; n.Data != <span class="hljs-string">&quot;style&quot;</span> &#123;<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br>texts = <span class="hljs-built_in">append</span>(texts, a.Val)<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>texts = visit(texts, c)<br>&#125;<br><span class="hljs-keyword">return</span> texts<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 5.4：</strong> 扩展visit函数，使其能够处理其他类型的结点，如images、scripts和style sheets。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>doc, err := html.Parse(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks1: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>visit(doc)<br><br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;links:%v\nimgs:%v\nscripts:%v\nstyles:%v\n&quot;</span>, links, imgs, scripts, styles)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>links   []<span class="hljs-type">string</span><br>imgs    []<span class="hljs-type">string</span><br>scripts []<span class="hljs-type">string</span><br>styles  []<span class="hljs-type">string</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type != html.ElementNode &#123;<br><span class="hljs-keyword">goto</span> LOOP<br>&#125;<br><br><span class="hljs-keyword">switch</span> n.Data &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;a&quot;</span>:<br><span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;<br>links = <span class="hljs-built_in">append</span>(links, a.Val)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;img&quot;</span>:<br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> i.Key == <span class="hljs-string">&quot;src&quot;</span> &#123;<br>imgs = <span class="hljs-built_in">append</span>(imgs, i.Val)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;script&quot;</span>:<br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> s.Key == <span class="hljs-string">&quot;src&quot;</span> &#123;<br>scripts = <span class="hljs-built_in">append</span>(scripts, s.Val)<br>&#125;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;link&quot;</span>:<br><span class="hljs-keyword">for</span> _, m := <span class="hljs-keyword">range</span> n.Attr &#123;<br><span class="hljs-keyword">if</span> m.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;<br>styles = <span class="hljs-built_in">append</span>(styles, m.Val)<br>&#125;<br>&#125;<br>&#125;<br><br>LOOP:<br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>visit(c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.1. 函数声明</title>
      <link href="/posts/9ebdd846b6d6/"/>
      <url>/posts/9ebdd846b6d6/</url>
      
        <content type="html"><![CDATA[<p>函数声明的写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(parameter-list)</span></span> (result-list) &#123;<br>body<br>&#125;<br></code></pre></td></tr></table></figure><p>函数声包括函数名、形式参数列表、返回值列表（可省略）以及函数体。<br>形式参数列表描述了函数的参数名以及参数类型。<br>返回值列表描述了函数返回值的变量名以及类型。<br>如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。<br>函数声明没有返回值列表时，那么函数体执行完毕后，不会返回任何值。<br>如果一组形参或返回值有相同的类型，可以简化成一个参数类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(i,j,k <span class="hljs-type">int</span>, s, t <span class="hljs-type">string</span>)</span></span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(i <span class="hljs-type">int</span>, j <span class="hljs-type">int</span>, k <span class="hljs-type">int</span>, s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span>&#123;<span class="hljs-comment">/*...*/</span>&#125;<br></code></pre></td></tr></table></figure><p>当形参未被使用时，可以使用_表示。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">first</span><span class="hljs-params">(x <span class="hljs-type">int</span>, _ <span class="hljs-type">int</span>)</span></span> &#123;<span class="hljs-keyword">return</span> x&#125;<br></code></pre></td></tr></table></figure><p>函数的类型被称为函数的标识符。<br>如果两个函数的形参列表和返回值列表中的变量类型一一对应，那么可以说这两个函数有相同的类型和标识符，也就是这两个函数相同。<br>形参和返回值的变量名不影响函数标识符，也不影响它们是否可以以省略参数类型的形式表示。</p><p>调用参数时必须按照函数声明顺序为所有参数提供实参。<br>Go语言中，函数没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对应函数调用者而言没有意义。</p><p>在函数体中，形参作为局部变量，被初始化为调用者提供的值。<br>函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</p><p>实参通过值的方式进行传递，因此函数的形参是实参的拷贝。<br>对形参的修改不会影响实参，但如果实参为引用类型，如指针、slice、map、function、channel等类型，实参可能由于函数的简接引用而被修改。</p><p>当遇到没有函数体的函数声明，这表示该函数不是以Go实现的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> math<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sin</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> float<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.10. Recover捕获异常</title>
      <link href="/posts/316db6a53afd/"/>
      <url>/posts/316db6a53afd/</url>
      
        <content type="html"><![CDATA[<p>[toc]</p><p>通常情况下，不应该对<code>panic</code>异常做任何处理，但有时，也可以使得程序从异常中恢复，或至少在程序崩溃前做一些事情。如web服务器在开发过程中，将异常信息反馈到客户端，便于调试。</p><p>在<code>defer</code>函数中调用内置<code>recover</code>函数，并且定义该<code>defer</code>语句中的函数发生了<code>panic</code>异常，<code>recover</code>函数会使程序从<code>panic</code>中恢复，并返回<code>panic value</code>。<br>导致<code>panic</code>异常的函数不会继续运行，但能正常返回。<br>在未发生<code>panic</code>时调用<code>recover</code>，<code>recover</code>会返回nil。<br>以语言解析器为例，当某个异常出现时，不会让解析器崩溃，而是将异常信息当做普通的解析错误，并附加额外信息提醒用户报告此错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-type">string</span>)</span></span> (s *Syntax, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;<br>err = fmt.Errorf(<span class="hljs-string">&quot;internal error: %v&quot;</span>, p)<br>&#125;<br>&#125;()<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。</p><p>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</p><p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p><p><code>只恢复应该被恢复的panic异常.</code></p><p>被恢复的panic异常占比应该尽可能的低。<br>为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p><p>下面的例子是title函数的变形，如果HTML页面包含多个<code>&lt;title&gt;</code>，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个<code>&lt;title&gt;</code>，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>url := <span class="hljs-string">&quot;https://www.dy2018.com/&quot;</span><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>doc, err := html.Parse(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>title, err := soleTitle(doc)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;url: %s, title: %s&quot;</span>, url, title)<br>&#125;<br><br><span class="hljs-comment">// soleTitle returns the text of the first non-empty title element</span><br><span class="hljs-comment">// in doc, and an error if there was not exactly one.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">soleTitle</span><span class="hljs-params">(doc *html.Node)</span></span> (title <span class="hljs-type">string</span>, err <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">type</span> bailout <span class="hljs-keyword">struct</span>&#123;&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">switch</span> p := <span class="hljs-built_in">recover</span>(); p &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>: <span class="hljs-comment">// nil panic</span><br><span class="hljs-keyword">case</span> bailout&#123;&#125;: <span class="hljs-comment">// expected panic</span><br>err = fmt.Errorf(<span class="hljs-string">&quot;multiple title elements&quot;</span>)<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">panic</span>(p)<br>&#125;<br>&#125;()<br><br>forEachNode(doc, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<br><span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;title&quot;</span> &amp;&amp; n.FirstChild != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">if</span> title != <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-built_in">panic</span>(bailout&#123;&#125;)<br>&#125;<br>title = n.FirstChild.Data<br>&#125;<br>&#125;, <span class="hljs-literal">nil</span>)<br><br><span class="hljs-keyword">if</span> title == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;no title element&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> title, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(node *html.Node)</span></span>) &#123;<br><span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;<br>pre(n)<br>&#125;<br><br><span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;<br>forEachNode(c, pre, post)<br>&#125;<br><br><span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;<br>post(n)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，deferred函数调用recover，并检查panic value。当panic value是bailout{}类型时，deferred函数生成一个error返回给调用者。当panic value是其他non-nil值时，表示发生了未知的panic异常，deferred函数将调用panic函数并将当前的panic value作为参数传入。此时，等同于recover没有做任何操作。（请注意：在例子中，对可预期的错误采用了panic，这违反了之前的建议，我们在此只是想向读者演示这种机制。）</p><p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如<code>内存不足</code>。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习5.19：</strong> 使用panic和recover编写一个不包含return语句但能返回一个非零值的函数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f()) <span class="hljs-comment">// 1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (n <span class="hljs-type">int</span>) &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>n = <span class="hljs-number">1</span><br>_ = <span class="hljs-built_in">recover</span>()<br>&#125;()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.6 文本和HTML模版</title>
      <link href="/posts/4d1bb1bed6d0/"/>
      <url>/posts/4d1bb1bed6d0/</url>
      
        <content type="html"><![CDATA[<p>复杂的打印格式可以使用<code>text/template</code>和<code>html\template</code>等模板包实现。<br>模版包含一个字符串或一个文件，里面包含一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。<br><code>action</code>对象包含一个用模板语言书写的表达式，如选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句等等特性。</p><h1 id="text-template"><a href="#text-template" class="headerlink" title="text&#x2F;template"></a>text&#x2F;template</h1><p>下面是一个简单的模板字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ch/ch4/github&quot;</span><br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// !+template</span><br><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span><br><span class="hljs-string">&#123;&#123;range .Items&#125;&#125;---------------------------------------</span><br><span class="hljs-string">Number:&#123;&#123;.Number&#125;&#125;</span><br><span class="hljs-string">User:&#123;&#123;.User.Login&#125;&#125;</span><br><span class="hljs-string">Title:&#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;</span><br><span class="hljs-string">Age:&#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span><br><span class="hljs-string">&#123;&#123;end&#125;&#125;`</span><br><br><span class="hljs-comment">//!-template</span><br><br><span class="hljs-comment">// !+daysAgo</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daysAgo</span><span class="hljs-params">(t time.Time)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(time.Since(t).Hours() / <span class="hljs-number">24</span>)<br>&#125;<br><br><span class="hljs-comment">//!-daysAgo</span><br><br><span class="hljs-comment">// !+exec</span><br><span class="hljs-keyword">var</span> report = template.Must(template.New(<span class="hljs-string">&quot;issuelist&quot;</span>).<br>Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).<br>Parse(templ))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// !-exec</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">noMust</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//!+parse</span><br>report, err := template.New(<span class="hljs-string">&quot;reprot&quot;</span>).<br>Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).<br>Parse(templ)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-comment">//!-parse</span><br><br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//!+output</span><br><span class="hljs-comment">$ go run main.go windows+label:bug</span><br><span class="hljs-comment">651325 issues:</span><br><span class="hljs-comment">---------------------------------------</span><br><span class="hljs-comment">Number: 1449</span><br><span class="hljs-comment">User:   sensuikan1973</span><br><span class="hljs-comment">Title:  debug windows widget test</span><br><span class="hljs-comment">Age:    0 days</span><br><span class="hljs-comment">---------------------------------------</span><br><span class="hljs-comment">Number: 334</span><br><span class="hljs-comment">User:   mkilgore</span><br><span class="hljs-comment">Title:  Fix keyboard _Device on Windows</span><br><span class="hljs-comment">Age:    0 days</span><br><span class="hljs-comment">---------------------------------------</span><br><span class="hljs-comment">...</span><br><span class="hljs-comment">//!-output</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>点操作符<code>.</code>可以引用模板调用参数，当前例子中对应为<code>github.IssuesSearchResult</code>类型的变量。<br>模板中<code>&#123;&#123;.TotalCount&#125;&#125;</code>对应action将展开为结构体中<code>TotalCount</code>成员以默认的方式打印的值。<br>模板中<code>&#123;&#123;range .Items&#125;&#125;</code>和<code>&#123;&#123;end&#125;&#125;</code>对应一个循环action，可以进行循环迭代，每次迭代的当前值对应当前的Iteams元素的值。<br><code>|</code>操作符表示将前一个表达式的结果作为后一个函数的输入，类型UNIX中管道的概率。<br>在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用。<br>对于Age部分，第二个动作是一个叫daysAgo的函数，通过time.Since函数将CreatedAt成员转换为过去的时间长度。</p><p>生成模板的输出需要两个处理步骤。第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。<br>分析模板部分一般只需要执行一次。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">report, err := template.New(<span class="hljs-string">&quot;reprot&quot;</span>).<br>Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).<br>Parse(templ)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的模板执行顺序：</p><ol><li><code>template.New</code>先创建并返回一个模板。</li><li><code>Funcs</code>方法将<code>daysAgo</code>等自定义函数注册到模板中，并返回模板。</li><li>最后调用<code>Parse</code>函数分析模板。</li></ol><p><code>template.Must</code>辅助函数可以简化模板解析失败的处理：它接受一个模板和一个error类型的参数，检测error是否为nil（如果不是nil则发出panic异常），然后返回传入的模板。</p><p>模板创建、注册函数、并通过分析和检测，可以使用<code>github.IssuesSearchResult</code>作为输入源、<code>os.Stdout</code>作为输出源来执行模板：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> report = template.Must(template.New(<span class="hljs-string">&quot;issuelist&quot;</span>).<br>Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).<br>Parse(templ))<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="html-template"><a href="#html-template" class="headerlink" title="html&#x2F;template"></a>html&#x2F;template</h1><p><code>html/template</code>包使用的API和模板语言与<code>text/template</code>包一样，但增加了一个讲字符串自动转义特性，以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。还能避免安全问题，如通过生成HTML注入攻击、通过构造一个含有恶意代码的问题标题。<br>下面的模板以HTML格式输出issue列表：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Issueshtml prints an HTML table of issues matching the search terms.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;go-learn-gopl/ch/ch4/github&quot;</span><br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// !+template</span><br><span class="hljs-keyword">var</span> issueList = template.Must(template.New(<span class="hljs-string">&quot;issuelist&quot;</span>).Parse(<span class="hljs-string">`</span><br><span class="hljs-string">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span><br><span class="hljs-string">&lt;table&gt;</span><br><span class="hljs-string">&lt;tr style=&#x27;text-align: left&#x27;&gt;</span><br><span class="hljs-string">&lt;th&gt;#&lt;/th&gt;</span><br><span class="hljs-string">&lt;th&gt;State&lt;/th&gt;</span><br><span class="hljs-string">&lt;th&gt;User&lt;/th&gt;</span><br><span class="hljs-string">&lt;th&gt;Title&lt;/th&gt;</span><br><span class="hljs-string">&lt;/tr&gt;</span><br><span class="hljs-string">&#123;&#123;range .Items&#125;&#125;</span><br><span class="hljs-string">&lt;tr&gt;</span><br><span class="hljs-string">&lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="hljs-string">&lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span><br><span class="hljs-string">&lt;td&gt;&lt;a href=&#x27;&#123;&#123;.User.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="hljs-string">&lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><br><span class="hljs-string">&lt;/tr&gt;</span><br><span class="hljs-string">&#123;&#123;end&#125;&#125;</span><br><span class="hljs-string">&lt;/table&gt;</span><br><span class="hljs-string">`</span>))<br><br><span class="hljs-comment">//!-template</span><br><br><span class="hljs-comment">// !+</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><span class="hljs-keyword">if</span> err := issueList.Execute(os.Stdout, result); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//!-</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">//!+output</span><br><span class="hljs-comment">$ go run main.go windows+label:bug</span><br><span class="hljs-comment">//!-output</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>得出结果：<br><img src="/4.6%20%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E7%89%88/1682529639246.png" alt="enter description here"><br><strong>html&#x2F;template包自动将特殊字符转义，因此依然可以看到正确的字面值。</strong><br>如果使用<code>text/template</code>包的话，如”&It;”四个字符会被当作小于字符”&lt;”处理，同时”<link>“字符串会被当作一个链接元素处理，就会导致HTML文档结构的改变，从而导致有未知的风险。<br>通过对信任的HTML字符串使用template.HTML类型来抑制这种自动转义的行为。还有很多采用类型命名的字符串类型分别对应信任的JavaScript、CSS和URL。<br>下面的程序演示了两个使用不同类型的相同字符串产生的不同结果：A是一个普通字符串，B是一个信任的template.HTML字符串类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Autoescape demonstrate automatic HTML escaping in html/template.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-comment">// !+</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&lt;p&gt;A: &#123;&#123;.A&#125;&#125;&lt;/p&gt;&lt;p&gt;B: &#123;&#123;.B&#125;&#125;&lt;/p&gt;`</span><br>t := template.Must(template.New(<span class="hljs-string">&quot;escape&quot;</span>).Parse(templ))<br><span class="hljs-keyword">var</span> data <span class="hljs-keyword">struct</span> &#123;<br>A <span class="hljs-type">string</span><br>B template.HTML<br>&#125;<br>data.A = <span class="hljs-string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span><br>data.B = <span class="hljs-string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span><br><span class="hljs-keyword">if</span> err := t.Execute(os.Stdout, data); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//!-</span><br></code></pre></td></tr></table></figure><p>执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run main.go &gt;autoescape.html</span><br></code></pre></td></tr></table></figure><p><img src="/4.6%20%E6%96%87%E6%9C%AC%E5%92%8CHTML%E6%A8%A1%E7%89%88/1682530571287.png" alt="enter description here"><br>由上图可知，A的黑体标志被转义失效了，但B没有。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 4.14：</strong> 创建一个web服务器，查询一次GitHub，然后生成BUG报告、里程碑和对应的用户信息。<br>解：<br>issue&#x2F;issue.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> issue<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> IssuesURL = <span class="hljs-string">&quot;https://api.github.com/search/issues&quot;</span><br><br><span class="hljs-keyword">type</span> IssuesSearchResult <span class="hljs-keyword">struct</span> &#123;<br>TotalCount <span class="hljs-type">int</span> <span class="hljs-string">`json:total_count`</span><br>Items      []Issue<br>&#125;<br><br><span class="hljs-keyword">type</span> Issue <span class="hljs-keyword">struct</span> &#123;<br>Title     <span class="hljs-type">string</span><br>User      User<br>Milestone Milestone<br>&#125;<br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Login <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Milestone <span class="hljs-keyword">struct</span> &#123;<br>Title       <span class="hljs-type">string</span><br>Description <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SearchIssues</span><span class="hljs-params">(params <span class="hljs-type">string</span>)</span></span> (*IssuesSearchResult, <span class="hljs-type">error</span>) &#123;<br>resp, err := http.Get(IssuesURL + <span class="hljs-string">&quot;?q=&quot;</span> + params)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-keyword">var</span> result IssuesSearchResult<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;result, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>index.html</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">&lt;!DOCTYPE html&gt;<br>&lt;html lang=<span class="hljs-string">&quot;en&quot;</span> xmlns=<span class="hljs-string">&quot;http://www.w3.org/1999/html&quot;</span>&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Issue Search&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues:&lt;/h1&gt;<br>&lt;table&gt;<br>    &lt;tr style=<span class="hljs-string">&quot;text-align: left&quot;</span>&gt;<br>        &lt;th&gt;Title&lt;/th&gt;<br>        &lt;th&gt;User&lt;/th&gt;<br>        &lt;th&gt;Milestone&lt;/th&gt;<br>        &lt;th&gt;Description&lt;/th&gt;<br>    &lt;/tr&gt;<br>    &#123;&#123;<span class="hljs-keyword">range</span> .Items&#125;&#125;<br>    &lt;tr&gt;<br>        &lt;td&gt;&#123;&#123;.Title&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Milestone.Title&#125;&#125;&lt;/td&gt;<br>        &lt;td&gt;&#123;&#123;.Milestone.Description&#125;&#125;&lt;/td&gt;<br>    &lt;/tr&gt;<br>    &#123;&#123;end&#125;&#125;<br>&lt;/table&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex4/ex4.14/issue&quot;</span><br><span class="hljs-string">&quot;html/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, Handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintln(w, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>q := r.FormValue(<span class="hljs-string">&quot;key&quot;</span>)<br>result, err := issue.SearchIssues(q)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintln(w, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>templ := template.Must(template.ParseFiles(<span class="hljs-string">&quot;./ex/ex4/ex4.14/index.html&quot;</span>))<br><span class="hljs-keyword">if</span> err := templ.Execute(w, result); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintln(w, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.5. JSON</title>
      <link href="/posts/b184f11121f4/"/>
      <url>/posts/b184f11121f4/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>JSON（JavaScript Object Notation）是基于JavaScript语言的轻量级的数据交换格式，也常用于发送和接收结构化信息的标准协议。<br>还有类似的协议，如XML、ASN.1和Google的Protocol Buffers。</p><p>Go语言对于这些标准格式的编码和解码都有良好的支持，标准库中对应的包有<code>encoding/json</code>、<code>encoding/xml</code>、<code>encoding/asn1</code>。“Protocol Buffers的支持由 github.com&#x2F;golang&#x2F;protobuf 包提供）。</p><h1 id="JSON支持的类型"><a href="#JSON支持的类型" class="headerlink" title="JSON支持的类型"></a>JSON支持的类型</h1><p>JSON是对JavaScript中各种类型的Unicode文本编码。<br>JSON类型如下：</p><ul><li>字符串<br>  字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是\Uhhhh转义数字来表示一个UTF-16编码（译注：UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题），而不是Go语言的rune类型。如：”She said &quot;Hello,BF&quot;“</li><li>数字number<br>  十进制或科学计数法，如：-273.15</li><li>布尔值boolean<br>  true或false</li><li>数组array<br>  如：[“gold”,”silver”,”bronze”]</li><li>对象object<br>  如：<br>  {<br>          “year”: 1980,<br>           “event”: “archery”,<br>           “medals”: [“gold”, “silver”, “bronze”]<br>  }</li></ul><p>下面程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span> &#123;<br>Title  <span class="hljs-type">string</span><br>Year   <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;released&quot;`</span><br>Color  <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;color,omitempty&quot;`</span><br>Actors []<span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> movies = []Movie&#123;<br>&#123;Title: <span class="hljs-string">&quot;Casablanca&quot;</span>, Year: <span class="hljs-number">1942</span>, Color: <span class="hljs-literal">false</span>, Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Humphrey Bogart&quot;</span>, <span class="hljs-string">&quot;Ingrid Bergman&quot;</span>&#125;&#125;,<br>&#123;Title: <span class="hljs-string">&quot;Cool Hand Luke&quot;</span>, Year: <span class="hljs-number">1967</span>, Color: <span class="hljs-literal">true</span>, Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Paul Newman&quot;</span>&#125;&#125;,<br>&#123;Title: <span class="hljs-string">&quot;Bullitt&quot;</span>, Year: <span class="hljs-number">1968</span>, Color: <span class="hljs-literal">true</span>, Actors: []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;Steve McQueen&quot;</span>, <span class="hljs-string">&quot;Jacqueline Bisset&quot;</span>&#125;&#125;,<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="JSON的编码与解码"><a href="#JSON的编码与解码" class="headerlink" title="JSON的编码与解码"></a>JSON的编码与解码</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><p>将一个Go语言中类似movies的结构体slice转为JSON的过程叫编码（marshaling）。<br>通过<code>json.Marshall</code>函数完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := json.Marshal(movies)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed:%s&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[&#123;&quot;Title&quot;:&quot;Casablanca&quot;,&quot;released&quot;:1942,&quot;Actors&quot;:[&quot;Humphrey Bogart&quot;,&quot;Ingrid Bergman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Cool Hand Luke&quot;,&quot;released&quot;:1967,&quot;color&quot;:true,&quot;Actors&quot;:[&quot;Paul Newman&quot;]&#125;,&#123;&quot;Title&quot;:&quot;Bullitt&quot;,&quot;released&quot;:1968,&quot;color&quot;:true,&quot;Actors&quot;:[&quot;Steve McQueen&quot;,&quot;Jacqueline Bisset&quot;]&#125;]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>json.MarshalIndent</code>函数可以产生整齐缩进的输出，以便阅读。<br>该函数有两个字符串参数，分别表示每一行输出的前缀和每一个层级的缩进。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := json.MarshalIndent(movies, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed:%s&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">[</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">                &quot;Title&quot;: &quot;Casablanca&quot;,</span><br><span class="hljs-comment">                &quot;released&quot;: 1942,</span><br><span class="hljs-comment">                &quot;Actors&quot;: [</span><br><span class="hljs-comment">                        &quot;Humphrey Bogart&quot;,</span><br><span class="hljs-comment">                        &quot;Ingrid Bergman&quot;</span><br><span class="hljs-comment">                ]</span><br><span class="hljs-comment">        &#125;,</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">                &quot;Title&quot;: &quot;Cool Hand Luke&quot;,</span><br><span class="hljs-comment">                &quot;released&quot;: 1967,</span><br><span class="hljs-comment">                &quot;color&quot;: true,</span><br><span class="hljs-comment">                &quot;Actors&quot;: [</span><br><span class="hljs-comment">                        &quot;Paul Newman&quot;</span><br><span class="hljs-comment">                ]</span><br><span class="hljs-comment">        &#125;,</span><br><span class="hljs-comment">        &#123;</span><br><span class="hljs-comment">                &quot;Title&quot;: &quot;Bullitt&quot;,</span><br><span class="hljs-comment">                &quot;released&quot;: 1968,</span><br><span class="hljs-comment">                &quot;color&quot;: true,</span><br><span class="hljs-comment">                &quot;Actors&quot;: [</span><br><span class="hljs-comment">                        &quot;Steve McQueen&quot;,</span><br><span class="hljs-comment">                        &quot;Jacqueline Bisset&quot;</span><br><span class="hljs-comment">                ]</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">]</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。<br><strong>只有导出的结构体成员才会被编码</strong>，这也就是我们为什么选择用大写字母开头的成员名称。</p><p>其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为构体成员<code>Tag</code>所导致的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">Year  <span class="hljs-type">int</span>  <span class="hljs-string">`json:&quot;released&quot;`</span><br>Color <span class="hljs-type">bool</span> <span class="hljs-string">`json:&quot;color,omitempty&quot;`</span><br></code></pre></td></tr></table></figure><p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含义双引号字符，因此成员Tag一般用原生字符串面值的形式书写。<br>json开头键名对应的值用于控制encoding&#x2F;json包的编码和解码的行为，并且encoding&#x2F;…下面其它的包也遵循这个约定。<br>成员的Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。<br>Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成JSON对象（这里false为零值）。</p><h2 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h2><p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫<code>unmarshaling</code>，通过<code>json.Unmarshal</code>函数完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> titles []<span class="hljs-keyword">struct</span>&#123; Title <span class="hljs-type">string</span> &#125;<br><span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;JSON unmarshaling failed:%s&quot;</span>, err)<br>&#125;<br>fmt.Println(titles) <span class="hljs-comment">// [&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]</span><br></code></pre></td></tr></table></figure><p>通过定义合适的Go语言数据结构，可以选择性地解码JSON中感兴趣的成员。<br>当Unmarshal函数返回时，slice将只含有Title信息值填充，其它的JSON成员将被忽略。</p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="Github的issue查询服务"><a href="#Github的issue查询服务" class="headerlink" title="Github的issue查询服务"></a>Github的issue查询服务</h2><p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。<br>定义合适的类型和常量：<br>github.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> github<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> IssuesURL = <span class="hljs-string">&quot;https://api.github.com/search/issues&quot;</span><br><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Login   <span class="hljs-type">string</span><br>HTMLURL <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;html_url&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Issue <span class="hljs-keyword">struct</span> &#123;<br>Number    <span class="hljs-type">int</span><br>HTMLURL   <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;html_url&quot;`</span><br>Title     <span class="hljs-type">string</span><br>State     <span class="hljs-type">string</span><br>User      *User<br>CreatedAt time.Time <span class="hljs-string">`json:&quot;created_at&quot;`</span><br>Body      <span class="hljs-type">string</span>    <span class="hljs-comment">// in Markdown format</span><br>&#125;<br><br><span class="hljs-keyword">type</span> IssuesSearchResult <span class="hljs-keyword">struct</span> &#123;<br>TotalCount <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;total_count&quot;`</span><br>Items      []*Issue<br>&#125;<br></code></pre></td></tr></table></figure><p>定义查询方法：<br>search.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> github<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;net/url&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-comment">// SearchIssues queries the GitHub issue tracker.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SearchIssues</span><span class="hljs-params">(terms []<span class="hljs-type">string</span>)</span></span> (*IssuesSearchResult, <span class="hljs-type">error</span>) &#123;<br>q := url.QueryEscape(strings.Join(terms, <span class="hljs-string">&quot;&quot;</span>))<br>resp, err := http.Get(IssuesURL + <span class="hljs-string">&quot;?q=&quot;</span> + q)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><br><span class="hljs-comment">// We must close resp.Body on all executing paths.</span><br><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;search query failed:%s&quot;</span>, resp.Status)<br>&#125;<br><br><span class="hljs-keyword">var</span> result IssuesSearchResult<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="hljs-literal">nil</span> &#123;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>resp.Body.Close()<br><span class="hljs-keyword">return</span> &amp;result, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编写主程序，包含输出请求结果：<br>issue&#x2F;main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch4/github&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// windows+label:bug</span><br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d issues:\n&quot;</span>, result.TotalCount)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> result.Items &#123;<br>fmt.Printf(<span class="hljs-string">&quot;#%-5d %9.9s %.55s\n&quot;</span>, item.Number, item.User.Login, item.Title)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过一下命令进行程序运行及输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build ./issues/main.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main.go windows+label:bug</span><br>649797 issues:<br><span class="hljs-meta prompt_">#</span><span class="language-bash">14     deondreE Windows Integration</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">11948  wujunwei fix: failed testcase on windows</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">20821  joker5bb Build fails on windows</span> <br><span class="hljs-meta prompt_">#</span><span class="language-bash">272    tieugene Windows issues</span><br>...<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 4.10：</strong>  修改issues程序，根据问题的时间进行分类，比如不到一个月的、不到一年的、超过一年。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch4/github&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> class <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>LTOM class = <span class="hljs-string">&quot;less than one month&quot;</span><br>MTOM class = <span class="hljs-string">&quot;more than one month&quot;</span><br>LTOY class = <span class="hljs-string">&quot;less than one year&quot;</span><br>MTOY class = <span class="hljs-string">&quot;more than one year&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br><br>issueClass := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[class][]github.Issue)<br><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> result.Items &#123;<br>item := *item<br>y, m, _ := item.CreatedAt.Date()<br>cy, cm, _ := time.Now().Date()<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> cm-m &lt;= time.Month(<span class="hljs-number">1</span>):<br>issueClass[LTOM] = <span class="hljs-built_in">append</span>(issueClass[LTOM], item)<br><span class="hljs-keyword">case</span> cm-m &gt; time.Month(<span class="hljs-number">1</span>):<br>issueClass[MTOM] = <span class="hljs-built_in">append</span>(issueClass[MTOM], item)<br><span class="hljs-keyword">case</span> cy-y &lt;= <span class="hljs-number">1</span>:<br>issueClass[LTOY] = <span class="hljs-built_in">append</span>(issueClass[LTOY], item)<br><span class="hljs-keyword">case</span> cy-y &gt; <span class="hljs-number">1</span>:<br>issueClass[MTOY] = <span class="hljs-built_in">append</span>(issueClass[MTOY], item)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> class, issues := <span class="hljs-keyword">range</span> issueClass &#123;<br>fmt.Printf(<span class="hljs-string">&quot;class: %s, issue: %v\n&quot;</span>, class, issues)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 4.11：</strong> 编写一个工具，允许用户在命令行创建、读取、更新和关闭GitHub上的issue，当必要的时候自动打开用户默认的编辑器用于输入文本信息。<br>解：<br>issue&#x2F;issue.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> issue<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Params <span class="hljs-keyword">struct</span> &#123;<br>Owner  <span class="hljs-type">string</span><br>Repo   <span class="hljs-type">string</span><br>Number <span class="hljs-type">string</span><br>Token  <span class="hljs-type">string</span><br>Issue<br>&#125;<br><br><span class="hljs-keyword">type</span> Issue <span class="hljs-keyword">struct</span> &#123;<br>Title <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;title&quot;`</span><br>Body  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;body&quot;`</span><br>&#125;<br><br><span class="hljs-keyword">const</span> baseURL = <span class="hljs-string">&quot;https://api.github.com/repos/&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Params)</span></span> GetIssues() ([]Issue, <span class="hljs-type">error</span>) &#123;<br>u := baseURL + p.Owner + <span class="hljs-string">&quot;/&quot;</span> + p.Repo + <span class="hljs-string">&quot;/issues&quot;</span><br>resp, err := http.Get(u)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-keyword">var</span> issues []Issue<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;issues); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> issues, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Params)</span></span> GetIssue() (Issue, <span class="hljs-type">error</span>) &#123;<br>u := baseURL + p.Owner + <span class="hljs-string">&quot;/&quot;</span> + p.Repo + <span class="hljs-string">&quot;/issue&quot;</span> + <span class="hljs-string">&quot;/&quot;</span> + p.Number<br>resp, err := http.Get(u)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> Issue&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-keyword">var</span> issue Issue<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;issue); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> Issue&#123;&#125;, err<br>&#125;<br><span class="hljs-keyword">return</span> issue, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Params)</span></span> CreateIssue() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">if</span> err := json.NewEncoder(&amp;buf).Encode(p.Issue); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>u := baseURL + p.Owner + <span class="hljs-string">&quot;/&quot;</span> + p.Repo + <span class="hljs-string">&quot;/issues&quot;</span> + <span class="hljs-string">&quot;?access_token&quot;</span> + p.Token<br>_, err := http.Post(u, <span class="hljs-string">&quot;application/json&quot;</span>, &amp;buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Params)</span></span> EditIssue() <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">if</span> err := json.NewEncoder(&amp;buf).Encode(p.Issue); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>u := baseURL + p.Owner + <span class="hljs-string">&quot;/&quot;</span> + p.Repo + <span class="hljs-string">&quot;/issues&quot;</span> + <span class="hljs-string">&quot;/&quot;</span> + p.Number + <span class="hljs-string">&quot;?access+token=&quot;</span> + p.Token<br>request, err := http.NewRequest(http.MethodPatch, u, &amp;buf)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>request.Header.Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>)<br>client := &amp;http.Client&#123;&#125;<br>_, err = client.Do(request)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex4.11/issue&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>create = flag.Bool(<span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>)<br>list   = flag.Bool(<span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>)<br>read   = flag.Bool(<span class="hljs-string">&quot;r&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>)<br>edit   = flag.Bool(<span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br>owner  = flag.String(<span class="hljs-string">&quot;owner&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>repo   = flag.String(<span class="hljs-string">&quot;repo&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>number = flag.String(<span class="hljs-string">&quot;number&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>token  = flag.String(<span class="hljs-string">&quot;token&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br>title = flag.String(<span class="hljs-string">&quot;title&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>body  = flag.String(<span class="hljs-string">&quot;body&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> *create:<br>p := issue.Params&#123;Owner: *owner,<br>Repo:  *repo,<br>Token: *token,<br>Issue: issue.Issue&#123;Title: *title, Body: *body&#125;&#125;<br><span class="hljs-keyword">if</span> !p.CreateIssue() &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;create issue fail&quot;</span>)<br>&#125;<br><span class="hljs-keyword">case</span> *list:<br>p := issue.Params&#123;Owner: *owner, Repo: *repo&#125;<br>issues, err := p.GetIssues()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err)<br>&#125;<br><span class="hljs-keyword">for</span> _, i := <span class="hljs-keyword">range</span> issues &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\t%s\n&quot;</span>, i.Title, i.Body)<br>&#125;<br><span class="hljs-keyword">case</span> *read:<br>p := issue.Params&#123;Owner: *owner, Repo: *repo, Number: *number&#125;<br>i, err := p.GetIssue()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprint(os.Stderr, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\t%s\n&quot;</span>, i.Title, i.Body)<br><span class="hljs-keyword">case</span> *edit:<br>p := issue.Params&#123;<br>Owner:  *owner,<br>Repo:   *repo,<br>Token:  *token,<br>Number: *number,<br>Issue:  issue.Issue&#123;Title: *token, Body: *body&#125;,<br>&#125;<br><span class="hljs-keyword">if</span> !p.EditIssue() &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;edit issue fail&quot;</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 4.12：</strong> 流行的web漫画服务xkcd也提供了JSON接口。例如，一个 <a href="https://xkcd.com/571/info.0.json">https://xkcd.com/571/info.0.json</a> 请求将返回一个很多人喜爱的571编号的详细描述。下载每个链接（只下载一次）然后创建一个离线索引。编写一个xkcd工具，使用这些离线索引，打印和命令行输入的检索词相匹配的漫画的URL。<br>解：<br>xkcd&#x2F;xkcd.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> xkcd<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>MinNum = <span class="hljs-number">1</span><br>MaxNum = <span class="hljs-number">2125</span><br>)<br><br><span class="hljs-keyword">type</span> comic <span class="hljs-keyword">struct</span> &#123;<br>Month      <span class="hljs-type">string</span><br>Num        <span class="hljs-type">int</span><br>Link       <span class="hljs-type">string</span><br>Year       <span class="hljs-type">string</span><br>News       <span class="hljs-type">string</span><br>SafeTitle  <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;sale_title&quot;`</span><br>Transcript <span class="hljs-type">string</span><br>Alt        <span class="hljs-type">string</span><br>Img        <span class="hljs-type">string</span><br>Title      <span class="hljs-type">string</span><br>Day        <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *comic)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;Comic: %d\n&quot;</span>, c.Num) +<br>fmt.Sprintf(<span class="hljs-string">&quot;Image: %s\n&quot;</span>, c.Img) +<br>fmt.Sprintf(<span class="hljs-string">&quot;Transcript: %s\n&quot;</span>, c.Transcript)<br>&#125;<br><br><span class="hljs-keyword">type</span> Index <span class="hljs-keyword">struct</span> &#123;<br>Comic []*comic<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">()</span></span> Index &#123;<br><span class="hljs-keyword">return</span> Index&#123;[]*comic&#123;&#125;&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Get</span><span class="hljs-params">(num <span class="hljs-type">int</span>)</span></span> (*comic, <span class="hljs-type">error</span>) &#123;<br>url := <span class="hljs-string">&quot;https://xkcd.com/&quot;</span> + strconv.Itoa(num) + <span class="hljs-string">&quot;/info.0.json&quot;</span><br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><span class="hljs-keyword">var</span> comic comic<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;comic); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> &amp;comic, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Search</span><span class="hljs-params">(index Index, keywords []<span class="hljs-type">string</span>)</span></span> []*comic &#123;<br><span class="hljs-keyword">var</span> result []*comic<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> index.Comic &#123;<br>isMatch := <span class="hljs-literal">true</span><br><span class="hljs-keyword">for</span> _, term := <span class="hljs-keyword">range</span> keywords &#123;<br><span class="hljs-keyword">if</span> !match(c, term) &#123;<br>isMatch = <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> isMatch &#123;<br>result = <span class="hljs-built_in">append</span>(result, c)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">match</span><span class="hljs-params">(c *comic, keyword <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> strings.Contains(c.Month, keyword) ||<br>strings.Contains(strconv.Itoa(c.Num), keyword) ||<br>strings.Contains(c.Link, keyword) ||<br>strings.Contains(c.Year, keyword) ||<br>strings.Contains(c.News, keyword) ||<br>strings.Contains(c.SafeTitle, keyword) ||<br>strings.Contains(c.Transcript, keyword) ||<br>strings.Contains(c.Alt, keyword) ||<br>strings.Contains(c.Img, keyword) ||<br>strings.Contains(c.Title, keyword) ||<br>strings.Contains(c.Day, keyword)<br>&#125;<br></code></pre></td></tr></table></figure><p>main.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex4/ex4.12/xkcd&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>f = flag.Bool(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>)<br>n = flag.Int(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-number">100</span>, <span class="hljs-string">&quot;&quot;</span>)<br>)<br><br><span class="hljs-comment">// fetch: go run main.go -f -n=100 &gt; in.json</span><br><span class="hljs-comment">// search: cat in.json | go run main.go keywords</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> *f &#123;<br><span class="hljs-keyword">if</span> *n &gt; xkcd.MaxNum &#123;<br>log.Fatalf(<span class="hljs-string">&quot;%d can&#x27;t bigger than %d&quot;</span>, *n, xkcd.MaxNum)<br>&#125;<br>fetch(*n)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>search(flag.Args())<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> &#123;<br>index := xkcd.New()<br><span class="hljs-keyword">for</span> num := xkcd.MinNum; num &lt; n; num++ &#123;<br>c, err := xkcd.Get(num)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>index.Comic = <span class="hljs-built_in">append</span>(index.Comic, c)<br>&#125;<br>out, err := json.MarshalIndent(index, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;   &quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(keywords []<span class="hljs-type">string</span>)</span></span> &#123;<br>in, err := io.ReadAll(os.Stdin)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>index := xkcd.New()<br><span class="hljs-keyword">if</span> err := json.Unmarshal(in, &amp;index); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(err)<br>&#125;<br>resul := xkcd.Search(index, keywords)<br><span class="hljs-keyword">for</span> _, c := <span class="hljs-keyword">range</span> resul &#123;<br>fmt.Println(c)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 4.13：</strong> 使用开放电影数据库的JSON服务接口，允许你检索和下载 <a href="https://omdbapi.com/">https://omdbapi.com/</a> 上电影的名字和对应的海报图像。编写一个poster工具，通过命令行输入的电影名字，下载对应的海报。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>url2 <span class="hljs-string">&quot;net/url&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>title  = flag.String(<span class="hljs-string">&quot;t&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>apikey = flag.String(<span class="hljs-string">&quot;apikey&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>)<br><br><span class="hljs-keyword">const</span> api = <span class="hljs-string">&quot;https://www.omdbapi.com/&quot;</span><br><br><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;<br>PosterURL <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;Poster&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>url := api + <span class="hljs-string">&quot;?t=&quot;</span> + url2.QueryEscape(*title) + <span class="hljs-string">&quot;&amp;apikey=&quot;</span> + url2.QueryEscape(*apikey)<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;http get url: %v fail. err: %v&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br><br><span class="hljs-keyword">var</span> res result<br><span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;res); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;json decode fail. err: %v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><br>poster, err := http.Get(res.PosterURL)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;http get poster url: %v fail. err: %v&quot;</span>, res.PosterURL, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> poster.Body.Close()<br><br>f, err := os.Create(*title + <span class="hljs-string">&quot;.jpeg&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;create file fail. err: %v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> f.Close()<br><br>_, err = io.Copy(f, poster.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;io copy fail. err：%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.4. Struct</title>
      <link href="/posts/556653fe988e/"/>
      <url>/posts/556653fe988e/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>下面例子声明了经典的员工信息Employee的结构类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;<br>ID        <span class="hljs-type">int</span><br>Name      <span class="hljs-type">string</span><br>Address   <span class="hljs-type">string</span><br>DoB       time.Time<br>Position  <span class="hljs-type">string</span><br>Salary    <span class="hljs-type">int</span><br>ManagerID <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> dilbert Employee<br></code></pre></td></tr></table></figure><p>结构体成员变量的输入顺序不同，就定义了不同的结构体类型，通常情况下，可以把相同类型的成员变量写到一起。</p><p>如果结构体成员变量以大写字母开头，那么该成员是导出的；一个结构体可能同时包含导出和未导出的成员变量。</p><p>结构体的成员变量不能包含其自身，和数组一样。但结构体的成员变量可以包含其指针类型的成员变量。</p><p>结构体类型的零值是每个成员变量都是零值。<br>当声明一个结构体变量时，其实初始化为零值的结构体：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> e Employee<br>fmt.Println(e) <span class="hljs-comment">// &#123;0   0001-01-01 00:00:00 +0000 UTC  0 0&#125;</span><br></code></pre></td></tr></table></figure><p>空结构体没有任何成员变量，写作<code>struct&#123;&#125;</code>，大小为0，也不包含任何信息，常用作map模拟set数据结构是，用于替代value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-comment">// set of strings</span><br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">if</span> _, ok := seen[s]; !ok &#123;<br>seen[s] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// first time seeing ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h1><p>结构体成员变量可以通过点操作符访问，如<code>dilbert.Name</code>。<br>因为<code>dilbert</code>是一个变量，其所有的成员也是变量，即可以对每个成员变量赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">dilbert.Salary = <span class="hljs-number">30000</span><br></code></pre></td></tr></table></figure><p>也可以对成员取址，通过指针访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">position := &amp;dilbert.Position<br>*position = <span class="hljs-string">&quot;Senior&quot;</span> + *position<br></code></pre></td></tr></table></figure><p>点操作符也可以和指针结合：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbert<br>employeeOfTheMonth.Position += <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>简化成下面语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">(*employeeOfTheMonth).Position += <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h1 id="结构体作为函数的参数和返回值"><a href="#结构体作为函数的参数和返回值" class="headerlink" title="结构体作为函数的参数和返回值"></a>结构体作为函数的参数和返回值</h1><p>结构体可以作为函数的参数和返回值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Scale</span><span class="hljs-params">(p Point, factor <span class="hljs-type">int</span>)</span></span> Point &#123;<br><span class="hljs-keyword">return</span> Point&#123;p.X * factor, p.Y * factor&#125;<br>&#125;<br>fmt.<span class="hljs-built_in">println</span>(Scale(Point&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;, <span class="hljs-number">5</span>)) <span class="hljs-comment">// &#123;5, 10&#125;</span><br></code></pre></td></tr></table></figure><p>如果考虑性能效率，较大的结构体通常会用指针的方式传入和返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Bonus</span><span class="hljs-params">(e *Employee, percent <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> e.Salary * percent / <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Go语言中，所有函数参数都是值拷贝出入，函数参数将不再是函数调用时的原始变量。所以要在函数内部修改结构体成员的话，用指针传入是必须的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AwardAnnualRaise</span><span class="hljs-params">(e *Employee)</span></span> &#123;<br>e.Salary = e.Salay * <span class="hljs-number">105</span> / <span class="hljs-number">100</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二叉树的插入排序"><a href="#二叉树的插入排序" class="headerlink" title="二叉树的插入排序"></a>二叉树的插入排序</h1><p>结构体类型可以包含其自身指针，那么就可以创建递归的数据结构，如链表和树结构。<br>下面使用一个二叉树来实现插入排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>Sort(s)<br>fmt.Println(s) <span class="hljs-comment">// [1 2 3 4 6]</span><br>&#125;<br><br><span class="hljs-keyword">type</span> tree <span class="hljs-keyword">struct</span> &#123;<br>value       <span class="hljs-type">int</span><br>left, right *tree<br>&#125;<br><br><span class="hljs-comment">// Sort sorts values in place.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sort</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">var</span> root *tree<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> values &#123;<br>root = add(root, v)<br>&#125;<br>appendValues(values[:<span class="hljs-number">0</span>], root)<br>&#125;<br><br><span class="hljs-comment">// appendValues appends the elements of t to values in order</span><br><span class="hljs-comment">// and returns the resulting slice.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendValues</span><span class="hljs-params">(values []<span class="hljs-type">int</span>, t *tree)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> t != <span class="hljs-literal">nil</span> &#123;<br>values = appendValues(values, t.left)<br>values = <span class="hljs-built_in">append</span>(values, t.value)<br>values = appendValues(values, t.right)<br>&#125;<br><span class="hljs-keyword">return</span> values<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(t *tree, value <span class="hljs-type">int</span>)</span></span> *tree &#123;<br><span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// Equivalent to return &amp;tree&#123;value:value&#125;.</span><br>t = <span class="hljs-built_in">new</span>(tree)<br>t.value = value<br><span class="hljs-keyword">return</span> t<br>&#125;<br><span class="hljs-keyword">if</span> value &lt; t.value &#123;<br>t.left = add(t.left, value)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>t.right = add(t.right, value)<br>&#125;<br><span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-4-1-结构体面值"><a href="#4-4-1-结构体面值" class="headerlink" title="4.4.1. 结构体面值"></a>4.4.1. 结构体面值</h1><p>结构体值也可以用结构体面值表示，指定每个成员变量的值。<br>以结构体成员声明的顺序为每个结构体成员变量赋值，一般用于定义结构体的包内部使用，或小的结构体中使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X,Y <span class="hljs-type">int</span>&#125;<br>p := Point&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>更常用的写法，以成员变量名字和相应的值来初始化，可以包含部分或全部的成员变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">anim := gif.GIF&#123;LoopCount: nframes&#125;<br></code></pre></td></tr></table></figure><p>在这种结构体面值写法中，如果成员变量被忽略将默认使用相对应类型的零值。<br>两种写法不能混用！</p><p>结构体内的命名首字母为小写字母的成员变量，将不能在其他包内导出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> p<br><span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span>&#123; a, b <span class="hljs-type">int</span> &#125; <span class="hljs-comment">// a and b are not exported</span><br><br><span class="hljs-keyword">package</span> q<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;p&quot;</span><br><span class="hljs-keyword">var</span> _ = p.T&#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125; <span class="hljs-comment">// compile error: can&#x27;t reference a, b</span><br><span class="hljs-keyword">var</span> _ = p.T&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;       <span class="hljs-comment">// compile error: can&#x27;t reference a, b</span><br></code></pre></td></tr></table></figure><p>结构体还可以通过指针处理，可以用下面的写法来创建并初始化一个结构体变量，并返回结构体的地址：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">pp := &amp;Point&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">pp := <span class="hljs-built_in">new</span>(Point)<br>*pp = Point&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></td></tr></table></figure><p>·<code>&amp;Point&#123;1,2&#125;</code>写法可以直接在表达式中使用，如函数调用。</p><h1 id="4-4-2-结构体比较"><a href="#4-4-2-结构体比较" class="headerlink" title="4.4.2. 结构体比较"></a>4.4.2. 结构体比较</h1><p>如果结构体的全部成员变量都是可以比较的，那么结构体也是可以比较的。<br>可以使用了<code>==</code>或<code>!=</code>运算符进行比较，将比较两个结构体的每个成员。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">int</span> &#125;<br><br>p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>q := Point&#123;<span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<br>fmt.Println(p.X == q.X &amp;&amp; p.Y == q.Y) <span class="hljs-comment">// false</span><br>fmt.Println(p == q)                   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>可比较的结构体类型和其他可比较的类型一样，可以用于map的key类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> address <span class="hljs-keyword">struct</span> &#123;<br>hostname <span class="hljs-type">string</span><br>port     <span class="hljs-type">int</span><br>&#125;<br><br>hits := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[address]<span class="hljs-type">int</span>)<br>hits[address&#123;<span class="hljs-string">&quot;golang.org&quot;</span>, <span class="hljs-number">443</span>&#125;]++<br></code></pre></td></tr></table></figure><h1 id="4-4-3-结构体嵌入和匿名成员"><a href="#4-4-3-结构体嵌入和匿名成员" class="headerlink" title="4.4.3. 结构体嵌入和匿名成员"></a>4.4.3. 结构体嵌入和匿名成员</h1><p>Go语言提供的不同寻常的结构体嵌入机制让一个命名的结构体包含另一个结构体类型的匿名成员，这样就可以通过简单的点运算符x.f来访问匿名成员链中嵌套的x.d.e.f成员。</p><p>如一个二维的绘图程序，提供了各种图形的库，如矩形、椭圆等几何形状：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>X, Y, Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>X, Y, Radius, Spokes <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由上代码可知，Circle代表的圆形类型包含了标准圆心的X和Y坐标信息，和Radius表示的半价信息。Wheel轮形除了包含Circle类型所有的全部成员外，还增加了Spokes表示径向辐条的数量。可以创建一个Wheel变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w Wheel<br>w.X = <span class="hljs-number">8</span><br>w.Y = <span class="hljs-number">8</span><br>w.Radius = <span class="hljs-number">5</span><br>w.Spokes = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>随着几何形状数量最多，它们之间重复的属性，可以将其独立出来：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>Center Point<br>Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>Circle Circle<br>Spokes <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然改动后结构体类型变得清晰了，但是访问成员变量变得繁琐了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w Wheel<br>w.Circle.Center.X = <span class="hljs-number">8</span><br>w.Circle.Center.Y = <span class="hljs-number">8</span><br>w.Circle.Radius = <span class="hljs-number">5</span><br>w.Spokes = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>Go语言有一个特性让只声明一个成员对应的数据类型而不指明成员变量的名字，这类成员叫做<code>匿名成员</code>。<br>匿名成员的数据类型必须是命名的类型或指向一个命名的类型或指针。<br>下面的代码中，Circle和Wheel各自拥有一个匿名成员，Point类型被嵌入到了Circle结构体，Circle类型被嵌入到了Wheel结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-type">int</span> &#125;<br><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>Point<br>Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>Circle<br>Spokes <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于匿名嵌入的特性，可以直接访问叶子属性而不需要给出完整的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> w Wheel<br>w.X = <span class="hljs-number">8</span> <span class="hljs-comment">// 相当于w.Circle.Center.X = 8</span><br>w.Y = <span class="hljs-number">8</span> <span class="hljs-comment">// 相当于w.Circle.Center.Y = 8</span><br>w.Radius = <span class="hljs-number">5</span> <span class="hljs-comment">// 相当于w.Circle.Radius = 5</span><br>w.Spokes = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>右边注释中的显式形式访问叶子成员的语法依然有效，匿名成员的名字就是命名的类型名字。如匿名成员Circle和Point都有自己的名字Circle和Point。</p><p>但要注意的是，结构体字面值并没有简短表示匿名成员的语法，下面的语句是不能编译通过的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">w = Wheel&#123;<span class="hljs-number">8</span>, <span class="hljs-number">8</span>, <span class="hljs-number">5</span>, <span class="hljs-number">20</span>&#125;                       <span class="hljs-comment">// compile error: unknown fields</span><br>w = Wheel&#123;X: <span class="hljs-number">8</span>, Y: <span class="hljs-number">8</span>, Radius: <span class="hljs-number">5</span>, Spokes: <span class="hljs-number">20</span>&#125; <span class="hljs-comment">// compile error: unknown fields</span><br></code></pre></td></tr></table></figure><p>结构体字面值必须遵循形状类型声明时的结构，所以我们只能用下面的两种语法，它们彼此是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Circle <span class="hljs-keyword">struct</span> &#123;<br>Point<br>Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>Circle<br>Spokes <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>w := Wheel&#123;Circle&#123;Point&#123;<span class="hljs-number">8</span>, <span class="hljs-number">8</span>&#125;, <span class="hljs-number">5</span>&#125;, <span class="hljs-number">20</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, w) <span class="hljs-comment">// main.Wheel&#123;Circle:main.Circle&#123;Point:main.Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span><br><br>w = Wheel&#123;<br>Circle: Circle&#123;<br>Point:  Point&#123;X: <span class="hljs-number">8</span>, Y: <span class="hljs-number">8</span>&#125;,<br>Radius: <span class="hljs-number">5</span>,<br>&#125;,<br>Spokes: <span class="hljs-number">20</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, w) <span class="hljs-comment">// main.Wheel&#123;Circle:main.Circle&#123;Point:main.Point&#123;X:8, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span><br><br>w.X = <span class="hljs-number">42</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, w) <span class="hljs-comment">// main.Wheel&#123;Circle:main.Circle&#123;Point:main.Point&#123;X:42, Y:8&#125;, Radius:5&#125;, Spokes:20&#125;</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>Printf</code>函数中<code>%v</code>参数包含的<code>#</code>副词，它表示用和Go语言类似的语法打印值。对于结构体类型来说，将包含每个成员的名字。</p><p>因为匿名成员也有一个隐式的名字，所以不能同时包含两个类型相同的匿名成员，否则会导致名字冲突。<br>即使成员的名字都是有其类型隐式地决定的，所有匿名成员也有可见性，即Point和Circle匿名成员都是导出的。<br>如果把Point和Circle两个类型改成小写字母开头的point和circle，在包内依然可以使用简短方式访问匿名成员嵌套的成员：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> point <span class="hljs-keyword">struct</span> &#123;<br>X, Y <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> circle <span class="hljs-keyword">struct</span> &#123;<br>point<br>Radius <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">type</span> Wheel <span class="hljs-keyword">struct</span> &#123;<br>circle<br>Spokes <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-keyword">var</span> w Wheel<br>w.X = <span class="hljs-number">8</span><br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, w)  <span class="hljs-comment">// main.Wheel&#123;circle:main.circle&#123;point:main.point&#123;X:8, Y:0&#125;, Radius:0&#125;, Spokes:0&#125;</span><br></code></pre></td></tr></table></figure><p>在包外部，因为circle和point类型没有导出，就不能使用简短的匿名成员访问。</p><p>简短的点运算符语法不仅可以用于访问匿名成员嵌套的成员，还可以访问它的方法。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.3. Map</title>
      <link href="/posts/610def108dde/"/>
      <url>/posts/610def108dde/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>哈希表是一个<strong>无序</strong>的<code>key/value</code>对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。<br><code>map</code>是哈希表的引用，<code>map</code>类型写法：<code>map[K]V</code>，K为key，V为value。<br>所有key都是相同类型，value也都是相同类型，但key和value之间可以是不同的数据类型。<br>key必须是支持<code>==</code>比较运算符的数据类型，所以<code>map</code>可以通过比较key是否相等来判断key是否存在。<br><code>slice</code>不能当key，因为其不支持<code>==</code>比较运算符。<br>虽然浮点数类型支持<code>==</code>比较运算符，但是可能出现<code>NaN</code>和任何浮点数（包括自身）都不相等，所以浮点数最好不能为key。<br>对于value数据类型则没有任何限制。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="字面值创建"><a href="#字面值创建" class="headerlink" title="字面值创建"></a>字面值创建</h2><p>指定最初的<code>key\value</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">ages := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;<br><span class="hljs-string">&quot;alice&quot;</span>:   <span class="hljs-number">31</span>,<br><span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">21</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="内置make创建"><a href="#内置make创建" class="headerlink" title="内置make创建"></a>内置make创建</h2><p>内置的<code>make</code>函数可以创建<code>map</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">31</span><br>ages[<span class="hljs-string">&quot;charlie&quot;</span>] = <span class="hljs-number">21</span><br></code></pre></td></tr></table></figure><p>另一种创建空的<code>map</code>的方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ages := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br></code></pre></td></tr></table></figure><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>取值、存值、删除这些操作都是安全的，即使<code>key</code>不存在。</p><h2 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h2><p>通过key对应的下标语法访问：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(ages[<span class="hljs-string">&quot;alice&quot;</span>]) <span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><p>当<code>key</code>不存在，返回的<code>value</code>为<code>value</code>对应类型的零值。如<code>int</code>返回0。</p><p>但需要知道<code>map</code>中是否存在该键值对时或返回的值是已存在的0还是不存在而返回的零值0，可以通过以下操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">age, ok := ages[<span class="hljs-string">&quot;bob&quot;</span>]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-comment">/* &quot;bob&quot; is not a key in this map; age == 0.*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>也可以进行结合简化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> age, ok := ages[<span class="hljs-string">&quot;bob&quot;</span>]; !ok &#123;<br><span class="hljs-comment">/* &quot;bob&quot; is not a key in this map; age == 0.*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>map</code>的下标语法将产生两个值；第二个是一个布尔值，用于报告元素是否真的存在。布尔变量一般命名为<code>ok</code>，特别适合马上用于<code>if</code>条件判断部分。</p><p><code>map</code>中的<code>value</code>并不是变量，因此不能对<code>map</code>的值进行取址操作：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">_ = &amp;ages[<span class="hljs-string">&quot;bob&quot;</span>] <span class="hljs-comment">// invalid operation: cannot take address of ages[&quot;bob&quot;] (map index expression of type int)</span><br></code></pre></td></tr></table></figure><p>原因：<code>map</code>可能随着键值对的数量增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</p><h2 id="存入键值对"><a href="#存入键值对" class="headerlink" title="存入键值对"></a>存入键值对</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">31</span><br>ages[<span class="hljs-string">&quot;charlie&quot;</span>] = <span class="hljs-number">34</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>使用内置的<code>delete</code>函数删除k\v：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">delete</span>(ages, <span class="hljs-string">&quot;alice&quot;</span>)<br></code></pre></td></tr></table></figure><p>当<code>key</code>不存在时，删除操作同样不会出现异常。</p><h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> ages &#123;<br>fmt.Printf(<span class="hljs-string">&quot;key:%s\tvalue:%d\n&quot;</span>, key, value)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>map</code>的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。所以遍历的顺序是随机的，每一次遍历的顺序都不相同。</p><p>如果要求按顺序遍历<code>key/value</code>对，可以显式对应<code>key</code>进行排序：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> name := <span class="hljs-keyword">range</span> ages &#123;<br>names = <span class="hljs-built_in">append</span>(names, name)<br>&#125;<br>sort.Strings(names)<br><span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span>  names &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, ages[name])<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="map的零值"><a href="#map的零值" class="headerlink" title="map的零值"></a>map的零值</h1><p><code>map</code>类型的零值是<code>nil</code>，也就是没有引用任何哈希表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ages <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>fmt.Println(ages == <span class="hljs-literal">nil</span>)    <span class="hljs-comment">// true</span><br>fmt.Println(<span class="hljs-built_in">len</span>(ages) == <span class="hljs-number">0</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>nil</code>值的<code>map</code>进行查找、删除、len和range循环等大部分操作都是安全的，与空的<code>map</code>类似。<br>但向<code>nil</code>值的<code>map</code>存入键值对将导致<code>panic</code>异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ages <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span><br>ages[<span class="hljs-string">&quot;carol&quot;</span>] = <span class="hljs-number">21</span> <span class="hljs-comment">// panic: assignment to entry in nil map</span><br></code></pre></td></tr></table></figure><p>所以在向<code>map</code>存储键值对前必须先创建<code>map</code>。</p><h1 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h1><p>和<code>slice</code>一样，<code>map</code>之间也不能进行相等比较；<br>唯一的例外是可以和<code>nil</code>进行相等比较。<br>要判断两个map是否包含相同的key和value，我们必须通过一个循环实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(x) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> k, xv := <span class="hljs-keyword">range</span> x &#123;<br><span class="hljs-keyword">if</span> yv, ok := y[k]; !ok || xv != yv &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="dedup去重"><a href="#dedup去重" class="headerlink" title="dedup去重"></a>dedup去重</h2><p>Go语言中并没有提供set类型，但可以通过<code>map</code>去实现类似功能。<br>下面的dedup程序读取多行输入，但是只打印第一次出现的行。（它是1.3节中出现的dup程序的变体。）dedup程序通过map来表示所有的输入行所对应的set集合，以确保已经在集合存在的行不会被重复打印。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>text := input.Text()<br><span class="hljs-keyword">if</span> !seen[text] &#123;<br>seen[text] = <span class="hljs-literal">true</span><br>fmt.Println(text)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> err := input.Err(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dedup: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>终端中输入文件结束符（EOF，end of file）:</p><ul><li>windows终端，键入<code>ctrl+Z</code></li><li>Linux&#x2F;Mac终端中，键入<code>ctrl+D</code></li></ul><h2 id="统计相同的字符串"><a href="#统计相同的字符串" class="headerlink" title="统计相同的字符串"></a>统计相同的字符串</h2><p>下面的例子演示了如何使用map来记录提交相同的字符串列表的次数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;<br>Add(s)<br>Add(s)<br>Add(s)<br>fmt.Println(Count(s)) <span class="hljs-comment">// 3</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">k</span><span class="hljs-params">(list []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%q&quot;</span>, list)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Add</span><span class="hljs-params">(list []<span class="hljs-type">string</span>)</span></span> &#123;<br>m[k(list)]++<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(list []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> m[k(list)]<br>&#125;<br></code></pre></td></tr></table></figure><p>不可比较的key类型，可以通过k函数，进行转换成可比较的类型。还可以在比较字符串时候忽略大小写等。</p><h2 id="统计Unicode码点出现次数"><a href="#统计Unicode码点出现次数" class="headerlink" title="统计Unicode码点出现次数"></a>统计Unicode码点出现次数</h2><p>下面的程序用于统计输入中每个Unicode码点出现的次数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Charcount computes counts of Unicode characters.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;unicode&quot;</span><br><span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>)    <span class="hljs-comment">// counts of Unicode characters</span><br><span class="hljs-keyword">var</span> utflen [utf8.UTFMax + <span class="hljs-number">1</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// count of lengths of UTF-8 encodings</span><br>invalid := <span class="hljs-number">0</span>                    <span class="hljs-comment">// count of invalid UTF-8 characters</span><br><br>in := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">for</span> &#123;<br>r, n, err := in.ReadRune() <span class="hljs-comment">// returns rune,nbytes,error</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;charcount: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">if</span> r == unicode.ReplacementChar &amp;&amp; n == <span class="hljs-number">1</span> &#123;<br>invalid++<br><span class="hljs-keyword">continue</span><br>&#125;<br>counts[r]++<br>utflen[n]++<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;rune\tcount\n&quot;</span>)<br><span class="hljs-keyword">for</span> c, n := <span class="hljs-keyword">range</span> counts &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%q\t%d\n&quot;</span>, c, n)<br>&#125;<br>fmt.Print(<span class="hljs-string">&quot;\nlen\tcount\n&quot;</span>)<br><span class="hljs-keyword">for</span> i, n := <span class="hljs-keyword">range</span> utflen &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%d\n&quot;</span>, i, n)<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> invalid &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;\n%d invalid UTF-8 characters\n&quot;</span>, invalid)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在终端输入后回车，就能继续运行<code>r, n, err := in.ReadRune()</code>及其后面的代码。当检测到有非法utf8字符（如文件结尾）时就会break跳出循环，并打印统计数据。</p><h2 id="聚合类型的value"><a href="#聚合类型的value" class="headerlink" title="聚合类型的value"></a>聚合类型的value</h2><p>在下面的代码中，图graph的key类型是一个字符串，value类型map[string]bool代表一个字符串集合。从概念上将，graph将一个字符串类型的key映射到一组相关的字符串集合，它们指向新的graph的key。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">var</span> graph = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>addEdge(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>)<br>fmt.Println(graph)             <span class="hljs-comment">// map[A:map[b:true]]</span><br>fmt.Println(hasEdge(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>)) <span class="hljs-comment">// false</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addEdge</span><span class="hljs-params">(from, to <span class="hljs-type">string</span>)</span></span> &#123;<br>edges := graph[from]<br><span class="hljs-keyword">if</span> edges == <span class="hljs-literal">nil</span> &#123;<br>edges = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>)<br>graph[from] = edges<br>&#125;<br>edges[to] = <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hasEdge</span><span class="hljs-params">(from, to <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> graph[from][to]<br>&#125;<br></code></pre></td></tr></table></figure><p>其中addEdge函数惰性初始化map是一个惯用方式，也就是说在每个值首次作为key时才初始化。addEdge函数显示了如何让map的零值也能正常工作；即使from到to的边不存在，graph[from][to]依然可以返回一个有意义的结果。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 4.8：</strong> 修改charcount程序，使用unicode.IsLetter等相关的函数，统计字母、数字等Unicode中不同的字符类别。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;unicode&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> class <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>letter  class = <span class="hljs-string">&quot;letter&quot;</span><br>number  class = <span class="hljs-string">&quot;number&quot;</span><br>graphic class = <span class="hljs-string">&quot;graphic&quot;</span><br>space   class = <span class="hljs-string">&quot;space&quot;</span><br>symbol  class = <span class="hljs-string">&quot;symbol&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>classCount := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[class]<span class="hljs-type">int</span>, <span class="hljs-number">5</span>)<br>in := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">for</span> &#123;<br>r, _, err := in.ReadRune()<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> unicode.IsLetter(r):<br>classCount[letter]++<br><span class="hljs-keyword">case</span> unicode.IsNumber(r):<br>classCount[number]++<br><span class="hljs-keyword">case</span> unicode.IsGraphic(r):<br>classCount[graphic]++<br><span class="hljs-keyword">case</span> unicode.IsSpace(r):<br>classCount[space]++<br><span class="hljs-keyword">case</span> unicode.IsSymbol(r):<br>classCount[symbol]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> class, count := <span class="hljs-keyword">range</span> classCount &#123;<br>fmt.Printf(<span class="hljs-string">&quot;class: %s, count = %d\n&quot;</span>, class, count)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 4.9：</strong> 编写一个程序wordfreq程序，报告输入文本中每个单词出现的频率。在第一次调用Scan前先调用input.Split(bufio.ScanWords)函数，这样可以按单词而不是按行输入。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wordCount := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>input := bufio.NewScanner(os.Stdin)<br>input.Split(bufio.ScanWords)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>wordCount[input.Text()]++<br>&#125;<br><span class="hljs-keyword">for</span> word, count := <span class="hljs-keyword">range</span> wordCount &#123;<br>fmt.Printf(<span class="hljs-string">&quot;word: %s, count= %d\n&quot;</span>, word, count)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.2. Slice</title>
      <link href="/posts/53445ef771d8/"/>
      <url>/posts/53445ef771d8/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p><code>Slice</code>（切片）代表变长的序列，序列中每个元素都是相同的类型。<br><code>slice</code>类型一般写法<code>[]T</code>，其中<code>T</code>代表<code>slice</code>中元素的类型。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><h2 id="字面值初始化"><a href="#字面值初始化" class="headerlink" title="字面值初始化"></a>字面值初始化</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br></code></pre></td></tr></table></figure><p>与数组字面值初始化很相似，但<code>slice</code>字面值初始化没有指明序列长度。<br><code>slice</code>会隐式创建合适大小的数组，然后<code>slice</code>的指针指向底层的数组。</p><h2 id="使用make创建"><a href="#使用make创建" class="headerlink" title="使用make创建"></a>使用make创建</h2><p>内置的<code>make</code>函数创建指定元素类型、长度和容量的<code>slice</code>。容量可以省略，这种情况，容量等于长度。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>)<br><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>) <span class="hljs-comment">// same as make([]T, cap)[:len]</span><br></code></pre></td></tr></table></figure><p>在底层，<code>make</code>创建了一个匿名的数组变量，然后返回一个<code>slice</code>;<br>只有通过返回的<code>slice</code>才能引用底层匿名的数组变量。<br>在第一种语句中，<code>slice</code>是指向整个数组。<br>在第二种语句中，<code>slice</code>只引用了底层数组的前len个元素，但容量包含整个数组。<br>额外的元素留作动态增长。</p><h1 id="切片操作"><a href="#切片操作" class="headerlink" title="切片操作"></a>切片操作</h1><p><code>slice</code>的切片操作<code>s[i:j]</code>，其中<code>0 ≤ i≤ j≤ cap(s)</code>，用于创建一个新的<code>slice</code>。<br>新的<code>slice</code>将只有<code>j-i</code>个元素，从第<code>i</code>个元素开始到第<code>j-1</code>个元素的子序列，并不包含第<code>j</code>个元素。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a := months[<span class="hljs-number">4</span>:<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><code>slice</code>类型的切片操作都是返回原序列的子序列，底层都是共享之前的底层数组。</p><h1 id="与数组的关系"><a href="#与数组的关系" class="headerlink" title="与数组的关系"></a>与数组的关系</h1><p><code>slice</code>的语法和数组类型，只是没有固定长度而已。<br><code>slice</code>是轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且<code>slice</code>的底层确实引用一个数组对象。<br><code>slice</code>由三个部分构成：<code>指针</code>、<code>长度</code>和<code>容量</code>。<br><code>指针</code>指向<code>slice</code>第一个元素对应的底层数组元素的地址，但<code>slice</code>的第一个元素并不一定就是数组的第一个元素。<br><code>长度</code>对应<code>slice</code>中元素的数量。内置的<code>len</code>函数返回<code>slice</code>的长度。<br><code>容量</code>一般是从<code>slice</code>的开始位置到底层数据的结尾位置。内置的<code>cap</code>函数返回<code>slice</code>的容量。</p><p>多个<code>slice</code>之间可以共享底层的数据，并且引用的数组部分区间可能重叠。<br><img src="/4.2.%20Slice/1680282900447.png" alt="enter description here"></p><p>与数组不同的是，<code>slice</code>之间不能比较，即不能使用<code>==</code>操作符去判断两个<code>slice</code>是否含有全部相等元素。<br>但<code>[]byte</code>的可以使用<code>bytes.Equal</code>函数来判断两个字节型<code>slice</code>是否相等。<br>其他类型，必须展开每个元素进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(y) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> x &#123;<br><span class="hljs-keyword">if</span> x[i] != y[i] &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><p>两个<code>slice</code>相等的测试，运行时间并不比数组或字符串的比较长，但为什么<code>slice</code>不直接支持比较运算符呢？</p><ul><li><code>slice</code>的元素是简接引用的，甚至可以保护自身。</li><li>因为<code>slice</code>的元素是简接引用，所以固定值的<code>slice</code>在不同时间内可能包含不同的元素，因为底层数组的元素可能会被修改。</li></ul><h1 id="与nil比较"><a href="#与nil比较" class="headerlink" title="与nil比较"></a>与nil比较</h1><p><code>slice</code>唯一合法的比较是和<code>nil</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> summer == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>一个零值的slice等于nil。</strong><br><strong>一个nil值的slice没有底层数组。</strong><br><strong>一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，如<code>[]int&#123;&#125;</code>或<code>make([]int,3)[3:]</code>。</strong><br>与任意类型的nil值一样，可以用<code>[]int(nil)</code>类型转换表达式来生成一个对应类型slice的nil值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span> <span class="hljs-comment">// len(s)==0, s==nil</span><br>s = <span class="hljs-literal">nil</span><span class="hljs-comment">// len(s)==0, s==nil</span><br>s = []<span class="hljs-type">int</span>(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// len(s)==0, s==nil</span><br>s = []<span class="hljs-type">int</span>&#123;&#125; <span class="hljs-comment">// len(s)==0, s!=nil</span><br></code></pre></td></tr></table></figure><p>如果测试一个<code>slice</code>是否为空的，使用<code>len(s)==0</code>来判断，而不应该用<code>s==nil</code>来判断。<br>除了和<code>nil</code>相等比较外，<code>nil</code>值的<code>slice</code>的行为和其它任意0长度的<code>slice</code>一样。如<code>reverse(nil)</code>也是安全的。<br>除了文档已经明确说明的地方，所有Go语言的函数应该以相同的方式对于<code>nil</code>值的<code>slice</code>和0长度的<code>slice</code>。</p><h1 id="4-2-1-append函数"><a href="#4-2-1-append函数" class="headerlink" title="4.2.1. append函数"></a>4.2.1. append函数</h1><p>内置的<code>append</code>函数用于向<code>slice</code>追加元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> runes []<span class="hljs-type">rune</span><br><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello, 世界&quot;</span> &#123;<br>runes = <span class="hljs-built_in">append</span>(runes, r)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, runes) <span class="hljs-comment">//[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]</span><br></code></pre></td></tr></table></figure><p>第一个版本的appendInt函数，专门用于处理<code>[]int</code>类型的<code>slice</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-type">int</span>&#123;&#125;<br>fmt.Println(appendInt(a, <span class="hljs-number">1</span>)) <span class="hljs-comment">// [1]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendInt</span><span class="hljs-params">(x []<span class="hljs-type">int</span>, y <span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> z []<span class="hljs-type">int</span><br>zlen := <span class="hljs-built_in">len</span>(x) + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> zlen &lt;= <span class="hljs-built_in">cap</span>(x) &#123;<br><span class="hljs-comment">// There is room to grow. Extend the slice.</span><br>z = x[:zlen]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// There is insufficient space. Allocate a new array.</span><br><span class="hljs-comment">// Grow by doubling, for amortized linear complexity.</span><br>zcap := zlen<br><span class="hljs-keyword">if</span> zcap &lt; <span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(x) &#123;<br>zcap = <span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(x)<br>&#125;<br>z = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, zlen, zcap)<br><span class="hljs-built_in">copy</span>(z, x)<br>&#125;<br>z[<span class="hljs-built_in">len</span>(x)] = y<br><span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><p><code>appendInt</code>函数剖析：</p><ol><li>先检测<code>slice</code>底层数组是否有猪狗的容量来保存新的元素。</li><li>如果足够空间，直接在原底层数组上扩展<code>slie</code>：<code>z= x[:zlen]</code>，赋值新元素y到新扩展的空间，并返回<code>slice</code>。此时输入x和输出的z共享相同的底层数组。</li><li>如果空间不足够，先分配足够大（原先底层数组长度的2倍）的<code>slice</code>，复制输入的x到新<code>slice</code>，并添加y元素。此时z和输入的x引用的是不同的底层数组。</li></ol><p>虽然通过循环复制元素更直接，不过内置的<code>copy</code>函数可以方便地将一个slice复制到另一个相同类型的slice。<br><code>copy</code>函数返回成功复制的元素个数，等于两个<code>slice</code>中较小那个<code>slice</code>的长度，所以不会导致超过目标<code>slice</code>的范围。</p><p>内置<code>append</code>函数使用了比<code>appendInt</code>更复杂的内存扩展策略。<br>通常情况下，我们并不知道调用<code>append</code>函数是否导致了内存的重新分配，因此也不能确定新的<code>slice</code>和原始的<code>slice</code>是否引用相同的底层数组空间。<br>同样，我们不能确认在原先的<code>slice</code>上的操作是否会影响到新的<code>slice</code>，因此，通常是将<code>append</code>函数返回的结果直接赋值给输入的<code>slice</code>变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">runes = <span class="hljs-built_in">append</span>(runes, r)<br></code></pre></td></tr></table></figure><p>更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。<br><code>slice</code>的底层数组的元素是简接访问的，但<code>slice</code>对应结构体本身的指针、长度和容量部分是直接访问的。<br><code>slice</code>并不是纯粹的引用类型，实际上是类似下面结构体的聚合类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSlice <span class="hljs-keyword">struct</span> &#123;<br>ptr *<span class="hljs-type">int</span><br><span class="hljs-built_in">len</span>,<span class="hljs-built_in">cap</span> <span class="hljs-type">int</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内置的<code>append</code>函数可以追加多个元素，甚至追加一个<code>slice</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x []<span class="hljs-type">int</span><br>x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">1</span>)<br>x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br>x = <span class="hljs-built_in">append</span>(x, x...) <span class="hljs-comment">// append the slice x</span><br>fmt.Println(x)      <span class="hljs-comment">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]</span><br></code></pre></td></tr></table></figure><p>修改<code>appendInt</code>函数如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-type">int</span>&#123;&#125;<br>fmt.Println(appendInt(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// [1 2 3 4]</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendInt</span><span class="hljs-params">(x []<span class="hljs-type">int</span>, y ...<span class="hljs-type">int</span>)</span></span> []<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> z []<span class="hljs-type">int</span><br>zlen := <span class="hljs-built_in">len</span>(x) + <span class="hljs-built_in">len</span>(y)<br><span class="hljs-keyword">if</span> zlen &lt;= <span class="hljs-built_in">cap</span>(x) &#123;<br>z = x[:zlen]<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>zcap := zlen<br><span class="hljs-keyword">if</span> zcap &lt; <span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(x) &#123;<br>zcap = <span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(x)<br>&#125;<br>z = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, zlen, zcap)<br><span class="hljs-built_in">copy</span>(z, x)<br>&#125;<br><span class="hljs-built_in">copy</span>(z[<span class="hljs-built_in">len</span>(x):], y)<br><span class="hljs-keyword">return</span> z<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-2-2-Slice内存技巧"><a href="#4-2-2-Slice内存技巧" class="headerlink" title="4.2.2. Slice内存技巧"></a>4.2.2. Slice内存技巧</h1><p>Continue…</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.1. 数组</title>
      <link href="/posts/681582df4225/"/>
      <url>/posts/681582df4225/</url>
      
        <content type="html"><![CDATA[<p>数组是一个由固定长度的特定类型元素组成的序列。</p><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>fmt.Println(a) <span class="hljs-comment">// [0 0 0]</span><br></code></pre></td></tr></table></figure><p>Go语言声明变量，会默认初始化。<br>默认情况下，数组每个元素都被初始化为元素类型对应的零值。</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>可以通过声明数组，也可以直接使用数组字面值初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> q [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> r [<span class="hljs-number">3</span>]<span class="hljs-type">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br>fmt.Println(r[<span class="hljs-number">2</span>]) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>当使用数组字面值时，值的数量与数组长度不一致，那么没有数组字面值的元素被赋值为元素类型的零值。</p><p>也可以由数组字面值来确定数组长度：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">q := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, q) <span class="hljs-comment">// [3]int</span><br></code></pre></td></tr></table></figure><p>数组的长度是数组类型的组成部分，因此<code>[3]int</code>和<code>[4]int</code>是两种不同的数组类型。<br>数组的长度必须是常量表达式，因为数组的长度需要再编译阶段确定。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">q := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;<br>q = [<span class="hljs-number">4</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>&#125; <span class="hljs-comment">// compile error: cannot assign [4]int to [3]int</span><br></code></pre></td></tr></table></figure><p>也可以指定索引和对应值列表方式初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Currency <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>USD Currency = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 美元</span><br>EUR                 <span class="hljs-comment">// 欧元</span><br>GBP                 <span class="hljs-comment">// 英镑</span><br>RMB                 <span class="hljs-comment">// 人民币</span><br>)<br><br>symbol := [...]<span class="hljs-type">string</span>&#123;USD: <span class="hljs-string">&quot;$&quot;</span>, EUR: <span class="hljs-string">&quot;€&quot;</span>, GBP: <span class="hljs-string">&quot;£&quot;</span>, RMB: <span class="hljs-string">&quot;￥&quot;</span>&#125;<br>fmt.Println(RMB, symbol[RMB]) <span class="hljs-comment">// 3 ￥</span><br></code></pre></td></tr></table></figure><p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而没用到的索引可以省略，未指定初始化值的元素将用零值初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">r := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">99</span>:<span class="hljs-number">-1</span>&#125;<br></code></pre></td></tr></table></figure><p>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</p><h1 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h1><p>数组的每个元素可以通过索引下标来访问，索引下标的范围从0开始到数组长度减1的。<br>内置len函数将返回数组中的元素个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-type">int</span><br>fmt.Println(a[<span class="hljs-number">0</span>])<br>fmt.Println(<span class="hljs-built_in">len</span>(a)) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p><code>a[index]</code>可以访问数组的元素。</p><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><p>使用for…range遍历数组:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, v)<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, v)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h1><p>如果数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的。<br>可以使用<code>==</code>比较运算符比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。<br>不相等比较运算符<code>!=</code>遵循同样的规则。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>b := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>c := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;<br>fmt.Println(a == b, a == c, b == c) <span class="hljs-comment">// true false false</span><br>d := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>fmt.Println(a == d) <span class="hljs-comment">// invalid operation: a == d (mismatched types [2]int and [3]int)</span><br></code></pre></td></tr></table></figure><p>crypto&#x2F;sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）；如果消息摘要不同，那么消息本身必然也是不同的。下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := sha256.Sum256([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;x&quot;</span>))<br>c2 := sha256.Sum256([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;x&quot;</span>))<br>fmt.Printf(<span class="hljs-string">&quot;%x\n%x\n%t\n%T\n&quot;</span>, c1, c2, c1 == c2, c1)<br><span class="hljs-comment">// Output</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span><br><span class="hljs-comment">4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span><br><span class="hljs-comment">true</span><br><span class="hljs-comment">[32]uint8</span><br><span class="hljs-comment">*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，虽然只有一个字符的差异，但生成的消息摘要相同。</p><h1 id="数组作为函数入参"><a href="#数组作为函数入参" class="headerlink" title="数组作为函数入参"></a>数组作为函数入参</h1><p>当调用函数时，函数的每个调用参数将会被赋值给函数内部的参数变量。<br>函数参数变量接受的是一个复制的副本，并不是原始调用的变量。<br>函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并非直接修改调用时的原始的数组变量。<br>Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">2</span>]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>c(a)<br>fmt.Println(a) <span class="hljs-comment">// [1,2]</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">(a [2]<span class="hljs-type">int</span>)</span></span> &#123;<br>a[<span class="hljs-number">1</span>] = <span class="hljs-number">9</span><br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这种直接使用数组当做函数参数的方式，当函数元素过大，将导致函数参数复制的性能。<br>当然，可以显式地传入数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。<br>下面函数用于给[32]byte类型的数组清零：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">a := [<span class="hljs-number">32</span>]<span class="hljs-type">byte</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br>zero(&amp;a)<br>fmt.Println(a) <span class="hljs-comment">// [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span><br>...<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-type">byte</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ptr &#123;<br>ptr[i] = <span class="hljs-number">0</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实还有更简洁的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-type">byte</span>)</span></span> &#123;<br>*ptr = [<span class="hljs-number">32</span>]<span class="hljs-type">byte</span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然通过指针传递数组参数是高效的，而且也允许在函数内部修改数组元素的值，但是数组类型规定了固定的长度信息，决定了数组是不够便捷的类型。<br>如<code>zero</code>函数并不能接受指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。<br>由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组很少用于函数参数，一般使用slice来替代数组。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 4.1：</strong> 编写一个函数，计算两个SHA256哈希码中不同bit的数目。（参考2.6.2节的PopCount函数。)<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c1 := sha256.Sum256([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;x&quot;</span>))<br>c2 := sha256.Sum256([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;X&quot;</span>))<br>fmt.Println(sha256DiffBitCount(c1, c2))<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sha256DiffBitCount</span><span class="hljs-params">(c1, c2 [32]<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++ &#123;<br>count += diffBitCount(c1[i], c2[i])<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">diffBitCount</span><span class="hljs-params">(b1, b2 <span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>count := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>mask := <span class="hljs-type">byte</span>(<span class="hljs-number">1</span> &lt;&lt; i)<br><span class="hljs-keyword">if</span> b1&amp;mask != b2&amp;mask &#123;<br>count++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> count<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 4.2：</strong> 编写一个程序，默认打印标准输入的以SHA256哈希码，也可以通过命令行标准参数选择SHA384或SHA512哈希算法。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;crypto/sha512&quot;</span><br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> f = flag.String(<span class="hljs-string">&quot;flag&quot;</span>, <span class="hljs-string">&quot;sha256&quot;</span>, <span class="hljs-string">&quot;flag = sha256 | sha384 | sha512&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>bytes := input.Bytes()<br><span class="hljs-keyword">switch</span> *f &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sha256&quot;</span>:<br>fmt.Printf(<span class="hljs-string">&quot;sha256: %x\n&quot;</span>, sha256.Sum256(bytes))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sha384&quot;</span>:<br>fmt.Printf(<span class="hljs-string">&quot;sha384: %x\n&quot;</span>, sha512.Sum384(bytes))<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sha512&quot;</span>:<br>fmt.Printf(<span class="hljs-string">&quot;sha512: %x\n&quot;</span>, sha512.Sum512(bytes))<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 复合数据类型</title>
      <link href="/posts/a27051ca627c/"/>
      <url>/posts/a27051ca627c/</url>
      
        <content type="html"><![CDATA[<p>复合数据类型，它是以不同的方式组合基本类型可以构造出来的复合数据类型。<br>如:<code>数组</code>、<code>slice</code>、<code>map</code>和<code>struct</code>。<br>数组和结构体是聚合类型，其值由许多元素或成员字段的值组成。<br>数组由同构的元素组成，每个元素的类型完全一致。<br>结构体由异构的元素组成，元素类型可以不用完全一致。<br>数组和结构体都是固定内存大小，而<code>slice</code>和<code>map</code>则是动态的数据结构，根据需要动态增长。</p><p><a href="/posts/681582df4225/">4.1. 数组</a></p><p><a href="/posts/53445ef771d8/">4.2. Slice</a></p><p><a href="/posts/610def108dde/">4.3. Map</a></p><p><a href="">4.4. 结构体</a></p><p><a href="/posts/b184f11121f4/">4.5. JSON</a></p><p><a href="">4.6. 文本和HTML模板</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.6. 常量</title>
      <link href="/posts/68c22f5501fb/"/>
      <url>/posts/68c22f5501fb/</url>
      
        <content type="html"><![CDATA[<p>常量表达式的值在编译期间计算，而非运行期。<br>常量的潜在类型都是基础类型：boolean、string或数字。</p><p>常量的声明语句定义了常量的名字，与变量声明语法类似。<br>常量的值不可改变 ，以防止在运行期间被意外或恶意修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span><br></code></pre></td></tr></table></figure><p>或批量声明多个相关常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    e  = <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span><br>    pi = <span class="hljs-number">3.14159265358979323846264338327950288419716939937510582097494459</span><br>)<br></code></pre></td></tr></table></figure><p>当操作数是常量时，一些运行时的错误也可以在编译时被发现，如整数除零、字符串索引越界、任何导致无效浮点数的操作等。</p><p>常量的声明也可以包含类型和值，如果没有显式指定类型，那么将从右边的表达式推断类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> noDelay time.Duration = <span class="hljs-number">0</span><br><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">5</span> * time.Minute<br>fmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, noDelay)     <span class="hljs-comment">// time.Duration 0s</span><br>fmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, timeout)     <span class="hljs-comment">// time.Duration 5m0s</span><br>fmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, time.Minute) <span class="hljs-comment">// time.Duration 1m0s</span><br></code></pre></td></tr></table></figure><p>如果批量声明常量且常量类型一样，除了第一个外，都可以省略常量右边的初始化表达式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-number">1</span><br>b<br>c = <span class="hljs-number">2</span><br>d<br>)<br>fmt.Println(a, b, c, d)<br></code></pre></td></tr></table></figure><h1 id="3-6-1-iota常量生成器"><a href="#3-6-1-iota常量生成器" class="headerlink" title="3.6.1. iota常量生成器"></a>3.6.1. iota常量生成器</h1><p>常量声明可以使用iota常量生成器初始化，它用于生成一组以相似规则初始化的常量，但是不用每行都写一遍初始化表达式。<br>在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置为0，然后在每一个有常量声明的行加1。</p><p>类似其它编程语言的枚举类型，下面来自time包的Weekday命名类型，为一周的每一天定义一个常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>Sunday Weekday = <span class="hljs-literal">iota</span><br>Monday<br>Tuesday<br>Wednesday<br>Thursday<br>Friday<br>Saturday<br>)<br></code></pre></td></tr></table></figure><p>周日为0，周一为1，以此类推。</p><p>也可以在复杂的常量表达式中使用iota.<br>如下<code>net</code>包的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Flags <span class="hljs-type">uint</span><br><br><span class="hljs-keyword">const</span> (<br>FlagUp           Flags = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// interface is up</span><br>FlagBroadcast                      <span class="hljs-comment">// interface supports broadcast access capability</span><br>FlagLoopback                       <span class="hljs-comment">// interface is a loopback interface</span><br>FlagPointToPoint                   <span class="hljs-comment">// interface belongs to a point-to-point link</span><br>FlagMulticast                      <span class="hljs-comment">// interface supports multicast access capability</span><br>)<br></code></pre></td></tr></table></figure><p>每个常量表达式1&lt;&lt;iota，是连续的2的幂，分别对应一个bit的位置。常应用于测试、设置或清除对应bit位的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsUp</span><span class="hljs-params">(v net.Flags)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> v&amp;net.FlagUp == net.FlagUp<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TurnDown</span><span class="hljs-params">(v *net.Flags)</span></span> &#123;<br>*v &amp;^= net.FlagUp<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetBroadcast</span><span class="hljs-params">(v *net.Flags)</span></span> &#123;<br>*v |= net.FlagBroadcast<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsCast</span><span class="hljs-params">(v net.Flags)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">return</span> v&amp;(net.FlagBroadcast|net.FlagMulticast) != <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> v net.Flags = net.FlagMulticast | net.FlagUp<br>fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// 10001 true</span><br>TurnDown(&amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// 10000 false</span><br>SetBroadcast(&amp;v)<br>fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v))   <span class="hljs-comment">// 10010 false</span><br>fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsCast(v)) <span class="hljs-comment">// 10010 true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>下面有一个更复杂的例子，每个常量都是1024的幂：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>_   = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>KiB <span class="hljs-comment">// 1024B</span><br>MiB <span class="hljs-comment">// 1048576B</span><br>GiB <span class="hljs-comment">// 1073741824B</span><br>TiB <span class="hljs-comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span><br>PiB <span class="hljs-comment">// 1125899906842624</span><br>EiB <span class="hljs-comment">// 1152921504606846976</span><br>ZiB <span class="hljs-comment">// 1180591620717411303424 (exceeds 1 &lt;&lt; 64)</span><br>YiB <span class="hljs-comment">// 1208925819614629174706176</span><br>)<br></code></pre></td></tr></table></figure><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p><strong>练习 3.13：</strong> 编写KB、MB的常量声明，然后扩展到YB。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>KB = <span class="hljs-number">1000</span><br>MB = KB * KB<br>GB = MB * KB<br>TB = GB * KB<br>PB = TB * KB<br>EB = PB * KB<br>ZB = EB * KB<br>YB = ZB * KB<br>)<br></code></pre></td></tr></table></figure><h1 id="3-6-2-无类型常量"><a href="#3-6-2-无类型常量" class="headerlink" title="3.6.2. 无类型常量"></a>3.6.2. 无类型常量</h1><p>有六种未明确类型的常量类型：</p><ul><li>无类型的布尔型  true false</li><li>无类型的整数 如 0</li><li>无类型的字符 如 ‘\u0000’</li><li>无类型的浮点数 如 0.0</li><li>无类型的复数 如 0i</li><li>无类型的字符串 如字符串面值常量”123”</li></ul><p>编译器为这些常量类型的数字常量提供比基础类型更高精度的算术运算，至少有256bit的运算精度，而且不需要显式类型转换可以直接用于更多表达式。如上的ZiB和YiB的值已超过整数类型能表达的范围，但仍然是合法的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(YiB / ZiB) <span class="hljs-comment">// 1024</span><br>fmt.Println(YiB) <span class="hljs-comment">// cannot use YiB (untyped int constant 1208925819614629174706176) as int value in argument to fmt.Println (overflows)</span><br></code></pre></td></tr></table></figure><p>另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">float32</span> = math.Pi<br><span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = math.Pi<br><span class="hljs-keyword">var</span> z <span class="hljs-type">complex128</span> = math.Pi<br><br>fmt.Println(x) <span class="hljs-comment">// 3.1415927</span><br>fmt.Println(y) <span class="hljs-comment">// 3.141592653589793</span><br>fmt.Println(z) <span class="hljs-comment">// (3.141592653589793+0i)</span><br></code></pre></td></tr></table></figure><p>将常量赋值给变量时，可能会导致精度丢失。<br>如果常量被指定类型，如<code>math.Pi</code>，精度也会产生变化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> Pi64 <span class="hljs-type">float64</span> = math.Pi<br><span class="hljs-keyword">var</span> x <span class="hljs-type">float32</span> = <span class="hljs-type">float32</span>(Pi64)<br><span class="hljs-keyword">var</span> y <span class="hljs-type">float64</span> = Pi64<br><span class="hljs-keyword">var</span> z <span class="hljs-type">complex128</span> = <span class="hljs-type">complex128</span>(Pi64)<br><br>fmt.Println(x) <span class="hljs-comment">// 3.1415927</span><br>fmt.Println(y) <span class="hljs-comment">// 3.141592653589793</span><br>fmt.Println(z) <span class="hljs-comment">// (3.141592653589793+0i)</span><br></code></pre></td></tr></table></figure><p>除法运算符<code>/</code>会根据操作数的类型生成对应类型的结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">212</span><br>fmt.Println((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)     <span class="hljs-comment">// &quot;100&quot;; (f - 32) * 5 is a float64</span><br>fmt.Println(<span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (f - <span class="hljs-number">32</span>))     <span class="hljs-comment">// &quot;0&quot;;   5/9 is an untyped integer, 0</span><br>fmt.Println(<span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span> * (f - <span class="hljs-number">32</span>)) <span class="hljs-comment">// &quot;100&quot;; 5.0/9.0 is an untyped float</span><br></code></pre></td></tr></table></figure><p>只有常量可以是无类型的。<br>当无类型的常量赋值给一个变量的时候，如<code>var f float64 = 212</code>或者像输出语句中的表达式含有明确类型的值，如果转换合法，无类型的常量将会被隐式转换为对应的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-number">3</span> + <span class="hljs-number">0i</span> <span class="hljs-comment">// untyped complex -&gt; float64</span><br>f = <span class="hljs-number">2</span>                  <span class="hljs-comment">// untyped integer -&gt; float64</span><br>f = <span class="hljs-number">1e123</span>              <span class="hljs-comment">// untyped floating-point -&gt; float64</span><br>f = <span class="hljs-string">&#x27;a&#x27;</span>                <span class="hljs-comment">// untyped rune -&gt; float64</span><br></code></pre></td></tr></table></figure><p>相当于:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f <span class="hljs-type">float64</span> = <span class="hljs-type">float64</span>(<span class="hljs-number">3</span> + <span class="hljs-number">0i</span>)<br>f = <span class="hljs-type">float64</span>(<span class="hljs-number">2</span>)<br>f = <span class="hljs-type">float64</span>(<span class="hljs-number">1e123</span>)<br>f = <span class="hljs-type">float64</span>(<span class="hljs-string">&#x27;a&#x27;</span>)<br></code></pre></td></tr></table></figure><p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    deadbeef = <span class="hljs-number">0xdeadbeef</span> <span class="hljs-comment">// untyped int with value 3735928559</span><br>    a = <span class="hljs-type">uint32</span>(deadbeef)  <span class="hljs-comment">// uint32 with value 3735928559</span><br>    b = <span class="hljs-type">float32</span>(deadbeef) <span class="hljs-comment">// float32 with value 3735928576 (rounded up)</span><br>    c = <span class="hljs-type">float64</span>(deadbeef) <span class="hljs-comment">// float64 with value 3735928559 (exact)</span><br>    d = <span class="hljs-type">int32</span>(deadbeef)   <span class="hljs-comment">// compile error: constant overflows int32</span><br>    e = <span class="hljs-type">float64</span>(<span class="hljs-number">1e309</span>)    <span class="hljs-comment">// compile error: constant overflows float64</span><br>    f = <span class="hljs-type">uint</span>(<span class="hljs-number">-1</span>)          <span class="hljs-comment">// compile error: constant underflows uint</span><br>)<br></code></pre></td></tr></table></figure><p>对于没有显式类型的变量声明语法，无类型的常量会被隐式转为默认的变量类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span>      <span class="hljs-comment">// untyped integer;        implicit int(0)</span><br>r := <span class="hljs-string">&#x27;\000&#x27;</span> <span class="hljs-comment">// untyped rune;           implicit rune(&#x27;\000&#x27;)</span><br>f := <span class="hljs-number">0.0</span>    <span class="hljs-comment">// untyped floating-point; implicit float64(0.0)</span><br>c := <span class="hljs-number">0i</span>     <span class="hljs-comment">// untyped complex;        implicit complex128(0i)</span><br></code></pre></td></tr></table></figure><p>默认类型规则：</p><ul><li>无类型的整数常量 -&gt;<code>int</code></li><li>无类型的浮点数常量-&gt;<code>float64</code></li><li>无类型的复数常量-&gt;<code>complex128</code></li><li>无类型的字符常量-&gt;<code>rune</code></li></ul><p>如果要给变量一个非默认类型，那么可以显式转换为所需类型或给声明的变量指定明确的类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i = <span class="hljs-type">int8</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">var</span> i <span class="hljs-type">int8</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>当无类型的常量输出接口值（类型）时，会输出默认类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0</span>)      <span class="hljs-comment">// &quot;int&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0.0</span>)    <span class="hljs-comment">// &quot;float64&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0i</span>)     <span class="hljs-comment">// &quot;complex128&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-string">&#x27;\000&#x27;</span>) <span class="hljs-comment">// &quot;int32&quot; (rune)</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.5. 字符串</title>
      <link href="/posts/a309a7c16f6a/"/>
      <url>/posts/a309a7c16f6a/</url>
      
        <content type="html"><![CDATA[<p>字符串是不可变的字节序列。<br>字符串包含任意数据，包括byte值0。<br>文本字符串通常被解释为采用UTF8编码的Unicode码（rune）序列。</p><p>内置的<code>len函数</code>返回字符串的<code>字节数量</code>，不是rune字符数量。<br>索引操作<code>s[i]</code>返回第<code>i</code>个字节的值，i必须满足<code>0 ≤ i&lt; len(s)</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello, world&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s))     <span class="hljs-comment">// 12</span><br>fmt.Println(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">7</span>]) <span class="hljs-comment">// 104 119 (h and w)</span><br></code></pre></td></tr></table></figure><p>第<code>i</code>个字节并不一定是字符串的第<code>i</code>个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节。</p><p><code>s[i:j]</code>基于字符串s的第<code>i</code>个字节开始到第<code>j</code>个字节（不包含第j个字节本身）生成新的字符串。新字符串包含<code>j-i</code>个字节。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello,world&quot;</span><br>fmt.Println(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>注意索引不要超出字符串范围或<code>j</code>小于<code>i</code>。<br><code>i</code>和<code>j</code>都可以被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;hello,world&quot;</span><br>fmt.Println(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// hello</span><br>fmt.Println(s[:<span class="hljs-number">5</span>])  <span class="hljs-comment">// hello</span><br>fmt.Println(s[<span class="hljs-number">6</span>:])  <span class="hljs-comment">// world</span><br>fmt.Println(s[:])   <span class="hljs-comment">// hello,world</span><br></code></pre></td></tr></table></figure><p><code>+</code>操作符可以将两个字符串拼接成一个新字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-string">&quot;hi&quot;</span> + s[<span class="hljs-number">5</span>:]) <span class="hljs-comment">// hi,world</span><br></code></pre></td></tr></table></figure><p>字符串可以通过逐个字节进行比较；比较的结果是根据字符串自然编码的顺序。</p><p>字符串的值是不可变的：一个字符串包含的字节序列永远不会被改变。<br>两个字符串拼接成一个字符串时，将生成新的字符串，原有的字符串值不会被改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;left foot&quot;</span><br>t := s<br>s += <span class="hljs-string">&quot;,right foot&quot;</span><br>fmt.Println(s) <span class="hljs-comment">// left foot,right foot</span><br>fmt.Println(t) <span class="hljs-comment">// left foot</span><br></code></pre></td></tr></table></figure><p>原有字符串值不会被改变，但变量s将被赋于新的字符串值，t依然包含原先的字符串值。</p><p>尝试修改字符串内部数据的操作也是被禁止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;L&#x27;</span>  <span class="hljs-comment">// cannot assign to s[0] (value of type byte)</span><br></code></pre></td></tr></table></figure><p>不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。同样，一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。在这两种情况下都没有必要分配新的内存。</p><h1 id="3-5-1-字符串面值"><a href="#3-5-1-字符串面值" class="headerlink" title="3.5.1. 字符串面值"></a>3.5.1. 字符串面值</h1><p>字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号即可：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&quot;Hello, world&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/3.5.%20%E5%AD%97%E7%AC%A6%E4%B8%B2/1679683714399.png" alt="enter description here"></p><p>Go语言源文件默认使用UTF8编码，文本字符串也是默认使用UTF8编码。<br>也可以将Unicode码点写到字符串面值里。</p><p>ASCII转义字符：</p><table><thead><tr><th>转义字符</th><th>释义</th></tr></thead><tbody><tr><td>\a</td><td>响铃</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\f</td><td>换页</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\r</td><td>回车</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\v</td><td>垂直制表符</td></tr><tr><td>&#39;</td><td>单引号（只用在’&#39;‘形式的rune符号面值中）</td></tr><tr><td>&quot;</td><td>双引号（只用在”…”形式的字符串面值中）</td></tr><tr><td>\</td><td>反斜杠</td></tr><tr><td>\xhh</td><td>十六进制 （两个h表示十六进制数字大小写都可以）如&#x2F;xff</td></tr><tr><td>\ooo</td><td>三个八进制数字 （0-7, 但不能超过\377，因为对应一个字节的范围，十进制为255）</td></tr></tbody></table><p>在原生字符串面值内是无法直接写字符的（如上表），必须通过转义字符、八进制或十六进制来表示。</p><h1 id="3-5-2-Unicode"><a href="#3-5-2-Unicode" class="headerlink" title="3.5.2. Unicode"></a>3.5.2. Unicode</h1><p>早期，计算机只有一个ASCII字符集（美国信息交换标准代码），使用7bit来表示128个字符（英文字母的大小写、数字、各种标点符号和设置控制符）。但是也导致了世界上很多地区的用户无法直接使用自己的符号系统。那么如何有效处理包含各种语言丰富多样的文本数据呢？</p><p><code>Unicode</code>（<a href="http://unicode.org)收集了世界上所有的符号系统,包括重音符号和其它变音符号,制表符和回车符,还有其它有趣的符号./">http://unicode.org）收集了世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有其它有趣的符号。</a><br>每一个符号都分配了唯一的<code>Unicode</code>码点。<br><code>Unicode</code>码点对应Go语言中的<code>rune</code>整数类型（<code>rune</code>是<code>int32</code>等价类型）。</p><p>在第八版的Unicode标准中收集了超过了120,000个字符，涵盖超过100多种语言。<br>Unicode码的数据类型是<code>int32</code>，也就是<code>rune</code>对应的类型，这种编码方式为UTF-32或UCS-4。每个Unicode码使用了32bit来表示，但是会浪费很多存储空间，因此大数据计算器读的文本是ASCII字符，ASCII字符只需要8bit或1Byte就可以表示。</p><h1 id="3-5-3-UTF-8"><a href="#3-5-3-UTF-8" class="headerlink" title="3.5.3. UTF-8"></a>3.5.3. UTF-8</h1><p><code>UTF8</code>是将<code>Unicode</code>码编码为字节序列的变长编码。<br><code>UTF8</code>编码使用1到4个字节来表示每个<code>Unicode</code>码。<br><code>ASCII</code>部分编码是使用1个字节，常用字符部分使用2或3个字节表示。</p><p>每个符号编码后第一个字节的高端bit位用于表示总共有多少个字节。<br>如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII码的每个字符依然是一个字节，与传统的ASCII编码兼容。<br>如果第一个字节的高端bit为110，则说明需要2个字节。<br>如果第一个字节的高端bit为1110，则说明需要3个字节。<br>如果第一个字节的高端bit为11110，则说明需要4个字节。<br>后续每个高端bit都以10开头。</p><table><thead><tr><th>字节表示</th><th>范围</th></tr></thead><tbody><tr><td>0xxxxxxx</td><td>runes 0-127 (ASCII)</td></tr><tr><td>110xxxxx 10xxxxxx</td><td>128-2047 (values &lt;128 unused)</td></tr><tr><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>2048-65535 (values &lt; 2048 unused)</td></tr><tr><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td><td>65536-0x10ffff (other values unused)</td></tr></tbody></table><p>变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了额外的优点。</p><ul><li>UTF8编码比较紧凑，完全兼容ASCII编码，并且可以自动同步。</li><li>UTF8编码还可以通过向前回溯最多2个字节就可以确定当前字符编码的开始字节的位置。</li><li>UTF8也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看（译注：像GBK之类的编码，如果不知道起点位置则可能会出现歧义）。</li><li>没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰。</li><li>UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。</li><li>因为没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。</li></ul><p><code>unicode</code>包提供了处理<code>rune</code>字符相关功能的函数（如区分字母和数组，或者是字母的大小和小写转换等），<code>unicode/utf8</code>包则提供了用于<code>rune</code>字符序列的<code>UTF8</code>编码和解码的功能。</p><p>有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符（译注：中文和日文就有很多相似但不同的字）。Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符。<br>有两种形式：</p><ul><li><code>\uhhhh</code>对应16bit的编码值</li><li><code>\Uhhhhhhhh</code>对应32bit的编码值</li></ul><p>其中一个h表示一个十六进制数字。<br>一般很少使用32bit的形式。<br>每一个对应着UTF编码。<br>下面的字母串面值都表示相同的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-string">&quot;世界&quot;</span>)                       <span class="hljs-comment">// 世界</span><br>fmt.Println(<span class="hljs-string">&quot;\xe4\xb8\x96\xe7\x95\x8c&quot;</span>) <span class="hljs-comment">// 世界</span><br>fmt.Println(<span class="hljs-string">&quot;\u4e16\u754c&quot;</span>)             <span class="hljs-comment">// 世界</span><br>fmt.Println(<span class="hljs-string">&quot;\U00004e16\U0000754c&quot;</span>)     <span class="hljs-comment">// 世界</span><br></code></pre></td></tr></table></figure><p>Unicode转义也可以使用在rune字符中。下面三个字符是等价的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-string">&#x27;世&#x27;</span> <span class="hljs-string">&#x27;\u4e16&#x27;</span> <span class="hljs-string">&#x27;\U00004e16&#x27;</span><br></code></pre></td></tr></table></figure><p>对于小于256码值可以写在一个十六进制的转义字节中，如<code>\x41</code>对应字符<code>A</code>，但对于更大的码值则必须使用<code>\u</code>或<code>\U</code>转义形式。<br>因此，<code>\xe4\xb8\x96</code>并非一个合法的<code>rune</code>字符，虽然这个3个字节对应一个有效的UTF8编码的码值。</p><p>得益于UTF8编码的优良设计，很多字符串并不需要解码操作。<br>如下，可以不用解码直接测试字符串是否是另一个字符串的前缀：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) &gt;= <span class="hljs-built_in">len</span>(prefix) &amp;&amp; s[:<span class="hljs-built_in">len</span>(prefix)] == prefix<br>&#125;<br></code></pre></td></tr></table></figure><p>当处理一个中西两个字符时，需要UTF8解码器。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;Hello, 世界&quot;</span><br>fmt.Println(<span class="hljs-built_in">len</span>(s))                    <span class="hljs-comment">// 13</span><br>fmt.Println(utf8.RuneCountInString(s)) <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><p>字符串s包含13个字节，以UTF8形式编码，却只对应9个Unicode字符。<br>可以使用<code>unicode/utf8</code>包中进行UTF解码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;<br>r, size := utf8.DecodeRuneInString(s[i:])<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, i, r)<br>i += size<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0       H</span><br><span class="hljs-comment">1       e</span><br><span class="hljs-comment">2       l</span><br><span class="hljs-comment">3       l</span><br><span class="hljs-comment">4       o</span><br><span class="hljs-comment">5       ,</span><br><span class="hljs-comment">6</span><br><span class="hljs-comment">7       世</span><br><span class="hljs-comment">10      界</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>DecodeRuneInString</code>函数返回一个r和size，r对应字符本身，size对应r采用UTF8编码后的编码字节数。<br>Go语言的range循环在处理字符串时，会自动进行隐式解码UTF8字符串。如下：<br><img src="/3.5.%20%E5%AD%97%E7%AC%A6%E4%B8%B2/1679689120671.png" alt="enter description here"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello,世界&quot;</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%q\t%d\n&quot;</span>, i, r, r)<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0       &#x27;H&#x27;     72</span><br><span class="hljs-comment">1       &#x27;e&#x27;     101</span><br><span class="hljs-comment">2       &#x27;l&#x27;     108</span><br><span class="hljs-comment">3       &#x27;l&#x27;     108</span><br><span class="hljs-comment">4       &#x27;o&#x27;     111</span><br><span class="hljs-comment">5       &#x27;,&#x27;     44</span><br><span class="hljs-comment">6       &#x27;世&#x27;    19990</span><br><span class="hljs-comment">9       &#x27;界&#x27;    30028</span><br></code></pre></td></tr></table></figure><p>统计字符串中字符的数目，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, _ = <span class="hljs-keyword">range</span> s &#123;<br>   n++<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以忽略变量<code>_</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">n := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> s &#123;<br>n++<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以直接调用<code>utf8.RuneCountInString(s)</code>函数。</p><p>文本字符串采用UTF8编码只是一种惯例，但是对于循环的真正字符串并不是一个惯例，这是正确的。如果用于循环的字符串只是一个普通的二进制数据，或者是含有错误编码的UTF8数据，将会发送什么呢？<br>每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符’\uFFFD’，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号”�”。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。</p><p>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。</p><p>string接受到[]rune的类型转换，可以将一个UTF8编码的字符串解码为Unicode字符序列：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;程序&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;% x\n&quot;</span>, s) <span class="hljs-comment">// e7 a8 8b e5 ba 8f</span><br>r := []<span class="hljs-type">rune</span>(s)<br>fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, r) <span class="hljs-comment">// [7a0b 5e8f]</span><br></code></pre></td></tr></table></figure><p>在第一个Printf中的% x参数用于在每个十六进制数字前插入一个空格。</p><p>将一个[]rune类型的Unicode字符slice或数组转为string，则进行UTF编码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-type">string</span>(r)) <span class="hljs-comment">// 程序</span><br></code></pre></td></tr></table></figure><p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">65</span>))                      <span class="hljs-comment">// A not 65</span><br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">1234567</span>))                 <span class="hljs-comment">// �</span><br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">0x4eac</span>))                  <span class="hljs-comment">// 京</span><br>fmt.Printf(<span class="hljs-string">&quot;%0b\n&quot;</span>, <span class="hljs-number">0x4eac</span>)                  <span class="hljs-comment">// 100111010101100 unicode 二进制码点</span><br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-type">rune</span>(<span class="hljs-number">0</span>b100111010101100))) <span class="hljs-comment">// 京  unicode二进制码点转rune字符输出</span><br>fmt.Printf(<span class="hljs-string">&quot;%0d\n&quot;</span>, <span class="hljs-number">0x4eac</span>)                  <span class="hljs-comment">// 20140  unicode十六进制转十进制</span><br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">20140</span>))                   <span class="hljs-comment">// 京</span><br>fmt.Println(strconv.QuoteToASCII(<span class="hljs-string">&quot;京&quot;</span>))       <span class="hljs-comment">// &quot;\u4eac&quot; unicode编码其实就是unicode十六进制前加\u  表示16bit长度</span><br><span class="hljs-comment">// 编码为UTF8 获取UTF8的二进制码点</span><br>p := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">3</span>)<br>n := utf8.EncodeRune(p, <span class="hljs-type">rune</span>(<span class="hljs-number">0x4eac</span>))<br>fmt.Println(p)                                <span class="hljs-comment">// [228 186 172]</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, p)                         <span class="hljs-comment">// 京</span><br>fmt.Println(n)                                <span class="hljs-comment">// 3 表示3个字节</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b %08b %08b\n&quot;</span>, <span class="hljs-number">228</span>, <span class="hljs-number">186</span>, <span class="hljs-number">172</span>) <span class="hljs-comment">//   11100100 10111010 10101100 UTF8的二进制码点</span><br><span class="hljs-comment">// Unicode二进制码点 0100 1110 1010 1100 -&gt; 应用3个字节的模版1110xxxx 10xxxxxx 10xxxxxx进行填充后的utf8二进制码点，11100100 10111010 10101100</span><br></code></pre></td></tr></table></figure><p>如果对应码点的字符是无效的，则用’\uFFFD’无效字符作为替换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">1234567</span>)) <span class="hljs-comment">// �</span><br></code></pre></td></tr></table></figure><h1 id="3-5-4-字符串和Byte切片"><a href="#3-5-4-字符串和Byte切片" class="headerlink" title="3.5.4. 字符串和Byte切片"></a>3.5.4. 字符串和Byte切片</h1><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。</p><ul><li>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</li><li>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。</li><li>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</li><li>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。</li></ul><p>下面例子的basename函数灵感于Unix shell的同名工具。在我们实现的版本中，basename(s)将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(basename(<span class="hljs-string">&quot;a/b/c.go&quot;</span>)) <span class="hljs-comment">// &quot;c&quot;</span><br>fmt.Println(basename(<span class="hljs-string">&quot;c.d.go&quot;</span>))   <span class="hljs-comment">// &quot;c.d&quot;</span><br>fmt.Println(basename(<span class="hljs-string">&quot;abc&quot;</span>))      <span class="hljs-comment">// &quot;abc”</span><br></code></pre></td></tr></table></figure><p>第一个版本，不使用任何库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>fmt.Println(basename(input.Text()))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// basename removes directory components and a .suffix.</span><br><span class="hljs-comment">// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.c</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">basename</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-comment">// Discard last &#x27;/&#x27; and everything before.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;/&#x27;</span> &#123;<br>s = s[i+<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// Preserve everything before last &#x27;.&#x27;.</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br><span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>s = s[:i]<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个版本使用<code>strings.LastIndex</code>函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>fmt.Println(basename(input.Text()))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">basename</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>slash := strings.LastIndex(s, <span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// -1 if &quot;/&quot; not found</span><br>s = s[slash+<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> dot := strings.LastIndex(s, <span class="hljs-string">&quot;.&quot;</span>); dot &gt;= <span class="hljs-number">0</span> &#123;<br>s = s[:dot]<br>&#125;<br><span class="hljs-keyword">return</span> s<br>&#125;<br></code></pre></td></tr></table></figure><p><code>path/filepath</code>包则使用操作系统本身的路径规则，例如POSIX系统使用&#x2F;foo&#x2F;bar，而Microsoft Windows使用c:\foo\bar等</p><p>函数的功能是将一个表示整值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>fmt.Println(comma(input.Text()))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// comma inserts commas in a non-negative decimal integer string.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">comma</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>n := <span class="hljs-built_in">len</span>(s)<br><span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span> &#123;<br><span class="hljs-keyword">return</span> s<br>&#125;<br><span class="hljs-keyword">return</span> comma(s[:n<span class="hljs-number">-3</span>]) + <span class="hljs-string">&quot;,&quot;</span> + s[n<span class="hljs-number">-3</span>:]<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串和字节slice之间的相互转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;abc&quot;</span><br>b := []<span class="hljs-type">byte</span>(s)<br>s2 := <span class="hljs-type">string</span>(b)<br></code></pre></td></tr></table></figure><p>从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。将一个字节slice转到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。</p><p>strings包的部分函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> []<span class="hljs-type">string</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(a []<span class="hljs-type">string</span>, sep <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br></code></pre></td></tr></table></figure><p><code>bytes</code>包的部分函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(b, subslice []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s []<span class="hljs-type">byte</span>)</span></span> [][]<span class="hljs-type">byte</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">bool</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep []<span class="hljs-type">byte</span>)</span></span> <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(s [][]<span class="hljs-type">byte</span>, sep []<span class="hljs-type">byte</span>)</span></span> []<span class="hljs-type">byte</span><br></code></pre></td></tr></table></figure><p>它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。</p><p>bytes包还提供了Buffer类型用于字节slice的缓存。一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长，一个bytes.Buffer变量并不需要处理化，因为零值也是有效的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(intsToString([]<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)) <span class="hljs-comment">// [1,2,3]</span><br>&#125;<br><br><span class="hljs-comment">// intsToString is like fmt.Sprint(value) but adds commas.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intsToString</span><span class="hljs-params">(values []<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(<span class="hljs-string">&#x27;[&#x27;</span>)<br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;<br>buf.WriteString(<span class="hljs-string">&quot;,&quot;</span>)<br>&#125;<br>fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, v)<br>&#125;<br>buf.WriteByte(<span class="hljs-string">&#x27;]&#x27;</span>)<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 3.10：</strong> 编写一个非递归版本的comma函数，使用bytes.Buffer代替字符串链接操作。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>fmt.Println(comma(input.Text()))<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// comma inserts commas in a non-negative decimal integer string.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">comma</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(s[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">len</span>(s)-i)%<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27;,&#x27;</span>)<br>&#125;<br>buf.WriteByte(s[i])<br>&#125;<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 3.11：</strong> 完善comma函数，以支持浮点数处理和一个可选的正负号的处理。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>fmt.Println(comma(input.Text()))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">comma</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span><br>&#125;<br><br>index := strings.LastIndex(s, <span class="hljs-string">&quot;.&quot;</span>)<br>n := <span class="hljs-built_in">len</span>(s)<br><span class="hljs-keyword">if</span> index &gt;= <span class="hljs-number">0</span> &#123;<br>n = index<br>&#125;<br><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br>buf.WriteByte(s[<span class="hljs-number">0</span>])<br><span class="hljs-keyword">if</span> s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;+&#x27;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span> &#123;<br>buf.WriteByte(s[<span class="hljs-number">1</span>])<br>s = s[<span class="hljs-number">1</span>:]<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<br><span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;.&#x27;</span> &#123;<br>buf.WriteString(s[i:])<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> (n-i)%<span class="hljs-number">3</span> == <span class="hljs-number">0</span> &amp;&amp; n-i &gt; <span class="hljs-number">0</span> &#123;<br>buf.WriteByte(<span class="hljs-string">&#x27;,&#x27;</span>)<br>&#125;<br>buf.WriteByte(s[i])<br>&#125;<br><span class="hljs-keyword">return</span> buf.String()<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 3.12：</strong> 编写一个函数，判断两个字符串是否是是相互打乱的，也就是说它们有着相同的字符，但是对应不同的顺序。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(isAnagram(<span class="hljs-string">&quot;1233&quot;</span>, <span class="hljs-string">&quot;3312&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s1, s2 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> s1 == s2 || <span class="hljs-built_in">len</span>(s1) != <span class="hljs-built_in">len</span>(s2) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><br>m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">rune</span>]<span class="hljs-type">int</span>, <span class="hljs-built_in">len</span>(s1))<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s1 &#123;<br>m[v]++<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> s2 &#123;<br><span class="hljs-keyword">if</span> m[v] == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>m[v]--<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-5-5-字符串和数字的转换"><a href="#3-5-5-字符串和数字的转换" class="headerlink" title="3.5.5. 字符串和数字的转换"></a>3.5.5. 字符串和数字的转换</h1><p><code>strconv</code>包可以将字符串和数字相互转换。</p><h2 id="整数转字符串"><a href="#整数转字符串" class="headerlink" title="整数转字符串"></a>整数转字符串</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">123</span><br>y := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x) <br>fmt.Println(y, strconv.Itoa(x)) <span class="hljs-comment">// 123 123</span><br></code></pre></td></tr></table></figure><p>有以下几种方法：</p><ul><li><code>fmt.Sprintf</code> 返回格式化的字符串。</li><li><code>strconv.Itoa</code>返回字符串 int转ASCII。</li></ul><p><code>Itoa</code>等价于<code>FormatInt</code>，同样的，还有类似的<code>FormatUint</code>。<br><code>FormatInt</code>和<code>FormatUint</code>函数可以用不同的进制来格式化数字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(strconv.FormatInt(<span class="hljs-type">int64</span>(x), <span class="hljs-number">2</span>)) <span class="hljs-comment">// 1111011 二进制</span><br>fmt.Println(strconv.FormatInt(<span class="hljs-type">int64</span>(x), <span class="hljs-number">8</span>)) <span class="hljs-comment">// 173 八进制</span><br>fmt.Println(strconv.FormatInt(<span class="hljs-type">int64</span>(x), <span class="hljs-number">10</span>)) <span class="hljs-comment">// 123 十进制</span><br>fmt.Println(strconv.FormatInt(<span class="hljs-type">int64</span>(x), <span class="hljs-number">16</span>)) <span class="hljs-comment">// 7b 十六进制</span><br></code></pre></td></tr></table></figure><p>同样，<code>fmt.Printf</code>函数的<code>%b</code>、<code>%o</code>、<code>%d</code>和<code>%x</code>等参数提供的功能比<code>strconv</code>包的<code>Format</code>函数强大很多，还可以附加额外信息:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(fmt.Sprintf(<span class="hljs-string">&quot;x=%08b&quot;</span>, x)) <span class="hljs-comment">// x=01111011</span><br>fmt.Println(fmt.Sprintf(<span class="hljs-string">&quot;x=%o&quot;</span>, x))   <span class="hljs-comment">// x=173</span><br>fmt.Println(fmt.Sprintf(<span class="hljs-string">&quot;x=%d&quot;</span>, x))   <span class="hljs-comment">// x=123</span><br>fmt.Println(fmt.Sprintf(<span class="hljs-string">&quot;x=% x&quot;</span>, x))  <span class="hljs-comment">// x= 7b</span><br></code></pre></td></tr></table></figure><h2 id="字符串转整数"><a href="#字符串转整数" class="headerlink" title="字符串转整数"></a>字符串转整数</h2><p>如果要将字符串转整数，有以下方法：</p><ul><li><code>strconv.Atoi</code>函数，返回<code>int</code>类型整数，ASCII转int。</li><li><code>strconv.ParseInt</code>函数，返回整数。还有解析无符号整数函数<code>strconv.ParseUint</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x, err := strconv.Atoi(<span class="hljs-string">&quot;123&quot;</span>) <br>y, err := strconv.ParseInt(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>) <span class="hljs-comment">// base 10, up to 64 bits</span><br></code></pre></td></tr></table></figure><p><code>strconv.ParseInt</code>函数的第三个参数是用于指定整型数的大小，如16表示int16，0则表示int。通常情况下，返回结果y总是int64类型。但注意范围大小。</p><p><code>strconv.ParseInt</code>函数的第二个参数是用于指定字符串前缀，如2为”0b”，8为”0”或”0o”，16为”0x”，10为其他，0为可以使用下划线字符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(strconv.ParseInt(<span class="hljs-string">&quot;01111011&quot;</span>, <span class="hljs-number">2</span>, <span class="hljs-number">64</span>)) <span class="hljs-comment">// 123 &lt;nil&gt;</span><br>fmt.Println(strconv.ParseInt(<span class="hljs-string">&quot;173&quot;</span>, <span class="hljs-number">8</span>, <span class="hljs-number">64</span>))      <span class="hljs-comment">// 123 &lt;nil&gt;</span><br>fmt.Println(strconv.ParseInt(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>))     <span class="hljs-comment">// 123 &lt;nil&gt;</span><br>fmt.Println(strconv.ParseInt(<span class="hljs-string">&quot;7b&quot;</span>, <span class="hljs-number">16</span>, <span class="hljs-number">64</span>))      <span class="hljs-comment">// 123 &lt;nil&gt;</span><br>fmt.Println(strconv.ParseInt(<span class="hljs-string">&quot;1_23&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">64</span>))     <span class="hljs-comment">// 123 &lt;nil&gt;</span><br></code></pre></td></tr></table></figure><p><code>fmt.Scanf</code>用于解析输入的字符串和数字，特别是字符串和数字混合一行时，可以灵活处理不完整或不规则的输入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> a <span class="hljs-type">int</span><br>fmt.Println(fmt.Scanf(<span class="hljs-string">&quot;混合%s%d&quot;</span>, &amp;s, &amp;a)) <span class="hljs-comment">// 2 &lt;nil&gt; 输入混合123 123</span><br>fmt.Println(s) <span class="hljs-comment">// 123</span><br>fmt.Println(a) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>多个输入时，空格或换行。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.4. 布尔型</title>
      <link href="/posts/d98a81de6430/"/>
      <url>/posts/d98a81de6430/</url>
      
        <content type="html"><![CDATA[<p><img src="/3.4.%20%E5%B8%83%E5%B0%94%E5%9E%8B/1679595785109.png" alt="bool"></p><h1 id="布尔值的运算"><a href="#布尔值的运算" class="headerlink" title="布尔值的运算"></a>布尔值的运算</h1><h2 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h2><p><code>!</code>对应逻辑非操作，<code>!true=false</code>，<code>!false=true</code>。</p><h2 id="二元运算符"><a href="#二元运算符" class="headerlink" title="二元运算符"></a>二元运算符</h2><p><code>&amp;&amp;</code>(AND)对应逻辑与<br><code>||</code>(OR)对应逻辑或<br>如果运算符左边已经可以确定整个布尔表达式的值，那么运算符右边的值将不被求值，因此下面的表达式并非异常：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;&quot;</span><br>fmt.Println(s != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment">// false</span><br>fmt.Println(s == <span class="hljs-string">&quot;&quot;</span> || s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>其中s[0]操作会导致panic异常。<br><strong><code>&amp;&amp;</code>的优先级比<code>||</code>高</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">c := <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span> || <br><span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> ||<br><span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;c is ASCII letter or digit&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="一些特别的"><a href="#一些特别的" class="headerlink" title="一些特别的"></a>一些特别的</h1><p>布尔值并不会隐式转换为数字值0或1，反之亦然，必须使用显式if语句辅助转换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> b &#123;<br>    i = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通常会进行包装：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// btoi returns 1 if b is true and 0 if false.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">btoi</span><span class="hljs-params">(b <span class="hljs-type">bool</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">if</span> b &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br><span class="hljs-comment">// itob reports whether i is non-zero.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">itob</span><span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">bool</span>  &#123;<br><span class="hljs-keyword">return</span> i != <span class="hljs-number">0</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.3. 复数</title>
      <link href="/posts/01a5b9d8501c/"/>
      <url>/posts/01a5b9d8501c/</url>
      
        <content type="html"><![CDATA[<p><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679562639256-1710774522762.png" alt="复数"></p><h1 id="3-3-1-复数的构建"><a href="#3-3-1-复数的构建" class="headerlink" title="3.3.1. 复数的构建"></a>3.3.1. 复数的构建</h1><p>复数构建：<code>complex()</code><br>返回复数的实部：<code>real()</code><br>返回复数的虚部：<code>imag()</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> y <span class="hljs-type">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br>fmt.Println(x)           <span class="hljs-comment">// (1 + 2i)</span><br>fmt.Println(x * y)       <span class="hljs-comment">// (1 + 2i) * (3 + 4i) = (1*3 - 2*4) + (2*3 + 1*4)i = -5 + 10i</span><br>fmt.Println(<span class="hljs-built_in">real</span>(x * y)) <span class="hljs-comment">// -5</span><br>fmt.Println(<span class="hljs-built_in">imag</span>(x * y)) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>复数的声明语句简化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">1</span> + <span class="hljs-number">2i</span><br>y := <span class="hljs-number">3</span> + <span class="hljs-number">4i</span><br></code></pre></td></tr></table></figure><h1 id="3-3-2-纯虚数"><a href="#3-3-2-纯虚数" class="headerlink" title="3.3.2. 纯虚数"></a>3.3.2. 纯虚数</h1><p>纯虚数，实部为0，如3.141592i。<br><code>i^2 = -1</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-number">1i</span> * <span class="hljs-number">1i</span>) <span class="hljs-comment">// (-1+0i), i^2 = -1</span><br></code></pre></td></tr></table></figure><h1 id="3-3-3-复数的比较"><a href="#3-3-3-复数的比较" class="headerlink" title="3.3.3. 复数的比较"></a>3.3.3. 复数的比较</h1><p>复数也可以使用&#x3D;&#x3D;和!&#x3D;进行相等比较，只有实部和虚部都相等时，复数才相等。<br>（注意浮点数比较的精度问题。）<br>复数无大小顺序之分。</p><h1 id="3-3-4-复数的运用"><a href="#3-3-4-复数的运用" class="headerlink" title="3.3.4. 复数的运用"></a>3.3.4. 复数的运用</h1><p>math&#x2F;cmplx包提供了复数处理的许多函数，例如求复数的平方根函数和求幂函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(cmplx.Sqrt(<span class="hljs-number">-1</span>)) <span class="hljs-comment">// (0+1i)</span><br>fmt.Println(cmplx.Exp(<span class="hljs-number">0</span>))   <span class="hljs-comment">// (1+0i)</span><br></code></pre></td></tr></table></figure><p>下面的程序使用complex128复数算法来生成一个Mandelbrot图像。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mandelbrot emits a PNG image of the Mandelbrot fractal.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br><span class="hljs-comment">// Image point(px,py) represents complex value z.</span><br>img.Set(px, py, mandlebrot(z))<br>&#125;<br>&#125;<br>png.Encode(os.Stdout, img) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandlebrot</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;<span class="hljs-number">255</span> - contrast*n&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br><br></code></pre></td></tr></table></figure><p><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679568526352.png" alt="The Mandelbrot set"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 3.5</strong>： 实现一个彩色的Mandelbrot图像，使用image.NewRGBA创建图像，使用color.RGBA或color.YCbCr生成颜色。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mandelbrot emits a PNG image of the Mandelbrot fractal.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br><span class="hljs-comment">// Image point(px,py) represents complex value z.</span><br>img.Set(px, py, acos(z))<br>&#125;<br>&#125;<br>png.Encode(os.Stdout, img) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">acos</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br>v := cmplx.Acos(z)<br>blue := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">real</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br>red := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">imag</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br><span class="hljs-keyword">return</span> color.YCbCr&#123;Y: <span class="hljs-number">192</span>, Cb: blue, Cr: red&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出图像：<br><img src="/3.3.%20%E5%A4%8D%E6%95%B0/out.png" alt="out"></p><p><strong>练习 3.6</strong>： 升采样技术可以降低每个像素对计算颜色值和平均值的影响。简单的方法是将每个像素分层四个子像素，实现它。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mandelbrot emits a PNG image of the Mandelbrot fractal.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">2048</span>, <span class="hljs-number">2048</span><br>)<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py += <span class="hljs-number">2</span> &#123;<br>y1 := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br>y2 := <span class="hljs-type">float64</span>(py+<span class="hljs-number">1</span>)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px += <span class="hljs-number">2</span> &#123;<br>x1 := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>x2 := <span class="hljs-type">float64</span>(px+<span class="hljs-number">1</span>)/width*(xmax-xmin) + xmin<br>z1 := <span class="hljs-built_in">complex</span>(x1, y1)<br>z2 := <span class="hljs-built_in">complex</span>(x1, y2)<br>z3 := <span class="hljs-built_in">complex</span>(x2, y1)<br>z4 := <span class="hljs-built_in">complex</span>(x2, y2)<br><span class="hljs-comment">// Image point (px, py) represents complex value z.</span><br>img.Set(px/<span class="hljs-number">2</span>, py/<span class="hljs-number">2</span>,<br>color.Gray&#123;Y: (mandelbrot(z1).Y +<br>mandelbrot(z2).Y +<br>mandelbrot(z3).Y +<br>mandelbrot(z4).Y) / <span class="hljs-number">4.0</span>&#125;)<br><br><span class="hljs-comment">// acos</span><br><span class="hljs-comment">//img.Set(px/2, py/2,</span><br><span class="hljs-comment">//color.YCbCr&#123;</span><br><span class="hljs-comment">//Y:  (acos(z1).Y + acos(z2).Y + acos(z3).Y + acos(z4).Y) / 4,</span><br><span class="hljs-comment">//Cb: (acos(z1).Cb + acos(z2).Cb + acos(z3).Cb + acos(z4).Cb) / 4,</span><br><span class="hljs-comment">//Cr: (acos(z1).Cr + acos(z2).Cr + acos(z3).Cr + acos(z4).Cr) / 4,</span><br><span class="hljs-comment">//&#125;)</span><br><br><span class="hljs-comment">// sqrt</span><br><span class="hljs-comment">//img.Set(px/2, py/2,</span><br><span class="hljs-comment">//color.YCbCr&#123;</span><br><span class="hljs-comment">//Y:  (sqrt(z1).Y + sqrt(z2).Y + sqrt(z3).Y + sqrt(z4).Y) / 4,</span><br><span class="hljs-comment">//Cb: (sqrt(z1).Cb + sqrt(z2).Cb + sqrt(z3).Cb + sqrt(z4).Cb) / 4,</span><br><span class="hljs-comment">//Cr: (sqrt(z1).Cr + sqrt(z2).Cr + sqrt(z3).Cr + sqrt(z4).Cr) / 4,</span><br><span class="hljs-comment">//&#125;)</span><br><br><span class="hljs-comment">// newton</span><br><span class="hljs-comment">//img.Set(px/2, py/2,</span><br><span class="hljs-comment">//color.Gray&#123;Y: (newton(z1).Y +</span><br><span class="hljs-comment">//newton(z2).Y +</span><br><span class="hljs-comment">//newton(z3).Y +</span><br><span class="hljs-comment">//newton(z4).Y) / 4.0&#125;)</span><br>&#125;<br>&#125;<br>png.Encode(os.Stdout, img)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Gray &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">255</span> - contrast*n&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">0</span>&#125;<br>&#125;<br><br><span class="hljs-comment">// Some other interesting functions.</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">acos</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.YCbCr &#123;<br>v := cmplx.Acos(z)<br>blue := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">real</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br>red := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">imag</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br><span class="hljs-keyword">return</span> color.YCbCr&#123;<br>Y:  <span class="hljs-number">128</span>,<br>Cb: blue,<br>Cr: red,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqrt</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.YCbCr &#123;<br>v := cmplx.Sqrt(z)<br>blue := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">real</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br>red := <span class="hljs-type">uint8</span>(<span class="hljs-built_in">imag</span>(v)*<span class="hljs-number">128</span>) + <span class="hljs-number">127</span><br><span class="hljs-keyword">return</span> color.YCbCr&#123;<br>Y:  <span class="hljs-number">128</span>,<br>Cb: blue,<br>Cr: red,<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newton</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Gray &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">37</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">7</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); i &lt; iterations; i++ &#123;<br>z -= (z - <span class="hljs-number">1</span>/(z*z*z)) / <span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> cmplx.Abs(z*z*z*z<span class="hljs-number">-1</span>) &lt; <span class="hljs-number">1e-6</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">255</span> - contrast*i&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">0</span>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679590373910.png" alt="mandelbrot"></p><p><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679590413010.png" alt="acos"></p><p><img src="/./images/1679590471597.png" alt="sqrt"></p><p><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679590518203.png" alt="newton"></p><p><strong>练习 3.7</strong>： 另一个生成分形图像的方式是使用牛顿法来求解一个复数方程，例如<code>!$ z^&#123;4&#125;-1=0 $</code>。每个起点到四个根的迭代次数对应阴影的灰度。方程根对应的点用颜色表示。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Mandelbrot emits a PNG image of the Mandelbrot fractal.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span><br>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;<br>y := <span class="hljs-type">float64</span>(py)/width*(xmax-xmin) + xmin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br><span class="hljs-comment">// Image point (px, py) represents complex value z.</span><br>img.Set(px, py, newton(z))<br>&#125;<br>&#125;<br>png.Encode(os.Stdout, img)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newton</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">37</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">7</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); i &lt; iterations; i++ &#123;<br>z -= (z - <span class="hljs-number">1</span>/(z*z*z)) / <span class="hljs-number">4</span><br><span class="hljs-keyword">if</span> cmplx.Abs(z*z*z*z<span class="hljs-number">-1</span>) &lt; <span class="hljs-number">1e-6</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">255</span> - contrast*i&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br></code></pre></td></tr></table></figure><p>输出图像：<br><img src="/3.3.%20%E5%A4%8D%E6%95%B0/1679591754515.png" alt="newton"></p><p><strong>练习 3.8</strong>： 通过提高精度来生成更多级别的分形。使用四种不同精度类型的数字实现相同的分形：complex64、complex128、big.Float和big.Rat。（后面两种类型在math&#x2F;big包声明。Float是有指定限精度的浮点数；Rat是无效精度的有理数。）它们间的性能和内存使用对比如何？当渲染图可见时缩放的级别是多少？<br>解：<br>mandelbrot.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/big&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot64</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex64</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + <span class="hljs-type">complex64</span>(z)<br><span class="hljs-keyword">if</span> cmplx.Abs(<span class="hljs-type">complex128</span>(v)) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">50</span> &#123;<br><span class="hljs-keyword">return</span> color.RGBA&#123;R: <span class="hljs-number">100</span>, A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>scale := math.Log(<span class="hljs-type">float64</span>(n)) / math.Log(<span class="hljs-type">float64</span>(iterations))<br><span class="hljs-keyword">return</span> color.RGBA&#123;B: <span class="hljs-number">255</span> - <span class="hljs-type">uint8</span>(scale*<span class="hljs-number">255</span>), A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot128</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">50</span> &#123;<br><span class="hljs-keyword">return</span> color.RGBA&#123;R: <span class="hljs-number">100</span>, A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>scale := math.Log(<span class="hljs-type">float64</span>(n)) / math.Log(<span class="hljs-type">float64</span>(iterations))<br><span class="hljs-keyword">return</span> color.RGBA&#123;B: <span class="hljs-number">255</span> - <span class="hljs-type">uint8</span>(scale*<span class="hljs-number">255</span>), A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrotBigFloat</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br>zR := (&amp;big.Float&#123;&#125;).SetFloat64(<span class="hljs-built_in">real</span>(z))<br>zI := (&amp;big.Float&#123;&#125;).SetFloat64(<span class="hljs-built_in">imag</span>(z))<br><span class="hljs-keyword">var</span> vR, vI = &amp;big.Float&#123;&#125;, &amp;big.Float&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); i &lt; iterations; i++ &#123;<br>vR2, vI2 := &amp;big.Float&#123;&#125;, &amp;big.Float&#123;&#125;<br>vR2.Mul(vR, vR).Sub(vR2, (&amp;big.Float&#123;&#125;).Mul(vI, vI)).Add(vR2, zR)<br>vI2.Mul(vR, vI).Mul(vI2, big.NewFloat(<span class="hljs-number">2</span>)).Add(vI2, zI)<br>vR, vI = vR2, vI2<br>squareSum := &amp;big.Float&#123;&#125;<br>squareSum.Mul(vR, vR).Add(squareSum, (&amp;big.Float&#123;&#125;).Mul(vI, vI))<br><span class="hljs-keyword">if</span> squareSum.Cmp(big.NewFloat(<span class="hljs-number">4</span>)) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">50</span> &#123;<br><span class="hljs-keyword">return</span> color.RGBA&#123;R: <span class="hljs-number">100</span>, A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>scale := math.Log(<span class="hljs-type">float64</span>(i)) / math.Log(<span class="hljs-type">float64</span>(iterations))<br><span class="hljs-keyword">return</span> color.RGBA&#123;B: <span class="hljs-number">255</span> - <span class="hljs-type">uint8</span>(scale*<span class="hljs-number">255</span>), A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrotBigRat</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br>zR := (&amp;big.Rat&#123;&#125;).SetFloat64(<span class="hljs-built_in">real</span>(z))<br>zI := (&amp;big.Rat&#123;&#125;).SetFloat64(<span class="hljs-built_in">imag</span>(z))<br><span class="hljs-keyword">var</span> vR, vI = &amp;big.Rat&#123;&#125;, &amp;big.Rat&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); i &lt; iterations; i++ &#123;<br>vR2, vI2 := &amp;big.Rat&#123;&#125;, &amp;big.Rat&#123;&#125;<br>vR2.Mul(vR, vR).Sub(vR2, (&amp;big.Rat&#123;&#125;).Mul(vI, vI)).Add(vR2, zR)<br>vI2.Mul(vR, vI).Mul(vI2, big.NewRat(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)).Add(vI2, zI)<br>vR, vI = vR2, vI2<br>squareSum := &amp;big.Rat&#123;&#125;<br>squareSum.Mul(vR, vR).Add(squareSum, (&amp;big.Rat&#123;&#125;).Mul(vI, vI))<br><span class="hljs-keyword">if</span> squareSum.Cmp(big.NewRat(<span class="hljs-number">4</span>, <span class="hljs-number">1</span>)) == <span class="hljs-number">1</span> &#123;<br><span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">50</span> &#123;<br><span class="hljs-keyword">return</span> color.RGBA&#123;R: <span class="hljs-number">100</span>, A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>scale := math.Log(<span class="hljs-type">float64</span>(i)) / math.Log(<span class="hljs-type">float64</span>(iterations))<br><span class="hljs-keyword">return</span> color.RGBA&#123;B: <span class="hljs-number">255</span> - <span class="hljs-type">uint8</span>(scale*<span class="hljs-number">255</span>), A: <span class="hljs-number">255</span>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br></code></pre></td></tr></table></figure><p>mandelbrot_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> mandelbrot<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bench</span><span class="hljs-params">(b *testing.B, f <span class="hljs-keyword">func</span>(complex1282 <span class="hljs-type">complex128</span>)</span></span> color.Color) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>f(<span class="hljs-built_in">complex</span>(<span class="hljs-type">float64</span>(i), <span class="hljs-type">float64</span>(i)))<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMandelbrotComplex64</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, mandelbrot64)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMandelbrotComplex128</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, mandelbrot128)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMandelbrotBigFloat</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, mandelbrotBigFloat)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkMandelbrotBigRat</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>bench(b, mandelbrotBigRat)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">goos: darwin</span><br><span class="hljs-comment">goarch: amd64</span><br><span class="hljs-comment">pkg: go-learn-gopl/ex/ex3/ex3.8</span><br><span class="hljs-comment">cpu: Intel(R) Core(TM) i7-7820HQ CPU @ 2.90GHz</span><br><span class="hljs-comment">BenchmarkMandelbrotComplex128</span><br><span class="hljs-comment">BenchmarkMandelbrotComplex64-8   20120569        57.30 ns/op</span><br><span class="hljs-comment">BenchmarkMandelbrotComplex128-8   19792554        55.43 ns/op</span><br><span class="hljs-comment">BenchmarkMandelbrotBigFloat-8    1730440       656.2 ns/op</span><br><span class="hljs-comment">BenchmarkMandelbrotBigRat-8     501489      2257 ns/op</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><strong>练习 3.9</strong>： 编写一个web服务器，用于给客户端生成分形的图像。运行客户端用过HTTP参数参数指定x,y和zoom参数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/png&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/cmplx&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;parse form err: %v&quot;</span>, err)<br>&#125;<br>x := firstOrDef(r.Form[<span class="hljs-string">&quot;x&quot;</span>], <span class="hljs-number">0</span>)<br>y := firstOrDef(r.Form[<span class="hljs-string">&quot;y&quot;</span>], <span class="hljs-number">0</span>)<br>zoom := firstOrDef(r.Form[<span class="hljs-string">&quot;zoom&quot;</span>], <span class="hljs-number">0</span>)<br>render(w, x, y, zoom)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">firstOrDef</span><span class="hljs-params">(forms []<span class="hljs-type">string</span>, def <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(forms) == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> def<br>&#125;<br><br>v, err := strconv.ParseFloat(forms[<span class="hljs-number">0</span>], <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> def<br>&#125;<br><span class="hljs-keyword">return</span> v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">render</span><span class="hljs-params">(out io.Writer, x, y, zoom <span class="hljs-type">float64</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>width, height = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span><br>)<br>exp2 := math.Exp2(<span class="hljs-number">1</span> - zoom)<br>xmin, xmax := x-exp2, x+exp2<br>ymin, ymax := y-exp2, y+exp2<br><br>img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<br><span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;<br>y := <span class="hljs-type">float64</span>(py)/height*(ymax-ymin) + ymin<br><span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;<br>x := <span class="hljs-type">float64</span>(px)/width*(xmax-xmin) + xmin<br>z := <span class="hljs-built_in">complex</span>(x, y)<br><span class="hljs-comment">// Image point (px, py) represent complex value z.</span><br>img.Set(px, py, mandelbrot(z))<br>&#125;<br>&#125;<br>png.Encode(out, img)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot</span><span class="hljs-params">(z <span class="hljs-type">complex128</span>)</span></span> color.Color &#123;<br><span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><br><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><br><br><span class="hljs-keyword">var</span> v <span class="hljs-type">complex128</span><br><span class="hljs-keyword">for</span> n := <span class="hljs-type">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;<br>v = v*v + z<br><span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> color.Gray&#123;Y: <span class="hljs-number">255</span> - contrast*n&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> color.Black<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.1. 整型</title>
      <link href="/posts/2a4f4f65e7ca/"/>
      <url>/posts/2a4f4f65e7ca/</url>
      
        <content type="html"><![CDATA[<p><img src="/3.1.%20%E6%95%B4%E5%9E%8B/1679232364704.png" alt="数值类型"></p><p>对应不同的CPU平台机器字大小的分为有符合和无符号整数<code>int</code>和<code>uint</code>。这两种类型都有对应32或64bit。</p><p><code>Unicode</code>字符<code>rune</code>类型是和<code>int32</code>等价的类型，通常用于表示一个人<code>Unicode</code>码。这两个名称可以互换使用，同样<code>byte</code>也是<code>unit8</code>类型的等价类型，<code>byte</code>类型一般用于强调数值是一个原始的数据而不是一个小的整数。</p><p>无符号的整数类型<code>uintptr</code>，没有指定具体的bit大小但是足以容纳指针。一般用于底层编程，如Go语言和C语言函数或操作系统接口相交互的地方。</p><p><code>int</code>和<code>int32</code>是不同类型，即使<code>int</code>的大小也是32bit，如果需要将<code>int</code>当做<code>int32</code>类型的地方需要一个显式的类型转换。</p><p>一个n-bit的有符号数的值域是<code>!$ -2^&#123;n-1&#125;$</code>到<code>!$ 2^&#123;n−1&#125;−1$</code>。<br>无符号整数的所有bit位都用于表示非负数，值域是0到<code>!$ 2^&#123;n&#125; - 1$</code>。<br>例如，<code>int8</code>类型整数的值域是从-128到127，而<code>uint8</code>类型整数的值域是从0到255。</p><p>下面是Go语言中的算数运算、逻辑运算和比较运算的二元运算符，按优先级递减的顺序排列：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">*      /      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^<br>+      -      |      ^<br>==     !=     &lt;      &lt;=       &gt;      &gt;=<br>&amp;&amp;<br>||<br></code></pre></td></tr></table></figure><p>如上所示，二元运算符有5种优先级。<br>同一个优先级中，使用左有效结合规则，但是可以使用括号可以明确优先顺序，使用括号也可以用于提升优先级。</p><p>对于上表中前两行的运算符，如<code>+</code>运算符还有一个与赋值相结合的对应运算符<code>+=</code>，也可以用于简化赋值语句。</p><p>算术运算符<code>+</code>、<code>-</code>、 <code>*</code>和<code>/</code>可以适用与于整数、浮点数和复数，但是取模运算符<code>%</code>仅用于整数间的运算。在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此-5%3和-5%-3结果都是-2。除法运算符&#x2F;的行为则依赖于操作数是否为全为整数，比如5.0&#x2F;4.0的结果是1.25，但是5&#x2F;4的结果是1，因为整数除法会向着0方向截断余数。</p><p>如果一个算数运算的结果，无论是有符号或无符号，如果需要更多bit位才能正确表示的话，就说明计算结果溢出了。超出的高位的bit位部分将被丢弃。<br>如果原始的数值是有符号类型，而且最左边的bit为1，那么最终结果可能为负，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> u <span class="hljs-type">uint8</span> = <span class="hljs-number">255</span><br>fmt.Println(u, u+<span class="hljs-number">1</span>, u*u) <span class="hljs-comment">// 255 0 1</span><br><br><span class="hljs-keyword">var</span> i <span class="hljs-type">int8</span> = <span class="hljs-number">127</span><br>fmt.Println(i, i+<span class="hljs-number">1</span>, i*i) <span class="hljs-comment">// 127 -128 1</span><br></code></pre></td></tr></table></figure><p><code>布尔型</code>、<code>数字类型</code>和<code>字符串</code>等基本类型都是可比较的。<br>可比较的类型值是可以根据比较结果排序的，反之，不可比较的类型的值是不可排序的。</p><p>一元的加法和减法运算符：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">+一元加法（无效果）<br>-   负数<br></code></pre></td></tr></table></figure><p>对于整数，<code>+x</code>是<code>0+x</code>的简写，<code>-x</code>则是<code>0-x</code>的简写;<br>对于浮点数和复数，<code>+x</code>就是x，<code>-x</code>则是<code>x</code>的负数。</p><p>bit位操作运算符，前四个操作运算符并不区分是有符号还是无符号：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&amp;      位运算 AND 按位与  两个都是1则为1<br>|      位运算 OR 按位或两个中有一个是1则为1<br>^      位运算 XOR 按位异或  相同为0，不同为1<br>&amp;^     位清空 (AND NOT) 相同位一样取0，相同位不同，取左边数的当前位值<br>&lt;&lt;     左移<br>&gt;&gt;     右移<br></code></pre></td></tr></table></figure><p>位操作运算符<code>^</code>作为二元运算符时是<code>按位异或</code>(XOR)，当做一元运算符时表示按位取反(每个bit位取反的数);<br>位操作运算符<code>&amp;^</code>用于<code>按位置零</code>（AND NOT）: 表达式<code>z = x &amp;^ y</code>结果z的bit位为0，如果对应y中bit位为1的话，否则对应的bit位等于x相应的bit位的值。</p><p>下面的代码演示了如何使用位操作解释uint8类型值的8个独立的bit位。它使用了Printf函数的%b参数打印二进制格式的数字；其中%08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span><br><span class="hljs-keyword">var</span> y <span class="hljs-type">uint8</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x) <span class="hljs-comment">// 00100010</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, y) <span class="hljs-comment">// 00000110</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&amp;y)  <span class="hljs-comment">// 00000010</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x|y)  <span class="hljs-comment">// 00100110</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x^y)  <span class="hljs-comment">// 00100100</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&amp;^y) <span class="hljs-comment">// 00100000</span><br><br><span class="hljs-keyword">for</span> i := <span class="hljs-type">uint</span>(<span class="hljs-number">0</span>); i &lt; <span class="hljs-number">8</span>; i++ &#123;<br><span class="hljs-keyword">if</span> x&amp;(<span class="hljs-number">1</span>&lt;&lt;i) != <span class="hljs-number">0</span> &#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">0 00100010 &amp; 00000001 = 00000000</span><br><span class="hljs-comment">1 00100010 &amp; 00000010 = 00000010</span><br><span class="hljs-comment">2 00100010 &amp; 00000100 = 00000000</span><br><span class="hljs-comment">3 00100010 &amp; 00001000 = 00000000</span><br><span class="hljs-comment">4 00100010 &amp; 00010000 = 00000000</span><br><span class="hljs-comment">5 00100010 &amp; 00100000 = 00100000</span><br><span class="hljs-comment">6 00100010 &amp; 01000000 = 00000000</span><br><span class="hljs-comment">7 00100010 &amp; 10000000 = 00000000</span><br><span class="hljs-comment">*/</span><br>fmt.Println(i) <span class="hljs-comment">// 1 5</span><br>&#125;<br>&#125;<br><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&lt;&lt;<span class="hljs-number">1</span>) <span class="hljs-comment">// 01000100</span><br>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&gt;&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">// 00010001</span><br></code></pre></td></tr></table></figure><p>移位运算中<code>x&lt;&lt;n</code>和<code>x&gt;&gt;n</code>，移位操作bit数n必须是无符号数，被操作数x可以是有符号或无符号说。<br>算术上，一个<code>x&lt;&lt;n</code>左移运算等价于乘以<code>!$ 2^n$</code>，一个<code>x&gt;&gt;n</code>右移运算等价于除以<code>!$2^n$</code>。</p><p>左移运算用0填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位。<br>有符号数的右移运算会用符号位的值填充左边空缺的bit位，所以最好使用无符号运算。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">medals := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;gold&quot;</span>, <span class="hljs-string">&quot;silver&quot;</span>, <span class="hljs-string">&quot;bronze&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(medals) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<br>fmt.Println(medals[i])<br>&#125;<br></code></pre></td></tr></table></figure><p>如果len函数返回一个无符号数，那么条件<code>i &gt;= 0</code>则永远为真。当i&#x3D;&#x3D;0时，i–将不会为-1，而是<code>uint</code>类型的最大值<code>!$ 2^&#123;64&#125; - 1$</code>，那么medals[i]表达式将发生运行时panic异常。</p><p>一般情况下，无符号数往往只有在位运算或其他特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。</p><p><code>%d</code> 十进制数输出<br><code>%o</code>八进制数输出 0<br><code>%x</code>十六进制数输出 0x 小写字母<br><code>%X</code>十六进制数输出 0X 大小字母</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">o := <span class="hljs-number">0666</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o) <span class="hljs-comment">// 438 666 0666</span><br>x := <span class="hljs-type">int64</span>(<span class="hljs-number">0xdeadbeef</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span>, x) <span class="hljs-comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span><br></code></pre></td></tr></table></figure><p><code>fmt</code>的两个技巧：</p><ul><li>通常<code>Printf</code>格式化字符串包含多个<code>%</code>参数时将会包含对应相同数量的额外操作数，但是<code>%</code>之后的<code>[1]</code>告诉<code>Printf</code>函数再次使用第一个操作数。</li><li>%后的<code>#</code>将告诉Printf在用<code>%o</code>、<code>%x</code>或<code>%X</code>输出时生成<code>0</code>、<code>0x</code>或<code>0X</code>前缀。</li></ul><p>字符通过转义的数值来表示任意的Unicode编码对应的字符。<br><code>%c</code>  字符打印输出<br><code>%q</code>  打印带单引号的字符</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ascii := <span class="hljs-string">&#x27;a&#x27;</span><br>unicode := <span class="hljs-string">&#x27;国&#x27;</span><br>newline := <span class="hljs-string">&#x27;\n&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]c %[1]q\n&quot;</span>, ascii) <span class="hljs-comment">// 97 a &#x27;a&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]c %[1]q\n&quot;</span>, unicode) <span class="hljs-comment">// 22269 国 &#x27;国&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;%d %[1]c %[1]q\n&quot;</span>, newline) <br><span class="hljs-comment">// 10 </span><br><span class="hljs-comment">//  &#x27;\n&#x27;</span><br><span class="hljs-comment">// &#x27;\n&#x27;前面是换行符&#123;换行\n&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 基础数据类型</title>
      <link href="/posts/0a1ced1a832c/"/>
      <url>/posts/0a1ced1a832c/</url>
      
        <content type="html"><![CDATA[<p>从底层来说，所有数据都是由bit组成，但计算机一般操作的是固定大小的数，如整数、浮点数、bit数组、内存地址等。进一步组合这些数据，就可以表达出更多对象。<br>内置的数据类型保证了硬件的特性和表达复杂数据结构的便捷性。</p><p><img src="/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/1679079034021.png" alt="go语言数据类型"></p><p><a href="/posts/2a4f4f65e7ca/">3.1. 整型</a></p><p><a href="">3.2. 浮点数</a></p><p><a href="/posts/01a5b9d8501c/">3.3. 复数</a></p><p><a href="/posts/d98a81de6430/">3.4. 布尔型</a></p><p><a href="/posts/a309a7c16f6a/">3.5. 字符串</a></p><p><a href="/posts/68c22f5501fb/">3.6. 常量</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.7. 作用域</title>
      <link href="/posts/5b89ef7a41d0/"/>
      <url>/posts/5b89ef7a41d0/</url>
      
        <content type="html"><![CDATA[<p>声明语句将程序中的实体和名字关联，如函数，变量。<br>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p><p>不能将作用域与生命周期混为一谈。<br>声明语句的作用域对应的是源代码的文本区域；是一个编译时的属性。<br>变量的生命周期是指程序运行的是变量存在的有效时间段，在此时间段内可以被程序的其它部分引用；是一个运行时的概念。</p><p><strong>语法块</strong>是由花括弧所包含的一系列语句，如函数体或循环体花括弧对应的语法块一样。<br>语法块内部声明的名字是无法被外部语法块访问的。<br>语法块决定了内部声明的名字的作用域范围。</p><ul><li>包含其它类似组批量声明等没有用花括弧包含的代码，称为语法块；</li><li>语法块为整个源代码时，称为全局语法块；</li><li>每个包的包语法块；</li><li>每个for、if和switch语句的语法块；</li><li>每个switch或select的分支也有独立的语法块；</li><li>显式书写的语法块（花括弧包含的语句）；</li></ul><p>声明语句对应的词法域决定了作用域范围的大小。<br>对应内置的类型、函数和常量，如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。<br>任何在函数外部（包级语法域）声明的名字可以在同一个包的任何源文件中访问的。<br>对于导入的包，如<code>fmt</code>包，则是对应源文件级的作用域，因此只能在当前文件中文件中访问导入的包，当前包的其它源文件无法访问在当前源文件中导入的包。<br>还有许多声明语句，如<code>tempconv.CToF</code>函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能局部的某些部分）访问。</p><p>控制流符号，就是<code>break</code>、<code>continue</code>或<code>goto</code>语句后面跟着的那种标号，则是函数级的作用域。</p><p>一个程序中可能包含多个同名的声明，但只需要它们在不同的词法域中。<br>如，局部变量和包级的变量同名；或函数参数名字声明为new，虽然内置的new是全局作用域的。<br>如果滥用不同词法域可重名的特性，可能导致程序的可读性变差。</p><p>当编译器编译到一个名字引用时，如果是一个声明，它首先从最内层的词法域向全局作用域查找。<br>如果查找失败，则报错<code>未声明的名字</code>这样的错误。<br>如果该名字在内部和外部的语法块分别声明过，则内部块的声明首先会被找到。<br>这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。<br>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> g = <span class="hljs-string">&quot;g&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := <span class="hljs-string">&quot;f&quot;</span><br>    fmt.Println(f) <span class="hljs-comment">// &quot;f&quot;; local var f shadows package-level func f</span><br>    fmt.Println(g) <span class="hljs-comment">// &quot;g&quot;; package-level var</span><br>    fmt.Println(h) <span class="hljs-comment">// compile error: undefined: h</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在函数中词法域可以深度嵌套，因此内部的声明可以屏蔽外部的声明。<br>下面的代码有三个不同的变量x，因为它们是定义在不同的词法域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := <span class="hljs-string">&quot;hello!&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(x); i++ &#123;<br>        x := x[i]<br>        <span class="hljs-keyword">if</span> x != <span class="hljs-string">&#x27;!&#x27;</span> &#123;<br>            x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span><br>            fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面for语句副本创建了两个词法域：一个显式部分是for的循环体部分词法域，另一个隐式部分是循环的初始化部分（迭代变量i的初始化）。隐式的词法域部分的作用域还包含了条件测试部分和循环后的迭代部分（i++），还包含了循环体词法域。<br>在x[i]和x + ‘A’ - ‘a’声明语句的初始化的表达式中都引用了外部作用域声明的x变量。</p><p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> x &#123;<br>        x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span><br>        fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x := f(); x == <span class="hljs-number">0</span> &#123;<br>    fmt.Println(x)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y := g(x); x == y &#123;<br>    fmt.Println(x, y)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(x, y)<br>&#125;<br>fmt.Println(x, y) <span class="hljs-comment">// compile error: x and y are not visible here</span><br></code></pre></td></tr></table></figure><p>第二个if语句被嵌套在第一个if语句的内部，因此在第一个if语句条件初始化词法域声明的变量在第二个if语句中也可以访问。<br>switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后每个是每个分支的词法域。</p><p>在包级别，声明的顺序并不影响作用域范围，因此先声明的可以引用它自身或者引用后面的声明，这样就可以定义一些相互嵌套或递归的类型或函数。<br>如果变量或常量递归引用了自身，则会产生编译错误。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.6. 包和文件</title>
      <link href="/posts/4bd2d633ee16/"/>
      <url>/posts/4bd2d633ee16/</url>
      
        <content type="html"><![CDATA[<p>包的存在是为了支持模块化、封装、单独编译和代码重用。</p><p>每个包都对应一个独立的命名空间。如: <code>image</code>包中的<code>Decode</code>函数和在<code>unicode/uft16</code>包中的<code>Decode</code>函数是不同的。要在外部引用该函数，必须显式使用<code>image.Decode</code>或<code>uft16.Decode</code>形式来访问。</p><p>包还可以实现可见性。规则：以大写字母开头的，那么该名字是可导出的。（因为中文汉字不区分大小写，因此汉字开头的名字是不可导出的。）</p><p>在每个源文件的包声明前是包注释。<br>包注释的第一句为包的功能概要说明。<br>通常情况下，包内只有一个源文件有包注释，如有多个包注释，文档工具会根据源文件名的先后顺序将包注释链接为一个包注释。<br>如果包注释很大，通常会放到单独的<code>doc.go</code>文件中。</p><p><strong>练习 2.1：</strong> 向tempconv包添加类型、常量和函数用来处理Kelvin绝对温度的转换，Kelvin 绝对零度是−273.15°C，Kelvin绝对温度1K和摄氏度1°C的单位间隔是一样的。<br>解答：<br>tempconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package tempconv performs Celsius and Fahrenheit conversions.</span><br><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Kelvin <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">const</span> (<br>AbsoluteZeroC Celsius = <span class="hljs-number">-273.15</span><br>FreezingC     Celsius = <span class="hljs-number">0</span><br>BoilingC      Celsius = <span class="hljs-number">100</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Fahrenheit)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°F&quot;</span>, f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Kelvin)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%gK&quot;</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure><p>conve.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-comment">// CToF converts a Celsius temperature to Fahrenheit.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-comment">// FToC converts a Fahrenheit temperature to Celsius.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)<br>&#125;<br><br><span class="hljs-comment">// CToK converts a Celsius temperature to Kelvin.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToK</span><span class="hljs-params">(c Celsius)</span></span> Kelvin &#123;<br><span class="hljs-keyword">return</span> Kelvin(c)<br>&#125;<br><br><span class="hljs-comment">// KToC converts a Kelvin temperature to Celsius.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KToC</span><span class="hljs-params">(k Kelvin)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius(k)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-6-1-导入包"><a href="#2-6-1-导入包" class="headerlink" title="2.6.1. 导入包"></a>2.6.1. 导入包</h1><p>每个包都是有一个全局唯一的导入路径。如：<code>go-learn-gopl/ch/ch2/tempconv</code>。<br>一个导入路径代表一个目录中的一个或多个Go源文件。</p><p>除了包路径，每个包还有一个包民，包名通常是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。<br>通常，包的名字和包的导入路径的最后一个字段相同，如<code>go-learn-gopl/ch/ch2/tempconv</code>包的名字一般是<code>tempconv</code>。</p><p>要使用<code>go-learn-gopl/ch/ch2/tempconv</code>包，需要先导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cf converts its numeric argument to Celsius and Fahrenheit.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch2/tempconv&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>t, err := strconv.ParseFloat(arg, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;cf: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>f := tempconv.Fahrenheit(t)<br>c := tempconv.Celsius(t)<br>fmt.Printf(<span class="hljs-string">&quot;%s=%s, %s=%s\n&quot;</span>, f, tempconv.FToC(f), c, tempconv.CToF(c))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cf程序是将命令行输入的一个温度在<code>Celsius</code>和<code>Fahrenheit</code>温度单位之间转换:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ go build ./ch/ch2/cf/main.go <br>$ ./main 24.2<br>24.2°F=-4.333333333333333°C, 24.2°C=75.56°F<br><br></code></pre></td></tr></table></figure><p>如果导入一个包，但是却没有使用，就将会被当做编译错误处理。<br>这种强制规则可以有效减少不必要的依赖。<br>可以使用<code>golang.org/x/tools/cmd/goimports</code>导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成<code>goimports</code>工具，然后在保存文件时自动运行。类似还有<code>gofmt</code>工具，用于格式化Go源文件。</p><p><strong>练习 2.2：</strong> 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。<br>unitconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package unitconv performs Meter and Foot, Pounds and Kilogram conversions.</span><br><span class="hljs-keyword">package</span> unitconv<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Meter <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Foot <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> Pounds <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Kilogram <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Meter)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g m&quot;</span>, m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foot)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g ft&quot;</span>, f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Pounds)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g lb&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Kilogram)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g kg&quot;</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure><p>conv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> unitconv<br><br><span class="hljs-comment">// MToF converts Meter to Foot.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MToF</span><span class="hljs-params">(m Meter)</span></span> Foot &#123;<br><span class="hljs-keyword">return</span> Foot(m * <span class="hljs-number">3.28083989501</span>)<br>&#125;<br><br><span class="hljs-comment">// FToM converts Foot to Meter.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToM</span><span class="hljs-params">(f Foot)</span></span> Meter &#123;<br><span class="hljs-keyword">return</span> Meter(f * <span class="hljs-number">0.3048</span>)<br>&#125;<br><br><span class="hljs-comment">// KToP converts Kilogram to Pounds.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KToP</span><span class="hljs-params">(k Kilogram)</span></span> Pounds &#123;<br><span class="hljs-keyword">return</span> Pounds(k * <span class="hljs-number">2.20462262185</span>)<br>&#125;<br><br><span class="hljs-comment">// PToK converts Pounds to Kilogram.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PToK</span><span class="hljs-params">(p Pounds)</span></span> Kilogram &#123;<br><span class="hljs-keyword">return</span> Kilogram(p * <span class="hljs-number">0.4535924</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>uconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex2/unitconv&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> m = flag.Float64(<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Meter to Foot.&quot;</span>)<br><span class="hljs-keyword">var</span> f = flag.Float64(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Foot to Meter.&quot;</span>)<br><span class="hljs-keyword">var</span> k = flag.Float64(<span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Kilogram to Pounds.&quot;</span>)<br><span class="hljs-keyword">var</span> p = flag.Float64(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Pounds to Kilogram.&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> *m &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Meter(*m), unitconv.MToF(unitconv.Meter(*m)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *f &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Foot(*f), unitconv.FToM(unitconv.Foot(*f)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *k &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Kilogram(*k), unitconv.KToP(unitconv.Kilogram(*k)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *p &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Pounds(*p), unitconv.PToK(unitconv.Pounds(*p)))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Fprintln(os.Stderr, <span class="hljs-string">&quot;value must be granter than 0.&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ go build conv/uconv.go<br>$ ./uconv -m 1<br>1 m = 3.28083989501 ft<br>$ ./uconv -f 1<br>1 ft = 0.3048 m<br>$ ./uconv -k 10<br>10 kg = 22.0462262185 lb<br>$ ./uconv -p 2<br>2 lb = 0.9071848 kg<br>$ ./uconv -m -1<br>value must be granter than 0.<br>$ ./uconv -h<br>Usage of ./uconv:<br>  -f float<br><span class="hljs-code">        converts Foot to Meter. (default -1)</span><br><span class="hljs-code">  -k float</span><br><span class="hljs-code">        converts Kilogram to Pounds. (default -1)</span><br><span class="hljs-code">  -m float</span><br><span class="hljs-code">        converts Meter to Foot. (default -1)</span><br><span class="hljs-code">  -p float</span><br><span class="hljs-code">        converts Pounds to Kilogram. (default -1)</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h1 id="2-6-2-包的初始化"><a href="#2-6-2-包的初始化" class="headerlink" title="2.6.2. 包的初始化"></a>2.6.2. 包的初始化</h1><p>包的初始化首先是解决包级变量的依赖顺序，然后安装包级变量声明出现的顺序依次初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = b + c <span class="hljs-comment">// a 第三个初始化, 为 3</span><br><span class="hljs-keyword">var</span> b = f()   <span class="hljs-comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>     <span class="hljs-comment">// c 第一个初始化, 为 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> c + <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，但有些数据初始化并非一个简单的赋值过程。这种情况下，可以使用<code>init</code>初始化函数来简化初始化工作，每个文件都可以包含多个<code>init</code>初始化函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>init</code>初始化函数除了不能被调用或引用外，其他行为与普通函数无异。<br>每个文件中的<code>init</code>初始化函数，在程序开始执行时按照声明的顺序被自动调用。</p><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。<br>如果<code>p</code>包导入了<code>q</code>包，那么在<code>p</code>包初始化的时候可以认为<code>q</code>包必然已经初始化过了。<br>初始化工作时自下而上进行的，<code>main</code>包最后被初始化。确保在<code>main</code>函数执行之前，所有依赖的包都已经完成初始化。</p><p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如果预生成辅助表格，这是编程中常用的技术）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br></code></pre></td></tr></table></figure><p>pc可以将初始化逻辑包装为匿名函数处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span> = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>for循环只用到索引部分，可以使用<code>_</code>忽略值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> pc &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 2.3：</strong> 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）<br>解答：<br>popcount.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 2.4：</strong> 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异。<br>解答：<br>popcount.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitShift returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitShift</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++ &#123;<br><span class="hljs-keyword">if</span> (x&gt;&gt;i)&amp;<span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitShift</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitShift(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitShift</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitShift(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 2.5：</strong> 表达式x&amp;(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitShift returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitShift</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++ &#123;<br><span class="hljs-keyword">if</span> (x&gt;&gt;i)&amp;<span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitClear returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitClear</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br>x &amp;= x - <span class="hljs-number">1</span><br>c++<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitShift</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitShift(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitClear</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitClear(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitShift</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitShift(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitClear</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitClear(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.5. 类型</title>
      <link href="/posts/9f13bfd0f9d8/"/>
      <url>/posts/9f13bfd0f9d8/</url>
      
        <content type="html"><![CDATA[<p>变量或表达式的类型定义了对应存储值的属性特征，如：</p><ul><li>值在内存的存储大小（或者是元素的bit个数）。</li><li>它们在内部是如何表达的。</li><li>是否支持一些操作符。</li><li>它们自己关联的方法集。</li></ul><p>类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。<br>新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名称 底层类型<br></code></pre></td></tr></table></figure><p>类型声明语句一般出现在包一级，且新的类型名称首字母大写，则在外部包也可以使用。<br>注：对于中文汉字，Unicode标志都作为小写字母处理，因此不能将其命名导出。<br>为了说明类型声明，将不同温度单位分别定义为不同的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span><br><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span>    <span class="hljs-comment">// 摄氏温度</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span> <span class="hljs-comment">// 华氏温度</span><br><br><span class="hljs-keyword">const</span> (<br>AbsoluteZeroC Celsius = <span class="hljs-number">-273.15</span> <span class="hljs-comment">// 绝对零度</span><br>FreezingC     Celsius = <span class="hljs-number">0</span>       <span class="hljs-comment">// 结冰温度</span><br>BoilingC      Celsius = <span class="hljs-number">100</span>     <span class="hljs-comment">// 沸水温度</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Celsius(t)</code>和<code>Fahrenheit(t)</code>是类型转换操作，并非函数调用。<br>对于每一个类型T，都有一个对应的类型转换操作T(x)，将x转为T类型。<br>如果T是指针类型，可能需要用小括弧包装T，如<code>(*int)(0)</code>。<br><code>只有当两个类型的底层基础类型相同时，才允许类型转换, 或者两者都是指向相同底层结构的指针类型。</code><br>如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型。</p><p>数值类型之间的类型转换也是允许的，并且字符串和一些特定类型的slice之间也是可以转换，但有可能改变值。<br>如：浮点数转换为整数将丢弃小数部分；字符串转为<code>[]byte</code>类型的slice将拷贝一个人字符串数据的副本。</p><p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, BoilingC - FreezingC) <span class="hljs-comment">// 100°C</span><br>boilingF := CToF(BoilingC)<br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, boilingF-CToF(FreezingC)) <span class="hljs-comment">// 180°F</span><br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, boilingF-FreezingC) <span class="hljs-comment">//  Invalid operation: boilingF-FreezingC (mismatched types Fahrenheit and Celsius)</span><br></code></pre></td></tr></table></figure><p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但如果两个值有着不同的类型，则不能直接进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c Celsius<br><span class="hljs-keyword">var</span> f Fahrenheit<br>fmt.Println(c == <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span><br>fmt.Println(f &gt;= <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span><br>fmt.Println(c == f)          <span class="hljs-comment">// compile error: type mismatch</span><br>fmt.Println(c == Celsius(f)) <span class="hljs-comment">// &quot;true&quot;!</span><br></code></pre></td></tr></table></figure><p><code>Celsius(f)</code>是类型转换操作，并不会改变值，仅改变了值的类型。</p><p>命名类型更方便书写，避免重复书写复杂类型，如匿名结构体定义变量。</p><p>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，即类型的方法集。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123; <br> <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c) <br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，类型都会定义一个<code>String</code>方法，当使用<code>fmt</code>包的打印方法时，将优先使用该类型对应的<code>String</code>方法返回的结果打印。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">c := FToC(<span class="hljs-number">212.0</span>)<br>fmt.Println(c.String()) <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;; no need to call String explicitly</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Println(c)          <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100&quot;; does not call String</span><br>fmt.Println(<span class="hljs-type">float64</span>(c)) <span class="hljs-comment">// &quot;100&quot;; does not call String</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.3.变量</title>
      <link href="/posts/7095472d910d/"/>
      <url>/posts/7095472d910d/</url>
      
        <content type="html"><![CDATA[<p><code>var</code>声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。<br>变量声明的一般语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名称 类型 = 表达式<br></code></pre></td></tr></table></figure><p>类型或”&#x3D;表达式”两个部分可以省略其中的一个。<br>如果省略的是类型，那么将根据初始化表达式来推导变量的类型。<br>如果初始化表达式被省略，那么将用零值初始化该变量。<br>数值类型变量对应的零值是<code>0</code>，布尔类型变量对应的零值是<code>false</code>，字符串类型对应的零值是<code>空字符串</code>，接口或引用类型（包含slice、map、chan和函数）变量对应的零值是<code>nil</code>。数组或结构体等聚合类型对应的零值是每一个元素或字段都是对应该类型的零值。</p><p>零值初始化机制可以确保每一个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。该特性可以简化代码，确保边界条件下的合理行为。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Println(s) <span class="hljs-comment">//&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>该代码将打印一个空字符串，而非导致错误或产生不可以预知的行为。<br>所以也应该使一些聚合类型的零值有一定意义，可以确保不管任何类型的变量总是有一个合理有效的零值状态。</p><p>简化变量的类型，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span><span class="hljs-comment">//int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;four&quot;</span> <span class="hljs-comment">// bool, float64, string</span><br></code></pre></td></tr></table></figure><p> 一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f, err = os.Open(name) <span class="hljs-comment">// os.Open returns a file and an error</span><br></code></pre></td></tr></table></figure></p><h1 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1. 简短变量声明"></a>2.3.1. 简短变量声明</h1><p>简短变量声明语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">名字:=表达式<br></code></pre></td></tr></table></figure><p>变量的类型根据表达式来自动推导。<br>下面有几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">100</span> <span class="hljs-comment">// an int</span><br><span class="hljs-keyword">var</span> boiling <span class="hljs-type">float64</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// a float64</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">var</span> p Point<br></code></pre></td></tr></table></figure><p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>:=</code>是一个变量声明语句。<br><code>=</code>是一个变量赋值操作。</p><p>简短变量声明语句中必须至少要声明一个新的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">f,err := os.Open(infile) <span class="hljs-comment">// 简短声明语句</span><br>f, err = os.Create(outfile) <span class="hljs-comment">// 赋值语句</span><br></code></pre></td></tr></table></figure><h1 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2. 指针"></a>2.3.2. 指针</h1><p>一个变量对应一个保存了变量对应类型值的内存空间。<br>一个指针的值是另一个变量的地址。<br>一个指针对应一个变量在内存中的存储位置。<br>并不是每一个值都有一个内存地址，但是对于每一个变量必然有对应的内存地址。<br>通过指针，可以直接读或更新对应变量的值。</p><p>如果用<code>var x int</code>声明语句声明一个<code>x</code>变量，那么<code>&amp;x</code>表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为<code>指向int类型的指针</code>。如果指针名字为p，那么可以说<code>p指针指向变量x</code>，或者说<code>p指针保存了x变量的内存地址</code>。同时<code>*p</code>表达式对应<code>p指针</code>指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为<code>int</code>类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。<br><code>&amp;</code>取址符<br><code>*</code>取值符<br><code>*int</code>指向int类型的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">1</span><br>p := &amp;x <span class="hljs-comment">// p, 类型*int,指向变量x</span><br>fmt.Println(*p) <span class="hljs-comment">// 1</span><br>*p = <span class="hljs-number">2</span><span class="hljs-comment">// 给x赋值2 等同于x=2</span><br>fmt.Println(x) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>对应聚合类型的每一个成员，如结构体的每个字段，数组的每个元素，也都是对应一个变量，因此也可以被取地址。</p><p>变量有时候被称为可寻址的值，即使变量由表达式临时生成，那么表达式也必须能接受<code>&amp;</code>取地址操作。</p><p>任何类型的指针的零值都是<code>nil</code>。如果<code>p != nil</code>为真，那么<code>p</code>是指向某个有效变量。指针之间同一个变量或全为<code>nil</code>时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true false false</span><br></code></pre></td></tr></table></figure><p>在Go语言中，返回函数中局部变量的地址也是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p = f()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>v := <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> &amp;v<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用f函数都返回不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(f()==f()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>通过指针改变变量的值，例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incr</span><span class="hljs-params">(p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>*p++<span class="hljs-comment">// 只是增加p指向的变量的值，并不改变p指针！！！</span><br><span class="hljs-keyword">return</span> *p<br>&#125;<br><br>v := <span class="hljs-number">1</span><br>incr(&amp;v)<span class="hljs-comment">// side effect: v is now 2</span><br>fmt.Println(incr(&amp;v))<span class="hljs-comment">// 3 and v is 3</span><br></code></pre></td></tr></table></figure><p>每次对变量取地址或者复制指针，都是为原变量创建了新别名。如，<code>*p</code>就是变量<code>v</code>的别名。<br>指针的特有价值是在于可以不通过名称而访问变量，但是也是一把双刃剑：<br>要找到一个变量的所有访问者并不容易，就必须知道变量全部的别名（即Go语言的垃圾回收器所做的工作）。</p><p>指针式实现标准库中<code>flag</code>包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。<br>在先前的<code>echo</code>版本中，就包含了两个可选的命令行参数：<code>-n</code>用于忽略行尾的换行符，<code>-s sep</code>用于指定分隔字符（默认是空格）。下面是新的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo4 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> n = flag.Bool(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;omit trailing newline&quot;</span>)<br><span class="hljs-keyword">var</span> sep = flag.String(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;separator&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>fmt.Print(strings.Join(flag.Args(), *sep))<br><span class="hljs-keyword">if</span> !*n &#123;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flag.Bool</code>函数会创建一个新的对应布尔型标志参数的变量。它有三个参数：</p><ul><li>第一个是命令行标志参数的名字，<code>n</code>。</li><li>第二个是第一个参数的默认值，<code>false</code>。</li><li>第三个是第一个标志参数对应的描述信息，<code>omit trailing newline</code>。</li></ul><p>如果用户在命令行输入了一个无效的标志参数，或输入<code>-n</code>或<code>-help</code>参数，那么将打印所有标志参数的名字、默认值和描述信息。<br>当然，<code>flag.String</code>函数与<code>flag.Bool</code>函数的区别在于，命令行标志参数的值类型不同罢了。<br>程序中的<code>sep</code>和<code>n</code>变量分别是指向命令行标志参数变量的指针，因此必须使用<code>*sep</code>和<code>*n</code>形式的指针语法简接引用它们。<br>在使用标志参数对应的变量之前，要先调用<code>flag.Parse</code>函数，用于更新每个标志参数对应变量的值（之前是默认值）。<br>对于非标志参数的普通命令行参数可以通过调用<code>flag.Args()</code>函数来访问，返回值对应一个字符串类型的<code>slice</code>。<br>如果在<code>flag.Parse</code>函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用<code>os.Exit(2)</code>终止程序。<br>下面是<code>echo</code>的测试用例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build main.go</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main a bc def</span><br>a bc def<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -s / a bc def</span><br>a/bc/def<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -f</span><br>flag provided but not defined: -f<br>Usage of ./main:<br>  -n    omit trailing newline<br>  -s string<br>        separator (default &quot; &quot;)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -h</span><br>Usage of ./main:<br>  -n    omit trailing newline<br>  -s string<br>        separator (default &quot; &quot;)<br></code></pre></td></tr></table></figure><h1 id="2-3-3-new函数"><a href="#2-3-3-new函数" class="headerlink" title="2.3.3. new函数"></a>2.3.3. new函数</h1><p>另一个创建变量的方法是调用内建的<code>new</code>函数。<br>表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) <span class="hljs-comment">// p,*int类型，指向匿名的int变量</span><br>fmt.Println(*p) <span class="hljs-comment">// 0</span><br>*p = <span class="hljs-number">2</span><span class="hljs-comment">// 设置int匿名变量的值为2</span><br>fmt.Println(*p) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用<code>new</code>创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外。<br>换言之，<code>new</code>函数类似一种语法糖，而不是一个新的基础概念。<br>下面的两个<code>newInt</code>函数有着相同的行为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> dummy <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> &amp;dummy<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用<code>new</code>函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>q := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>fmt.Println(p == q) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是也有一种特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如<code>struct&#123;&#125;</code>和<code>[0]int</code>，有可能有相同的地址。<br>慎用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体可查<code>runtime.SetFinalizer</code>函数相关文档。</p><p>由于<code>new</code>只是一个预定义的函数，它并不是一个关键字，因此可以将<code>new</code>名字重新定义为别的类型。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delta</span><span class="hljs-params">(old, <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> - old<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>new</code>被定义为<code>int</code>类型的变量名，因此在<code>deltal</code>函数内部无法使用内置的<code>new</code>函数。</p><h1 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h1><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。<br>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。<br>而局部变量的生命周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的内存空间可能被回收。<br>函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>    x := math.Sin(t)<br>    y := math.Sin(t*freq + phase)<br>    img.SetColorIndex(<br>        size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>),<br>        blackIndex, <span class="hljs-comment">// 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br>    )               <span class="hljs-comment">// 小括弧另起一行缩进，和大括弧的风格保存一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环的开始都会创建临时变量<code>t</code>，然后在每次循环迭代中创建临时变量<code>x</code>和<code>y</code>。</p><p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？<br>基本实现思路：从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。<br>因为一个变量的有效生命周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能会超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<br>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但这个选择并不是由用<code>var</code>还是<code>new</code>声明变量的方式决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global *<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>x = <span class="hljs-number">1</span><br>global = &amp;x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>y := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*y = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>f</code>函数里的<code>x</code>变量一定是在堆上分配的，因为它在函数退出后依然可以通过包一级的<code>global</code>变量找到，尽管它是在函数内部定义的。即可以说，这个<code>x</code>局部变量从函数<code>f</code>中逃逸了。<br>相反，当<code>g</code>函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数<code>g</code>中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（也可以选择在堆上分配，然后有Go语言的GC回收这个变量的内存空间），虽然这里使用了<code>new</code>方式。</p><p>其实在编写代码时不需要特意去考虑变量的逃逸行为，但是逃逸的变量需要额外分配内存空间，同时对性能可能会产生影响。</p><p>虽然自动垃圾收集器可以帮助我们不需要显式地分配和释放内存，但是编写高效的程序时依然需要了解变量的生命周期。<br>如将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收，从而可能影响程序的性能。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.4. 赋值</title>
      <link href="/posts/3bab4b966165/"/>
      <url>/posts/3bab4b966165/</url>
      
        <content type="html"><![CDATA[<p>使用赋值语句可以更新一个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">x = <span class="hljs-number">1</span><span class="hljs-comment">// 命名变量的赋值</span><br>*p = <span class="hljs-literal">true</span><span class="hljs-comment">// 通过指针间接赋值</span><br>person.name = <span class="hljs-string">&quot;bob&quot;</span><span class="hljs-comment">// 结构体字段赋值</span><br>count[x] = count[x] * scale <span class="hljs-comment">// 数组、slice或map的元素赋值</span><br></code></pre></td></tr></table></figure><p>二元算术运算符和赋值语句的复合操作可以进行简化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">count[x] *= scale<br></code></pre></td></tr></table></figure><p>数值变量也可以支持<code>++</code>递增和<code>--</code>递减语句（自增和自减是语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v := <span class="hljs-number">1</span><br>v++<span class="hljs-comment">// 等价 v = v + 1； v变成2</span><br>v--<span class="hljs-comment">// 等价 v = v - 1； v变成1</span><br></code></pre></td></tr></table></figure><h1 id="2-4-1-元组赋值"><a href="#2-4-1-元组赋值" class="headerlink" title="2.4.1. 元组赋值"></a>2.4.1. 元组赋值</h1><p>元组赋值允许同时更新多个变量的值。<br>赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。<br>下面是对变量的值进行交换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x, y = y, x<br>a[i], a[j] = a[j], a[i]<br></code></pre></td></tr></table></figure><p>下面是计算两个整数值的最大公约数(<code>GCD</code>, greatest common divisor)，欧几里得的GCD是最早的非平凡算法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> y != <span class="hljs-number">0</span> &#123;<br>x, y = y, x%y<br>&#125;<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>计算斐波那契数列（Fibonacci）的第N个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>x, y = y, x+y<br>&#125;<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>元组赋值可以简化一系列琐碎赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i, j, k = <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>但如果表达式太复杂，尽量避免过度使用元组赋值；单独对每个变量赋值的会提高代码的可读性。</p><p>表达式产生多个值时，左边变量数目必须和右边一致：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err = os.Open(<span class="hljs-string">&quot;foo.txt&quot;</span>) <span class="hljs-comment">// function call returns two values</span><br></code></pre></td></tr></table></figure><p>通常，这类函数会用额外的返回值来表达某种错误类型。如<code>os.Open</code>。<br>还有一些是用来返回布尔值，通常被称为ok，如<code>map查找</code>、<code>类型断言</code>和<code>通道接收</code>，都可能产生了两个结果，有一个额外的布尔结果表示操作是否成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok = m[key]<span class="hljs-comment">// map lookup  map查找</span><br>v, ok = x.(T)<span class="hljs-comment">// type assertion类型断言</span><br>v, ok = &lt;-ch        <span class="hljs-comment">// channel receive通道接收</span><br></code></pre></td></tr></table></figure><p>值得一提的是，<code>map查找</code>、<code>类型断言</code>和<code>通道接收</code>并不一定参数两个结果，也可能只产生一个结果。<br>如：</p><ul><li>map查找失败时会返回零值。</li><li>类型断言失败时会发送运行时painc异常。</li><li>通道接收失败时会返回零值（阻塞不算是失败）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">v = m[key] <span class="hljs-comment">// map查找,失败时会返回零值</span><br>v = x.(T)               <span class="hljs-comment">// type断言，失败时panic异常</span><br>v = &lt;-ch<span class="hljs-comment">// 管道接收，失败时返回零值（阻塞不算是失败）</span><br><br>_, ok = m[key]<span class="hljs-comment">// map返回2个值</span><br>_, ok = mm[<span class="hljs-string">&quot;&quot;</span>], <span class="hljs-literal">false</span><span class="hljs-comment">// map返回1个值</span><br>_ = mm[<span class="hljs-string">&quot;&quot;</span>]<span class="hljs-comment">// map返回1个值</span><br></code></pre></td></tr></table></figure><p>和变量声明一样，可以用下划线空白标识符_来丢弃不需要的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = io.Copy(dst, src) <span class="hljs-comment">// 丢弃字节数</span><br>_, ok = x.(T)              <span class="hljs-comment">// 只检测类型，忽略具体值</span><br></code></pre></td></tr></table></figure><h1 id="2-4-2-可赋值性"><a href="#2-4-2-可赋值性" class="headerlink" title="2.4.2. 可赋值性"></a>2.4.2. 可赋值性</h1><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">medals := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;gold&quot;</span>, <span class="hljs-string">&quot;silver&quot;</span>, <span class="hljs-string">&quot;bronze&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>隐式地对<code>slice</code>的每个元素进行赋值操作，类型这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">medals[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;gold&quot;</span> <br>medals[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;silver&quot;</span> <br>medals[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;bronze”</span><br></code></pre></td></tr></table></figure><p><code>map</code>和<code>chan</code>的元素，也有类似的隐式赋值行为。<br>无论是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。即，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p><p>可赋值性的规则对于不同类型有着不同要求。<br>最简单地规则：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。<br>常量的可赋值性可见3.6。</p><p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：<br>对应任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之依然。当然，每个类型都会有比较特殊的地方。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.2. 声明</title>
      <link href="/posts/2628b27da087/"/>
      <url>/posts/2628b27da087/</url>
      
        <content type="html"><![CDATA[<p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：</p><ul><li>var 变量</li><li>const 常量</li><li>type 类型</li><li>func 函数实体对象</li></ul><p>下面的例子中声明了一个常量、一个函数和两个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Boiling prints the boiling point of water.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">const</span> boilingF = <span class="hljs-number">212.0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = boilingF<br><span class="hljs-keyword">var</span> c = (f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span><br>fmt.Printf(<span class="hljs-string">&quot;boiling point = %g“°F or %g°C\n&quot;</span>, f, c)<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// boling point = 212°F or 100°C</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面的fToC函数封装了温度转换的处理逻辑，这样函数只需要被定义一次，就可以在多个地方多次被使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Ftoc prints two Fahrenheit-to-Celsius conversions.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> freezingF, boilingF = <span class="hljs-number">32.0</span>, <span class="hljs-number">212.0</span><br>fmt.Printf(<span class="hljs-string">&quot;%g°F=%g°C\n&quot;</span>, freezingF, fToC(freezingF)) <span class="hljs-comment">// &quot;32°F=0°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%g°F=%g°C\n&quot;</span>, freezingF, fToC(boilingF))  <span class="hljs-comment">// &quot;212°F=100°C&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fToC</span><span class="hljs-params">(f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> (f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.1. 命名</title>
      <link href="/posts/feafd476469a/"/>
      <url>/posts/feafd476469a/</url>
      
        <content type="html"><![CDATA[<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</p><p>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</p><p>如果一个命名是在函数内部定义，那么它只在函数内部有效。<br>如果定义在函数外部，那么将在当前包的所有文件中都可以访问。<br>命名的开头字母的大小写决定命名在包外的可见性，大写字母开头且在函数外部定义，那么它将是导出的，可以被外部的包访问。（包级函数名本身也是包级名字，如<code>fmt</code>包的<code>Printf</code>函数就是导出的，可以在<code>fmt</code>包外部访问）<br>包本身的名字一般总是小写字母。</p><p>命名长度没有逻辑限制，但Go语言的风格是尽量使用短小的命名，局部变量更应如此。当一个命名的作用域比较大，生命周期也比较长，那么使用长命名将更有意义。</p><p>习惯上，Go语言推荐使用<code>驼峰式</code>命名。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言中关键字有25个。</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">break</td><td align="center">default</td><td align="center">func</td><td align="center">interface</td><td align="center">select</td></tr><tr><td align="center">case</td><td align="center">defer</td><td align="center">go</td><td align="center">map</td><td align="center">struct</td></tr><tr><td align="center">chan</td><td align="center">else</td><td align="center">goto</td><td align="center">package</td><td align="center">switch</td></tr><tr><td align="center">const</td><td align="center">fallthrough</td><td align="center">if</td><td align="center">range</td><td align="center">type</td></tr><tr><td align="center">continue</td><td align="center">for</td><td align="center">import</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><h1 id="预定义"><a href="#预定义" class="headerlink" title="预定义"></a>预定义</h1><p>这些内部预定义的名字并不是关键字，可以再定义中重新使用。<br>在一些特殊的场景中重新定义它们是有意义的，但是要注意避免过度而引起语义混乱。</p><h2 id="内建常量"><a href="#内建常量" class="headerlink" title="内建常量"></a>内建常量</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>true</td><td>false</td><td>iota</td><td>nill</td></tr></tbody></table><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>int</td><td>int8</td><td>int16</td><td>int32</td><td>int64</td><td></td></tr><tr><td>uint</td><td>uint8</td><td>uint16</td><td>uint32</td><td>uint64</td><td>uintptr</td></tr><tr><td>float32</td><td>float64</td><td>complex128</td><td>complex64</td><td></td><td></td></tr><tr><td>bool</td><td>byte</td><td>rune</td><td>string</td><td></td><td></td></tr></tbody></table><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>make</td><td>len</td><td>cap</td><td>new</td><td>append</td></tr><tr><td>copy</td><td>close</td><td>delete</td><td>complex</td><td>real</td></tr><tr><td>imag</td><td>panic</td><td>recover</td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 程序结构</title>
      <link href="/posts/04348d4815af/"/>
      <url>/posts/04348d4815af/</url>
      
        <content type="html"><![CDATA[<p><a href="/posts/feafd476469a/">2.1. 命名</a></p><p><a href="/posts/2628b27da087/">2.2. 声明</a></p><p><a href="">2.3. 变量</a></p><p><a href="/posts/3bab4b966165/">2.4. 赋值</a></p><p><a href="/posts/9f13bfd0f9d8/">2.5. 类型</a></p><p><a href="/posts/4bd2d633ee16/">2.6. 包和文件</a></p><p><a href="/posts/5b89ef7a41d0/">2.7. 作用域</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.8. 本章要点</title>
      <link href="/posts/f529e3c31d9e/"/>
      <url>/posts/f529e3c31d9e/</url>
      
        <content type="html"><![CDATA[<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><ul><li>if</li><li>for</li><li>switch<ul><li>Go语言并不需要显式地在每一个<code>case</code>后写<code>break</code>，语言默认执行完<code>case</code>后的逻辑语句会自动退出。</li><li><code>fallthrough</code>可以<code>case</code>穿透。</li><li>Go语言里的<code>switch</code>还可以不带操作对象，默认用<code>true</code>值代替，然后将每个case的表达式和true值进行比较。这种形式叫无tag switch(tagless switch)，与switch true等价。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Signum</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> x &gt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> +<span class="hljs-number">1</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">case</span> x &lt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="命名类型"><a href="#命名类型" class="headerlink" title="命名类型"></a>命名类型</h1><p>给予类型一个新名称。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">var</span> p Point<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p> 指针是一种直接存储了变量的内存地址的数据类型。<br> 指针是可见的内存地址，<code>&amp;</code>操作符可以返回一个变量的内存地址，并且<code>*</code>操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p><h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><p> 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。<br> 接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p> 官方的标准库<br> <a href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a href="https://godoc.org/">https://godoc.org</a><br> <code>godoc</code>工具可以直接在本地命令行阅读标准库的文档，如：<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> $ </span><span class="language-bash">go doc http.ListenAndserve</span><br>package http // import &quot;net/http&quot;<br><br>func ListenAndServe(addr string, handler Handler) error<br>    ListenAndServe listens on the TCP network address addr and then calls<br>    Serve with handler to handle requests on incoming connections. Accepted<br>    connections are configured to enable TCP keep-alives.<br><br>    The handler is typically nil, in which case the DefaultServeMux is used.<br><br>    ListenAndServe always returns a non-nil error.<br></code></pre></td></tr></table></figure></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p> 多行注释<code>/* ... */</code></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.7. Web服务</title>
      <link href="/posts/94de4df7cd79/"/>
      <url>/posts/94de4df7cd79/</url>
      
        <content type="html"><![CDATA[<p>Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是URL.Path &#x3D; “hello”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler) <span class="hljs-comment">// each request calls handler</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the Path component of the request URL r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果操作系统为Mac OS X或者Linux，可以在运行命令的末尾加上一个&amp;符号，可以在后台运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ go <span class="hljs-keyword">run</span><span class="language-bash"> server1/main.go &amp;</span><br></code></pre></td></tr></table></figure><p>可以使用fetch进行发送客户端请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./fetch http://localhost:8000<br>URL.Path = <span class="hljs-string">&quot;/&quot;</span><br>$ ./fetch http://localhost:8000/help<br>URL.Path = <span class="hljs-string">&quot;/help&quot;</span><br></code></pre></td></tr></table></figure><p>也可以使用浏览器直接访问<code>http://localhost:8000</code>。<br>下面版本对请求次数继续计算，对URL的请求结果会包含各种URL被访问的总次数，直接对<code>/count</code>这个URL的访问要被排除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Server2 is a minimal &quot;echo&quot; and counter server.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>http.HandleFunc(<span class="hljs-string">&quot;/count&quot;</span>, counter)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// hanlder echoes the Path component of the requested URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>count++<br>mu.Unlock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br><br><span class="hljs-comment">// counter echoes the number of calls so far.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Count %d\n&quot;</span>, count)<br>mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个更为丰富的例子，<code>handler</code>函数会把请求的http头和请求的form数据都打印出来，更便于检查和调试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the HTTP request.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Host = %q\n&quot;</span>, r.Host)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)<br><span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Form[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后会输出以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">GET / HTTP/1.1<br>Header[&quot;User-Agent&quot;]=[&quot;Go-http-client/1.1&quot;]<br>Header[&quot;Accept-Encoding&quot;]=[&quot;gzip&quot;]<br>Host = &quot;localhost:8000&quot;<br>RemoteAddr = &quot;127.0.0.1:51006&quot;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.12：</strong> 修改Lissajour服务，从URL读取变量，比如你可以访问 <a href="http://localhost:8000/?cycles=20">http://localhost:8000/?cycles=20</a> 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whileIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>cycles, _ := strconv.Atoi(r.FormValue(<span class="hljs-string">&quot;cycles&quot;</span>))<br><span class="hljs-keyword">if</span> cycles &gt; <span class="hljs-number">50</span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;The number of cycles cannot be greater than 50&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>lissajous(w, cycles)<br>&#125;)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(w http.ResponseWriter, cycles <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">//cycles = 5 // number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; <span class="hljs-type">float64</span>(cycles)*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(w, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.6. 并发获取多个URL</title>
      <link href="/posts/c84dc5dd7597/"/>
      <url>/posts/c84dc5dd7597/</url>
      
        <content type="html"><![CDATA[<p>下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>nbytes, err := io.Copy(io.Discard, resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetchall.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetchall http://www.baidu.com http://qq.com http://gopl.io</span><br>0.03s  374152 http://www.baidu.com<br>0.05s     228 http://qq.com<br>1.42s    4154 http://gopl.io<br>1.42s elapsed<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.10：</strong> 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elased\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>buf := <span class="hljs-built_in">new</span>(strings.Builder)<br>nbytes, err := io.Copy(buf, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>resp.Body.Close()<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s\n %s&quot;</span>, secs, nbytes, url, buf)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.11：</strong> 在fatchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。<br>解：<br>将输出响应错误信息，但不影响其他网站的访问。</p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.5. 获取URL</title>
      <link href="/posts/8855378318a6/"/>
      <url>/posts/8855378318a6/</url>
      
        <content type="html"><![CDATA[<p>为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Fetch prints the content found at a URL.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:reading %s: %v\n&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch http://gopl.io</span><br>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;<br>  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;<br>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;<br>...<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.7：</strong> 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。<br>解：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-keyword">for</span> _, url := range os<span class="hljs-selector-class">.Args</span><span class="hljs-selector-attr">[1:]</span> &#123;<br>resp, err := http<span class="hljs-selector-class">.Get</span>(url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io<span class="hljs-selector-class">.Copy</span>(os<span class="hljs-selector-class">.Stdout</span>, resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.8：</strong> 修改fetch这个范例，如果输入的url参数没有 http:&#x2F;&#x2F; 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;<br>url = <span class="hljs-string">&quot;http://&quot;</span> + url<br>&#125;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io.Copy(os.Stdout, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.9：</strong> 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Println(resp.Status)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.4. GIF动画</title>
      <link href="/posts/d37e56e6ca24/"/>
      <url>/posts/d37e56e6ca24/</url>
      
        <content type="html"><![CDATA[<p>下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形(Lissajous figures)，这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lissajous generates GIF animations of random Lissajous figures.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span>     <span class="hljs-comment">// number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用以下命令生成一个GIF动画。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build lissajous</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./lissajous &gt;out.gif</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/out.gif" alt="out"></p><p>练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。<br>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x1</span>&#125;, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/out_1.gif" alt="out"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.6：</strong> 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x1</span>&#125;, color.White&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/lissajous2.gif" alt="lissajous2"></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.3. 查找重复的行</title>
      <link href="/posts/c749b9e4bafd/"/>
      <url>/posts/c749b9e4bafd/</url>
      
        <content type="html"><![CDATA[<p>对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。</p><p>dup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，<code>map</code>数据类型以及<code>bufio</code>包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup1 prints the text of each line that appears more than</span><br><span class="hljs-comment">// once in the standard input, preceded by its count.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> input.Text() == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。<br>if语句的else部分是可选的，在if的条件为false时执行。<br><code>map</code>存储了键&#x2F;值（key&#x2F;value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用<code>==</code>运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数<code>make</code>创建空<code>map</code>，此外，它还有别的作用。<br>从功能和实现上说，Go的<code>map</code>类似于Java语言中的<code>HashMap</code>，Python语言中的<code>dict</code>，Lua语言中的<code>table</code>，通常使用hash实现。遗憾的是，对于该词的翻译并不统一，数学界术语为映射，而计算机界众说纷纭莫衷一是。<br><code>counts[input.Text()]++</code>语句等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">line := input.Text()<br>counts[line] = counts[line] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>Printf</code>部分格式字符</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">%d          十进制整数<br>%x, %o, %b  十六进制，八进制，二进制整数。<br>%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00<br>%t          布尔：true或false<br>%c          字符（rune） (Unicode码点)<br>%s          字符串<br>%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;<br>%v          变量的自然形式（natural format）<br>%T          变量的类型<br>%%          字面上的百分号标志（无操作数）<br></code></pre></td></tr></table></figure><p>制表符<code>\t</code>和换行符<code>\n</code>,称为<code>转义字符</code>(escap sequences)。<br>按照惯例，以字母<code>f</code>结尾的格式化函数，如<code>log.Printf</code>和<code>fmt.Errof</code>,都采用了<code>fmt.Printf</code>的格式化准则。<br>以<code>ln</code>结尾的格式化函数，则遵循<code>Printlin</code>的方式，以跟<code>%v</code>差不多的方式格式化参数，并在最后添加一个换行符。<br>后缀<code>f</code>指<code>format</code>, <code>ln</code>指<code>line</code>。<br>很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。<code>dup</code>程序的下个版本读取标准输入或是使用<code>os.Open</code>打开各个具名文件，并操作它们。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup2 prints the count and text of lines that appear more than once</span><br><span class="hljs-comment">// in the input. It reads from stdin or from a list of named files.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>dup</code>的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。下面这个版本，dup3，就是这么操作的。这个例子引入了<code>ReadFile</code>函数（来自于<code>io/ioutil</code>包），其读取指定文件的全部内容，<code>strings.Split</code>函数把字符串分割成子串的切片。（<code>Split</code>的作用与前文提到的<code>strings.Join</code>相反。）<br>我们略微简化了dup3。首先，由于<code>ReadFile</code>函数需要文件名作为参数，因此只读指定文件，不读标准输入。其次，由于行计数代码只在一处用到，故将其移回<code>main</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args &#123;<br>data, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup3:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, line := <span class="hljs-keyword">range</span> strings.Split(<span class="hljs-type">string</span>(data), <span class="hljs-string">&quot;\n&quot;</span>) &#123;<br>counts[line]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.4：</strong> 修改dup2，出现重复的行时打印文件名称。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> counts[input.Text()] &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Println(f.Name())<br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.2. 命令行参数</title>
      <link href="/posts/b7c6dc0a75aa/"/>
      <url>/posts/b7c6dc0a75aa/</url>
      
        <content type="html"><![CDATA[<p>大多数程序都是处理输入，产生输出，这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？<br>有以下几种获取输入数据：</p><ul><li>一些程序生成自己的数据</li><li>文件</li><li>网络连接</li><li>其它程序的输入</li><li>键盘，鼠标等</li><li>命令行参数</li><li>其它类似输入源</li></ul><p><code>os</code>包以跨平台的方式，提供了一些与操作系统交互的函数和变量。<br>程序的命令行参数可从<code>os</code>包的Args变量获取。<br><code>os</code>包外部使用<code>os.Args</code>访问该变量。</p><p><code>os.Args</code>变量是一个字符串切片（<code>string slice</code>）。<br><code>slice</code>是简化的动态数组。<br>可以把<code>slice</code>当做数组元素序列，序列的成长度动态变化，用<code>s[i]</code>访问单个元素，用<code>s[n:m]</code>获取子序列。<br>序列的元素数目为<code>len(s)</code>。<br>区间索引时，采用<code>左闭右开</code>形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。如<code>s[m:n]</code>这个切片，0 ≤ m ≤ n ≤ len(s)，包含n - m个元素。“比如a &#x3D; [1, 2, 3, 4, 5], a[0:3] &#x3D; [1, 2, 3]，不包含最后一个元素”</p><p><code>os.Args</code>的第一个元素，<code>os.Args[0]</code>是命令本身的名字。<br>其它元素则是程序启动时传给它的参数。即<code>os.Args[1:len(os.Args)]</code>,简化<code>os.Args[1:]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo1 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;<br>s += sep + os.Args[i]<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ go <span class="hljs-built_in">run</span> echo1 1 2 3 4 5<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12345<br></code></pre></td></tr></table></figure><p>Go语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post &#123;<br><span class="hljs-comment">// zero or more statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环三个部分不需括号包围。<br>大括号强制要求, 左大括号必须和post语句在同一行。<br><code>initialization</code>语句是可选的，在循环开始前执行。<br><code>initalization</code>如果存在，必须是一条简单语句（<code>simple statement</code>），即，短变量声明、自增语句、赋值语句或函数调用。<br><code>condition</code>是一个布尔表达式（<code>boolean expression</code>），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。<br><code>post</code>语句在循环体执行结束后执行，之后再次对<code>conditon</code>求值。<code>condition</code>值为false时，循环结束。</p><p>for循环的这三个部分每个都可以省略，如果省略<code>initialization</code>和<code>post</code>，分号也可以省略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional &quot;while&quot; loop</span><br><span class="hljs-keyword">for</span> condition &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果连<code>condition</code>也省略了，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional infinite loop</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条<code>break</code>或<code>return</code>语句。</p><p>for循环的另一种形式, 在某种数据类型的区间（<code>range</code>）上遍历，如字符串或切片。echo的第二版本展示了这种形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo2 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环迭代，range产生一对值: 索引以及在该索引处的元素值。<br>这个例子不需要索引，但range的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量, 如temp, 然后忽略它的值，但Go语言不允许使用无用的局部变量（<code>local variables</code>），因为这会导致编译错误。Go语言中这种情况的解决方法是用空标识符（blank identifier），即_（也就是下划线）。</p><p>echo的这个版本使用一条短变量声明来声明并初始化s和seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。<br>第二种形式依赖于字符串的默认初始化零值机制，被初始化为””。<br>第三种形式用得很少，除非同时声明多个变量。<br>第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。<br>实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p><p>如前文所述，每次循环迭代字符串s的内容都会更新。<code>+=</code>连接原字符串、空格和下个参数，产生新字符串, 并把它赋值给s。s原来的内容已经不再使用，将在适当时机对它进行垃圾回收。</p><p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(os.Args[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.1：</strong> 修改echo程序，使其能够打印os.Args[0]，即被执行命令本身的名字。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(os.Args[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.2：</strong> 修改echo程序，使其打印每个参数的索引和值，每个一行。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> idx, sep := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Print(idx)<br>fmt.Println(<span class="hljs-string">&quot;  &quot;</span> + sep)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.3：</strong> 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>startTime := time.Now()<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>secs := time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br><br>startTime = time.Now()<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>secs = time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.1. Hello, World</title>
      <link href="/posts/02fc6779c7cd/"/>
      <url>/posts/02fc6779c7cd/</url>
      
        <content type="html"><![CDATA[<p>传统案例“hello world”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span><br></code></pre></td></tr></table></figure><p>毫无疑问，这个命令会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello, world<br></code></pre></td></tr></table></figure><p>Go语言原生支持Unicode, 可以处理全世界任何语言的文本。<br>如果不只是一次性实验，可以进行编译重新，并保留编译结果以备将来之用。<br>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span><br></code></pre></td></tr></table></figure><p>编译命令生成一个名为helloworld的可执行的二进制文件。<br>运行可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./helloworld</span><br>hello,world<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 入门</title>
      <link href="/posts/b721eb61c1a0/"/>
      <url>/posts/b721eb61c1a0/</url>
      
        <content type="html"><![CDATA[<p>本章主要为Go语言的基础组件，及其示例程序等。</p><p><a href="/posts/02fc6779c7cd/">1.1. Hello, World</a></p><p><a href="/posts/b7c6dc0a75aa/">1.2. 命令行参数</a></p><p><a href="/posts/c749b9e4bafd/">1.3. 查找重复的行</a></p><p><a href="/posts/d37e56e6ca24/">1.4. GIF动画</a></p><p><a href="/posts/8855378318a6/">1.5. 获取URL</a></p><p><a href="/posts/c84dc5dd7597/">1.6. 并发获取多个URL</a></p><p><a href="/posts/94de4df7cd79/">1.7. Web服务</a></p><p><a href="/posts/f529e3c31d9e/">1.8. 本章要点</a></p>]]></content>
      
      
      <categories>
          
          <category> go </category>
          
          <category> Go语言圣经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
            <tag> go </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
