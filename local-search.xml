<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2.7. 作用域</title>
    <link href="/posts/5b89ef7a41d0/"/>
    <url>/posts/5b89ef7a41d0/</url>
    
    <content type="html"><![CDATA[<p>声明语句将程序中的实体和名字关联，如函数，变量。<br>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p><p>不能将作用域与生命周期混为一谈。<br>声明语句的作用域对应的是源代码的文本区域；是一个编译时的属性。<br>变量的生命周期是指程序运行的是变量存在的有效时间段，在此时间段内可以被程序的其它部分引用；是一个运行时的概念。</p><p><strong>语法块</strong>是由花括弧所包含的一系列语句，如函数体或循环体花括弧对应的语法块一样。<br>语法块内部声明的名字是无法被外部语法块访问的。<br>语法块决定了内部声明的名字的作用域范围。</p><ul><li>包含其它类似组批量声明等没有用花括弧包含的代码，称为语法块；</li><li>语法块为整个源代码时，称为全局语法块；</li><li>每个包的包语法块；</li><li>每个for、if和switch语句的语法块；</li><li>每个switch或select的分支也有独立的语法块；</li><li>显式书写的语法块（花括弧包含的语句）；</li></ul><p>声明语句对应的词法域决定了作用域范围的大小。<br>对应内置的类型、函数和常量，如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。<br>任何在函数外部（包级语法域）声明的名字可以在同一个包的任何源文件中访问的。<br>对于导入的包，如<code>fmt</code>包，则是对应源文件级的作用域，因此只能在当前文件中文件中访问导入的包，当前包的其它源文件无法访问在当前源文件中导入的包。<br>还有许多声明语句，如<code>tempconv.CToF</code>函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能局部的某些部分）访问。</p><p>控制流符号，就是<code>break</code>、<code>continue</code>或<code>goto</code>语句后面跟着的那种标号，则是函数级的作用域。</p><p>一个程序中可能包含多个同名的声明，但只需要它们在不同的词法域中。<br>如，局部变量和包级的变量同名；或函数参数名字声明为new，虽然内置的new是全局作用域的。<br>如果滥用不同词法域可重名的特性，可能导致程序的可读性变差。</p><p>当编译器编译到一个名字引用时，如果是一个声明，它首先从最内层的词法域向全局作用域查找。<br>如果查找失败，则报错<code>未声明的名字</code>这样的错误。<br>如果该名字在内部和外部的语法块分别声明过，则内部块的声明首先会被找到。<br>这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问。<br>如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> g = <span class="hljs-string">&quot;g&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    f := <span class="hljs-string">&quot;f&quot;</span><br>    fmt.Println(f) <span class="hljs-comment">// &quot;f&quot;; local var f shadows package-level func f</span><br>    fmt.Println(g) <span class="hljs-comment">// &quot;g&quot;; package-level var</span><br>    fmt.Println(h) <span class="hljs-comment">// compile error: undefined: h</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在函数中词法域可以深度嵌套，因此内部的声明可以屏蔽外部的声明。<br>下面的代码有三个不同的变量x，因为它们是定义在不同的词法域：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := <span class="hljs-string">&quot;hello!&quot;</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(x); i++ &#123;<br>        x := x[i]<br>        <span class="hljs-keyword">if</span> x != <span class="hljs-string">&#x27;!&#x27;</span> &#123;<br>            x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span><br>            fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面for语句副本创建了两个词法域：一个显式部分是for的循环体部分词法域，另一个隐式部分是循环的初始化部分（迭代变量i的初始化）。隐式的词法域部分的作用域还包含了条件测试部分和循环后的迭代部分（i++），还包含了循环体词法域。<br>在x[i]和x + ‘A’ - ‘a’声明语句的初始化的表达式中都引用了外部作用域声明的x变量。</p><p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    x := <span class="hljs-string">&quot;hello&quot;</span><br>    <span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> x &#123;<br>        x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span><br>        fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> x := f(); x == <span class="hljs-number">0</span> &#123;<br>    fmt.Println(x)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y := g(x); x == y &#123;<br>    fmt.Println(x, y)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    fmt.Println(x, y)<br>&#125;<br>fmt.Println(x, y) <span class="hljs-comment">// compile error: x and y are not visible here</span><br></code></pre></td></tr></table></figure><p>第二个if语句被嵌套在第一个if语句的内部，因此在第一个if语句条件初始化词法域声明的变量在第二个if语句中也可以访问。<br>switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后每个是每个分支的词法域。</p><p>在包级别，声明的顺序并不影响作用域范围，因此先声明的可以引用它自身或者引用后面的声明，这样就可以定义一些相互嵌套或递归的类型或函数。<br>如果变量或常量递归引用了自身，则会产生编译错误。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.6. 包和文件</title>
    <link href="/posts/4bd2d633ee16/"/>
    <url>/posts/4bd2d633ee16/</url>
    
    <content type="html"><![CDATA[<p>包的存在是为了支持模块化、封装、单独编译和代码重用。</p><p>每个包都对应一个独立的命名空间。如: <code>image</code>包中的<code>Decode</code>函数和在<code>unicode/uft16</code>包中的<code>Decode</code>函数是不同的。要在外部引用该函数，必须显式使用<code>image.Decode</code>或<code>uft16.Decode</code>形式来访问。</p><p>包还可以实现可见性。规则：以大写字母开头的，那么该名字是可导出的。（因为中文汉字不区分大小写，因此汉字开头的名字是不可导出的。）</p><p>在每个源文件的包声明前是包注释。<br>包注释的第一句为包的功能概要说明。<br>通常情况下，包内只有一个源文件有包注释，如有多个包注释，文档工具会根据源文件名的先后顺序将包注释链接为一个包注释。<br>如果包注释很大，通常会放到单独的<code>doc.go</code>文件中。</p><p><strong>练习 2.1：</strong> 向tempconv包添加类型、常量和函数用来处理Kelvin绝对温度的转换，Kelvin 绝对零度是−273.15°C，Kelvin绝对温度1K和摄氏度1°C的单位间隔是一样的。<br>解答：<br>tempconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package tempconv performs Celsius and Fahrenheit conversions.</span><br><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Kelvin <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">const</span> (<br>AbsoluteZeroC Celsius = <span class="hljs-number">-273.15</span><br>FreezingC     Celsius = <span class="hljs-number">0</span><br>BoilingC      Celsius = <span class="hljs-number">100</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Fahrenheit)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°F&quot;</span>, f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Kelvin)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%gK&quot;</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure><p>conve.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-comment">// CToF converts a Celsius temperature to Fahrenheit.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-comment">// FToC converts a Fahrenheit temperature to Celsius.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)<br>&#125;<br><br><span class="hljs-comment">// CToK converts a Celsius temperature to Kelvin.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToK</span><span class="hljs-params">(c Celsius)</span></span> Kelvin &#123;<br><span class="hljs-keyword">return</span> Kelvin(c)<br>&#125;<br><br><span class="hljs-comment">// KToC converts a Kelvin temperature to Celsius.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KToC</span><span class="hljs-params">(k Kelvin)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius(k)<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-6-1-导入包"><a href="#2-6-1-导入包" class="headerlink" title="2.6.1. 导入包"></a>2.6.1. 导入包</h1><p>每个包都是有一个全局唯一的导入路径。如：<code>go-learn-gopl/ch/ch2/tempconv</code>。<br>一个导入路径代表一个目录中的一个或多个Go源文件。</p><p>除了包路径，每个包还有一个包民，包名通常是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。<br>通常，包的名字和包的导入路径的最后一个字段相同，如<code>go-learn-gopl/ch/ch2/tempconv</code>包的名字一般是<code>tempconv</code>。</p><p>要使用<code>go-learn-gopl/ch/ch2/tempconv</code>包，需要先导入：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Cf converts its numeric argument to Celsius and Fahrenheit.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ch/ch2/tempconv&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>t, err := strconv.ParseFloat(arg, <span class="hljs-number">64</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;cf: %v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>f := tempconv.Fahrenheit(t)<br>c := tempconv.Celsius(t)<br>fmt.Printf(<span class="hljs-string">&quot;%s=%s, %s=%s\n&quot;</span>, f, tempconv.FToC(f), c, tempconv.CToF(c))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>cf程序是将命令行输入的一个温度在<code>Celsius</code>和<code>Fahrenheit</code>温度单位之间转换:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ go build ./ch/ch2/cf/main.go <br>$ ./main 24.2<br>24.2°F=-4.333333333333333°C, 24.2°C=75.56°F<br><br></code></pre></td></tr></table></figure><p>如果导入一个包，但是却没有使用，就将会被当做编译错误处理。<br>这种强制规则可以有效减少不必要的依赖。<br>可以使用<code>golang.org/x/tools/cmd/goimports</code>导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成<code>goimports</code>工具，然后在保存文件时自动运行。类似还有<code>gofmt</code>工具，用于格式化Go源文件。</p><p><strong>练习 2.2：</strong> 写一个通用的单位转换程序，用类似cf程序的方式从命令行读取参数，如果缺省的话则是从标准输入读取参数，然后做类似Celsius和Fahrenheit的单位转换，长度单位可以对应英尺和米，重量单位可以对应磅和公斤等。<br>unitconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package unitconv performs Meter and Foot, Pounds and Kilogram conversions.</span><br><span class="hljs-keyword">package</span> unitconv<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Meter <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Foot <span class="hljs-type">float64</span><br><br><span class="hljs-keyword">type</span> Pounds <span class="hljs-type">float64</span><br><span class="hljs-keyword">type</span> Kilogram <span class="hljs-type">float64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Meter)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g m&quot;</span>, m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f Foot)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g ft&quot;</span>, f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Pounds)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g lb&quot;</span>, p)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(k Kilogram)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g kg&quot;</span>, k)<br>&#125;<br></code></pre></td></tr></table></figure><p>conv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> unitconv<br><br><span class="hljs-comment">// MToF converts Meter to Foot.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MToF</span><span class="hljs-params">(m Meter)</span></span> Foot &#123;<br><span class="hljs-keyword">return</span> Foot(m * <span class="hljs-number">3.28083989501</span>)<br>&#125;<br><br><span class="hljs-comment">// FToM converts Foot to Meter.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToM</span><span class="hljs-params">(f Foot)</span></span> Meter &#123;<br><span class="hljs-keyword">return</span> Meter(f * <span class="hljs-number">0.3048</span>)<br>&#125;<br><br><span class="hljs-comment">// KToP converts Kilogram to Pounds.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">KToP</span><span class="hljs-params">(k Kilogram)</span></span> Pounds &#123;<br><span class="hljs-keyword">return</span> Pounds(k * <span class="hljs-number">2.20462262185</span>)<br>&#125;<br><br><span class="hljs-comment">// PToK converts Pounds to Kilogram.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PToK</span><span class="hljs-params">(p Pounds)</span></span> Kilogram &#123;<br><span class="hljs-keyword">return</span> Kilogram(p * <span class="hljs-number">0.4535924</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>uconv.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;go-learn-gopl/ex/ex2/unitconv&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> m = flag.Float64(<span class="hljs-string">&quot;m&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Meter to Foot.&quot;</span>)<br><span class="hljs-keyword">var</span> f = flag.Float64(<span class="hljs-string">&quot;f&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Foot to Meter.&quot;</span>)<br><span class="hljs-keyword">var</span> k = flag.Float64(<span class="hljs-string">&quot;k&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Kilogram to Pounds.&quot;</span>)<br><span class="hljs-keyword">var</span> p = flag.Float64(<span class="hljs-string">&quot;p&quot;</span>, <span class="hljs-number">-1</span>, <span class="hljs-string">&quot;converts Pounds to Kilogram.&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br><span class="hljs-keyword">if</span> *m &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Meter(*m), unitconv.MToF(unitconv.Meter(*m)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *f &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Foot(*f), unitconv.FToM(unitconv.Foot(*f)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *k &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Kilogram(*k), unitconv.KToP(unitconv.Kilogram(*k)))<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> *p &gt;= <span class="hljs-number">0</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, unitconv.Pounds(*p), unitconv.PToK(unitconv.Pounds(*p)))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Fprintln(os.Stderr, <span class="hljs-string">&quot;value must be granter than 0.&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs markdown">$ go build conv/uconv.go<br>$ ./uconv -m 1<br>1 m = 3.28083989501 ft<br>$ ./uconv -f 1<br>1 ft = 0.3048 m<br>$ ./uconv -k 10<br>10 kg = 22.0462262185 lb<br>$ ./uconv -p 2<br>2 lb = 0.9071848 kg<br>$ ./uconv -m -1<br>value must be granter than 0.<br>$ ./uconv -h<br>Usage of ./uconv:<br>  -f float<br><span class="hljs-code">        converts Foot to Meter. (default -1)</span><br><span class="hljs-code">  -k float</span><br><span class="hljs-code">        converts Kilogram to Pounds. (default -1)</span><br><span class="hljs-code">  -m float</span><br><span class="hljs-code">        converts Meter to Foot. (default -1)</span><br><span class="hljs-code">  -p float</span><br><span class="hljs-code">        converts Pounds to Kilogram. (default -1)</span><br><span class="hljs-code"></span><br></code></pre></td></tr></table></figure><h1 id="2-6-2-包的初始化"><a href="#2-6-2-包的初始化" class="headerlink" title="2.6.2. 包的初始化"></a>2.6.2. 包的初始化</h1><p>包的初始化首先是解决包级变量的依赖顺序，然后安装包级变量声明出现的顺序依次初始化。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = b + c <span class="hljs-comment">// a 第三个初始化, 为 3</span><br><span class="hljs-keyword">var</span> b = f()   <span class="hljs-comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span><br><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>     <span class="hljs-comment">// c 第一个初始化, 为 1</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123; <span class="hljs-keyword">return</span> c + <span class="hljs-number">1</span> &#125;<br></code></pre></td></tr></table></figure><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，但有些数据初始化并非一个简单的赋值过程。这种情况下，可以使用<code>init</code>初始化函数来简化初始化工作，每个文件都可以包含多个<code>init</code>初始化函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">/*...*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>init</code>初始化函数除了不能被调用或引用外，其他行为与普通函数无异。<br>每个文件中的<code>init</code>初始化函数，在程序开始执行时按照声明的顺序被自动调用。</p><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。<br>如果<code>p</code>包导入了<code>q</code>包，那么在<code>p</code>包初始化的时候可以认为<code>q</code>包必然已经初始化过了。<br>初始化工作时自下而上进行的，<code>main</code>包最后被初始化。确保在<code>main</code>函数执行之前，所有依赖的包都已经完成初始化。</p><p>下面的代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如果预生成辅助表格，这是编程中常用的技术）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br></code></pre></td></tr></table></figure><p>pc可以将初始化逻辑包装为匿名函数处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span> = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span>) &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;()<br></code></pre></td></tr></table></figure><p>for循环只用到索引部分，可以使用<code>_</code>忽略值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> pc &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 2.3：</strong> 重写PopCount函数，用一个循环代替单一的表达式。比较两个版本的性能。（11.4节将展示如何系统地比较两个不同实现的性能。）<br>解答：<br>popcount.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>练习 2.4：</strong> 用移位算法重写PopCount函数，每次测试最右边的1bit，然后统计总数。比较和查表算法的性能差异。<br>解答：<br>popcount.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitShift returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitShift</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++ &#123;<br><span class="hljs-keyword">if</span> (x&gt;&gt;i)&amp;<span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitShift</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitShift(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitShift</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitShift(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 2.5：</strong> 表达式x&amp;(x-1)用于将x的最低的一个非零的bit位清零。使用这个算法重写PopCount函数，然后比较性能。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-comment">// pc[i] is the population count of i.</span><br><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-type">byte</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;<br>pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-type">byte</span>(i&amp;<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +<br>pc[<span class="hljs-type">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])<br>&#125;<br><br><span class="hljs-comment">// PopCountByLoop returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByLoop</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">8</span>; i++ &#123;<br>c += <span class="hljs-type">int</span>(pc[<span class="hljs-type">byte</span>(x&gt;&gt;(i*<span class="hljs-number">8</span>))])<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitShift returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitShift</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">64</span>; i++ &#123;<br><span class="hljs-keyword">if</span> (x&gt;&gt;i)&amp;<span class="hljs-number">1</span> != <span class="hljs-number">0</span> &#123;<br>c++<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br><span class="hljs-comment">// PopCountByBitClear returns the population count (number of set bits) of x.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCountByBitClear</span><span class="hljs-params">(x <span class="hljs-type">uint64</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>c := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> x != <span class="hljs-number">0</span> &#123;<br>x &amp;= x - <span class="hljs-number">1</span><br>c++<br>&#125;<br><span class="hljs-keyword">return</span> c<br>&#125;<br><br></code></pre></td></tr></table></figure><p>popcount_test.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> popcount<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;reflect&quot;</span><br><span class="hljs-string">&quot;testing&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assert</span><span class="hljs-params">(t *testing.T, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">if</span> !reflect.DeepEqual(expected, actual) &#123;<br>t.Errorf(<span class="hljs-string">&quot;(expected, actual) = (%v, %v)\n&quot;</span>, expected, actual)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCount</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByLoop</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByLoop(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitShift</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitShift(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPopCountByBitClear</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>assert(t, <span class="hljs-number">32</span>, PopCountByBitClear(<span class="hljs-number">0x1234567890ABCDEF</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCount</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCount(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByLoop</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByLoop(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitShift</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitShift(<span class="hljs-number">0x123456790ABCDEF</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkPopCountByBitClear</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>PopCountByBitClear(<span class="hljs-number">0x1234567890ABCDEF</span>)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5. 类型</title>
    <link href="/posts/9f13bfd0f9d8/"/>
    <url>/posts/9f13bfd0f9d8/</url>
    
    <content type="html"><![CDATA[<p>变量或表达式的类型定义了对应存储值的属性特征，如：</p><ul><li>值在内存的存储大小（或者是元素的bit个数）。</li><li>它们在内部是如何表达的。</li><li>是否支持一些操作符。</li><li>它们自己关联的方法集。</li></ul><p>类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。<br>新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名称 底层类型<br></code></pre></td></tr></table></figure><p>类型声明语句一般出现在包一级，且新的类型名称首字母大写，则在外部包也可以使用。<br>注：对于中文汉字，Unicode标志都作为小写字母处理，因此不能将其命名导出。<br>为了说明类型声明，将不同温度单位分别定义为不同的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span><br><span class="hljs-keyword">package</span> tempconv<br><br><span class="hljs-keyword">type</span> Celsius <span class="hljs-type">float64</span>    <span class="hljs-comment">// 摄氏温度</span><br><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-type">float64</span> <span class="hljs-comment">// 华氏温度</span><br><br><span class="hljs-keyword">const</span> (<br>AbsoluteZeroC Celsius = <span class="hljs-number">-273.15</span> <span class="hljs-comment">// 绝对零度</span><br>FreezingC     Celsius = <span class="hljs-number">0</span>       <span class="hljs-comment">// 结冰温度</span><br>BoilingC      Celsius = <span class="hljs-number">100</span>     <span class="hljs-comment">// 沸水温度</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span></span> Fahrenheit &#123;<br><span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span></span> Celsius &#123;<br><span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Celsius(t)</code>和<code>Fahrenheit(t)</code>是类型转换操作，并非函数调用。<br>对于每一个类型T，都有一个对应的类型转换操作T(x)，将x转为T类型。<br>如果T是指针类型，可能需要用小括弧包装T，如<code>(*int)(0)</code>。<br><code>只有当两个类型的底层基础类型相同时，才允许类型转换, 或者两者都是指向相同底层结构的指针类型。</code><br>如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型。</p><p>数值类型之间的类型转换也是允许的，并且字符串和一些特定类型的slice之间也是可以转换，但有可能改变值。<br>如：浮点数转换为整数将丢弃小数部分；字符串转为<code>[]byte</code>类型的slice将拷贝一个人字符串数据的副本。</p><p>底层数据类型决定了内部结构和表达方式，也决定是否可以像底层类型一样对内置运算符的支持。这意味着，Celsius和Fahrenheit类型的算术运算行为和底层的float64类型一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, BoilingC - FreezingC) <span class="hljs-comment">// 100°C</span><br>boilingF := CToF(BoilingC)<br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, boilingF-CToF(FreezingC)) <span class="hljs-comment">// 180°F</span><br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, boilingF-FreezingC) <span class="hljs-comment">//  Invalid operation: boilingF-FreezingC (mismatched types Fahrenheit and Celsius)</span><br></code></pre></td></tr></table></figure><p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。但如果两个值有着不同的类型，则不能直接进行比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c Celsius<br><span class="hljs-keyword">var</span> f Fahrenheit<br>fmt.Println(c == <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span><br>fmt.Println(f &gt;= <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span><br>fmt.Println(c == f)          <span class="hljs-comment">// compile error: type mismatch</span><br>fmt.Println(c == Celsius(f)) <span class="hljs-comment">// &quot;true&quot;!</span><br></code></pre></td></tr></table></figure><p><code>Celsius(f)</code>是类型转换操作，并不会改变值，仅改变了值的类型。</p><p>命名类型更方便书写，避免重复书写复杂类型，如匿名结构体定义变量。</p><p>命名类型还可以为该类型的值定义新的行为。这些行为表示为一组关联到该类型的函数集合，即类型的方法集。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span></span> String() <span class="hljs-type">string</span> &#123; <br> <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c) <br>&#125;<br></code></pre></td></tr></table></figure><p>一般情况下，类型都会定义一个<code>String</code>方法，当使用<code>fmt</code>包的打印方法时，将优先使用该类型对应的<code>String</code>方法返回的结果打印。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">c := FToC(<span class="hljs-number">212.0</span>)<br>fmt.Println(c.String()) <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;; no need to call String explicitly</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Println(c)          <span class="hljs-comment">// &quot;100°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100&quot;; does not call String</span><br>fmt.Println(<span class="hljs-type">float64</span>(c)) <span class="hljs-comment">// &quot;100&quot;; does not call String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3.变量</title>
    <link href="/posts/7095472d910d/"/>
    <url>/posts/7095472d910d/</url>
    
    <content type="html"><![CDATA[<p><code>var</code>声明语句可以创建一个特定类型的变量，然后给变量附加一个名字，并且设置变量的初始值。<br>变量声明的一般语法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> 变量名称 类型 = 表达式<br></code></pre></td></tr></table></figure><p>类型或”&#x3D;表达式”两个部分可以省略其中的一个。<br>如果省略的是类型，那么将根据初始化表达式来推导变量的类型。<br>如果初始化表达式被省略，那么将用零值初始化该变量。<br>数值类型变量对应的零值是<code>0</code>，布尔类型变量对应的零值是<code>false</code>，字符串类型对应的零值是<code>空字符串</code>，接口或引用类型（包含slice、map、chan和函数）变量对应的零值是<code>nil</code>。数组或结构体等聚合类型对应的零值是每一个元素或字段都是对应该类型的零值。</p><p>零值初始化机制可以确保每一个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。该特性可以简化代码，确保边界条件下的合理行为。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Println(s) <span class="hljs-comment">//&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>该代码将打印一个空字符串，而非导致错误或产生不可以预知的行为。<br>所以也应该使一些聚合类型的零值有一定意义，可以确保不管任何类型的变量总是有一个合理有效的零值状态。</p><p>简化变量的类型，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> i, j, k <span class="hljs-type">int</span><span class="hljs-comment">//int, int, int</span><br><span class="hljs-keyword">var</span> b, f, s = <span class="hljs-literal">true</span>, <span class="hljs-number">2.3</span>, <span class="hljs-string">&quot;four&quot;</span> <span class="hljs-comment">// bool, float64, string</span><br></code></pre></td></tr></table></figure><p> 一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f, err = os.Open(name) <span class="hljs-comment">// os.Open returns a file and an error</span><br></code></pre></td></tr></table></figure></p><h1 id="2-3-1-简短变量声明"><a href="#2-3-1-简短变量声明" class="headerlink" title="2.3.1. 简短变量声明"></a>2.3.1. 简短变量声明</h1><p>简短变量声明语法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">名字:=表达式<br></code></pre></td></tr></table></figure><p>变量的类型根据表达式来自动推导。<br>下面有几个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">i := <span class="hljs-number">100</span> <span class="hljs-comment">// an int</span><br><span class="hljs-keyword">var</span> boiling <span class="hljs-type">float64</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// a float64</span><br><span class="hljs-keyword">var</span> names []<span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><span class="hljs-keyword">var</span> p Point<br></code></pre></td></tr></table></figure><p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i, j := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>:=</code>是一个变量声明语句。<br><code>=</code>是一个变量赋值操作。</p><p>简短变量声明语句中必须至少要声明一个新的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">f,err := os.Open(infile) <span class="hljs-comment">// 简短声明语句</span><br>f, err = os.Create(outfile) <span class="hljs-comment">// 赋值语句</span><br></code></pre></td></tr></table></figure><h1 id="2-3-2-指针"><a href="#2-3-2-指针" class="headerlink" title="2.3.2. 指针"></a>2.3.2. 指针</h1><p>一个变量对应一个保存了变量对应类型值的内存空间。<br>一个指针的值是另一个变量的地址。<br>一个指针对应一个变量在内存中的存储位置。<br>并不是每一个值都有一个内存地址，但是对于每一个变量必然有对应的内存地址。<br>通过指针，可以直接读或更新对应变量的值。</p><p>如果用<code>var x int</code>声明语句声明一个<code>x</code>变量，那么<code>&amp;x</code>表达式（取x变量的内存地址）将产生一个指向该整数变量的指针，指针对应的数据类型是<code>*int</code>，指针被称之为<code>指向int类型的指针</code>。如果指针名字为p，那么可以说<code>p指针指向变量x</code>，或者说<code>p指针保存了x变量的内存地址</code>。同时<code>*p</code>表达式对应<code>p指针</code>指向的变量的值。一般<code>*p</code>表达式读取指针指向的变量的值，这里为<code>int</code>类型的值，同时因为<code>*p</code>对应一个变量，所以该表达式也可以出现在赋值语句的左边，表示更新指针所指向的变量的值。<br><code>&amp;</code>取址符<br><code>*</code>取值符<br><code>*int</code>指向int类型的指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x := <span class="hljs-number">1</span><br>p := &amp;x <span class="hljs-comment">// p, 类型*int,指向变量x</span><br>fmt.Println(*p) <span class="hljs-comment">// 1</span><br>*p = <span class="hljs-number">2</span><span class="hljs-comment">// 给x赋值2 等同于x=2</span><br>fmt.Println(x) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>对应聚合类型的每一个成员，如结构体的每个字段，数组的每个元素，也都是对应一个变量，因此也可以被取地址。</p><p>变量有时候被称为可寻址的值，即使变量由表达式临时生成，那么表达式也必须能接受<code>&amp;</code>取地址操作。</p><p>任何类型的指针的零值都是<code>nil</code>。如果<code>p != nil</code>为真，那么<code>p</code>是指向某个有效变量。指针之间同一个变量或全为<code>nil</code>时才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-type">int</span><br>fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == <span class="hljs-literal">nil</span>) <span class="hljs-comment">// true false false</span><br></code></pre></td></tr></table></figure><p>在Go语言中，返回函数中局部变量的地址也是安全的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p = f()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br>v := <span class="hljs-number">1</span><br><span class="hljs-keyword">return</span> &amp;v<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用f函数都返回不同的结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(f()==f()) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>通过指针改变变量的值，例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">incr</span><span class="hljs-params">(p *<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>*p++<span class="hljs-comment">// 只是增加p指向的变量的值，并不改变p指针！！！</span><br><span class="hljs-keyword">return</span> *p<br>&#125;<br><br>v := <span class="hljs-number">1</span><br>incr(&amp;v)<span class="hljs-comment">// side effect: v is now 2</span><br>fmt.Println(incr(&amp;v))<span class="hljs-comment">// 3 and v is 3</span><br></code></pre></td></tr></table></figure><p>每次对变量取地址或者复制指针，都是为原变量创建了新别名。如，<code>*p</code>就是变量<code>v</code>的别名。<br>指针的特有价值是在于可以不通过名称而访问变量，但是也是一把双刃剑：<br>要找到一个变量的所有访问者并不容易，就必须知道变量全部的别名（即Go语言的垃圾回收器所做的工作）。</p><p>指针式实现标准库中<code>flag</code>包的关键技术，它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中。<br>在先前的<code>echo</code>版本中，就包含了两个可选的命令行参数：<code>-n</code>用于忽略行尾的换行符，<code>-s sep</code>用于指定分隔字符（默认是空格）。下面是新的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo4 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;flag&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> n = flag.Bool(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;omit trailing newline&quot;</span>)<br><span class="hljs-keyword">var</span> sep = flag.String(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;separator&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>flag.Parse()<br>fmt.Print(strings.Join(flag.Args(), *sep))<br><span class="hljs-keyword">if</span> !*n &#123;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>flag.Bool</code>函数会创建一个新的对应布尔型标志参数的变量。它有三个参数：</p><ul><li>第一个是命令行标志参数的名字，<code>n</code>。</li><li>第二个是第一个参数的默认值，<code>false</code>。</li><li>第三个是第一个标志参数对应的描述信息，<code>omit trailing newline</code>。</li></ul><p>如果用户在命令行输入了一个无效的标志参数，或输入<code>-n</code>或<code>-help</code>参数，那么将打印所有标志参数的名字、默认值和描述信息。<br>当然，<code>flag.String</code>函数与<code>flag.Bool</code>函数的区别在于，命令行标志参数的值类型不同罢了。<br>程序中的<code>sep</code>和<code>n</code>变量分别是指向命令行标志参数变量的指针，因此必须使用<code>*sep</code>和<code>*n</code>形式的指针语法简接引用它们。<br>在使用标志参数对应的变量之前，要先调用<code>flag.Parse</code>函数，用于更新每个标志参数对应变量的值（之前是默认值）。<br>对于非标志参数的普通命令行参数可以通过调用<code>flag.Args()</code>函数来访问，返回值对应一个字符串类型的<code>slice</code>。<br>如果在<code>flag.Parse</code>函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用<code>os.Exit(2)</code>终止程序。<br>下面是<code>echo</code>的测试用例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build main.go</span> <br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main a bc def</span><br>a bc def<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -s / a bc def</span><br>a/bc/def<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -f</span><br>flag provided but not defined: -f<br>Usage of ./main:<br>  -n    omit trailing newline<br>  -s string<br>        separator (default &quot; &quot;)<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./main -h</span><br>Usage of ./main:<br>  -n    omit trailing newline<br>  -s string<br>        separator (default &quot; &quot;)<br></code></pre></td></tr></table></figure><h1 id="2-3-3-new函数"><a href="#2-3-3-new函数" class="headerlink" title="2.3.3. new函数"></a>2.3.3. new函数</h1><p>另一个创建变量的方法是调用内建的<code>new</code>函数。<br>表达式<code>new(T)</code>将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为<code>*T</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>) <span class="hljs-comment">// p,*int类型，指向匿名的int变量</span><br>fmt.Println(*p) <span class="hljs-comment">// 0</span><br>*p = <span class="hljs-number">2</span><span class="hljs-comment">// 设置int匿名变量的值为2</span><br>fmt.Println(*p) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>使用<code>new</code>创建变量和普通变量声明语句方式创建变量没有什么区别，除了不需要声明一个临时变量的名字外。<br>换言之，<code>new</code>函数类似一种语法糖，而不是一个新的基础概念。<br>下面的两个<code>newInt</code>函数有着相同的行为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newInt</span><span class="hljs-params">()</span></span> *<span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">var</span> dummy <span class="hljs-type">int</span><br><span class="hljs-keyword">return</span> &amp;dummy<br>&#125;<br></code></pre></td></tr></table></figure><p>每次调用<code>new</code>函数都是返回一个新的变量的地址，因此下面两个地址是不同的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">p := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>q := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>fmt.Println(p == q) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是也有一种特殊情况：如果两个类型都是空的，也就是说类型的大小是0，例如<code>struct&#123;&#125;</code>和<code>[0]int</code>，有可能有相同的地址。<br>慎用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体可查<code>runtime.SetFinalizer</code>函数相关文档。</p><p>由于<code>new</code>只是一个预定义的函数，它并不是一个关键字，因此可以将<code>new</code>名字重新定义为别的类型。如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">delta</span><span class="hljs-params">(old, <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> - old<br>&#125;<br></code></pre></td></tr></table></figure><p>由于<code>new</code>被定义为<code>int</code>类型的变量名，因此在<code>deltal</code>函数内部无法使用内置的<code>new</code>函数。</p><h1 id="2-3-4-变量的生命周期"><a href="#2-3-4-变量的生命周期" class="headerlink" title="2.3.4. 变量的生命周期"></a>2.3.4. 变量的生命周期</h1><p>变量的生命周期指的是在程序运行期间变量有效存在的时间间隔。<br>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的。<br>而局部变量的生命周期则是动态的：从每次创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的内存空间可能被回收。<br>函数的参数变量和返回值变量都是局部变量，它们在函数每次被调用的时候创建。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>    x := math.Sin(t)<br>    y := math.Sin(t*freq + phase)<br>    img.SetColorIndex(<br>        size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>),<br>        blackIndex, <span class="hljs-comment">// 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性</span><br>    )               <span class="hljs-comment">// 小括弧另起一行缩进，和大括弧的风格保存一致</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环的开始都会创建临时变量<code>t</code>，然后在每次循环迭代中创建临时变量<code>x</code>和<code>y</code>。</p><p>那么Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收的呢？<br>基本实现思路：从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。<br>因为一个变量的有效生命周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能会超出其局部作用域。同时，局部变量可能在函数返回之后依然存在。<br>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但这个选择并不是由用<code>var</code>还是<code>new</code>声明变量的方式决定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global *<span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-type">int</span><br>x = <span class="hljs-number">1</span><br>global = &amp;x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> &#123;<br>y := <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*y = <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>f</code>函数里的<code>x</code>变量一定是在堆上分配的，因为它在函数退出后依然可以通过包一级的<code>global</code>变量找到，尽管它是在函数内部定义的。即可以说，这个<code>x</code>局部变量从函数<code>f</code>中逃逸了。<br>相反，当<code>g</code>函数返回时，变量<code>*y</code>将是不可达的，也就是说可以马上被回收的。因此，<code>*y</code>并没有从函数<code>g</code>中逃逸，编译器可以选择在栈上分配<code>*y</code>的存储空间（也可以选择在堆上分配，然后有Go语言的GC回收这个变量的内存空间），虽然这里使用了<code>new</code>方式。</p><p>其实在编写代码时不需要特意去考虑变量的逃逸行为，但是逃逸的变量需要额外分配内存空间，同时对性能可能会产生影响。</p><p>虽然自动垃圾收集器可以帮助我们不需要显式地分配和释放内存，但是编写高效的程序时依然需要了解变量的生命周期。<br>如将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收，从而可能影响程序的性能。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4. 赋值</title>
    <link href="/posts/3bab4b966165/"/>
    <url>/posts/3bab4b966165/</url>
    
    <content type="html"><![CDATA[<p>使用赋值语句可以更新一个变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">x = <span class="hljs-number">1</span><span class="hljs-comment">// 命名变量的赋值</span><br>*p = <span class="hljs-literal">true</span><span class="hljs-comment">// 通过指针间接赋值</span><br>person.name = <span class="hljs-string">&quot;bob&quot;</span><span class="hljs-comment">// 结构体字段赋值</span><br>count[x] = count[x] * scale <span class="hljs-comment">// 数组、slice或map的元素赋值</span><br></code></pre></td></tr></table></figure><p>二元算术运算符和赋值语句的复合操作可以进行简化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">count[x] *= scale<br></code></pre></td></tr></table></figure><p>数值变量也可以支持<code>++</code>递增和<code>--</code>递减语句（自增和自减是语句，而不是表达式，因此<code>x = i++</code>之类的表达式是错误的）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v := <span class="hljs-number">1</span><br>v++<span class="hljs-comment">// 等价 v = v + 1； v变成2</span><br>v--<span class="hljs-comment">// 等价 v = v - 1； v变成1</span><br></code></pre></td></tr></table></figure><h1 id="2-4-1-元组赋值"><a href="#2-4-1-元组赋值" class="headerlink" title="2.4.1. 元组赋值"></a>2.4.1. 元组赋值</h1><p>元组赋值允许同时更新多个变量的值。<br>赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。<br>下面是对变量的值进行交换：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">x, y = y, x<br>a[i], a[j] = a[j], a[i]<br></code></pre></td></tr></table></figure><p>下面是计算两个整数值的最大公约数(<code>GCD</code>, greatest common divisor)，欧几里得的GCD是最早的非平凡算法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">gcd</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">for</span> y != <span class="hljs-number">0</span> &#123;<br>x, y = y, x%y<br>&#125;<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>计算斐波那契数列（Fibonacci）的第N个数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(n <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br>x, y := <span class="hljs-number">0</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>x, y = y, x+y<br>&#125;<br><span class="hljs-keyword">return</span> x<br>&#125;<br></code></pre></td></tr></table></figure><p>元组赋值可以简化一系列琐碎赋值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">i, j, k = <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>但如果表达式太复杂，尽量避免过度使用元组赋值；单独对每个变量赋值的会提高代码的可读性。</p><p>表达式产生多个值时，左边变量数目必须和右边一致：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f, err = os.Open(<span class="hljs-string">&quot;foo.txt&quot;</span>) <span class="hljs-comment">// function call returns two values</span><br></code></pre></td></tr></table></figure><p>通常，这类函数会用额外的返回值来表达某种错误类型。如<code>os.Open</code>。<br>还有一些是用来返回布尔值，通常被称为ok，如<code>map查找</code>、<code>类型断言</code>和<code>通道接收</code>，都可能产生了两个结果，有一个额外的布尔结果表示操作是否成功。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">v, ok = m[key]<span class="hljs-comment">// map lookup  map查找</span><br>v, ok = x.(T)<span class="hljs-comment">// type assertion类型断言</span><br>v, ok = &lt;-ch        <span class="hljs-comment">// channel receive通道接收</span><br></code></pre></td></tr></table></figure><p>值得一提的是，<code>map查找</code>、<code>类型断言</code>和<code>通道接收</code>并不一定参数两个结果，也可能只产生一个结果。<br>如：</p><ul><li>map查找失败时会返回零值。</li><li>类型断言失败时会发送运行时painc异常。</li><li>通道接收失败时会返回零值（阻塞不算是失败）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">v = m[key] <span class="hljs-comment">// map查找,失败时会返回零值</span><br>v = x.(T)               <span class="hljs-comment">// type断言，失败时panic异常</span><br>v = &lt;-ch<span class="hljs-comment">// 管道接收，失败时返回零值（阻塞不算是失败）</span><br><br>_, ok = m[key]<span class="hljs-comment">// map返回2个值</span><br>_, ok = mm[<span class="hljs-string">&quot;&quot;</span>], <span class="hljs-literal">false</span><span class="hljs-comment">// map返回1个值</span><br>_ = mm[<span class="hljs-string">&quot;&quot;</span>]<span class="hljs-comment">// map返回1个值</span><br></code></pre></td></tr></table></figure><p>和变量声明一样，可以用下划线空白标识符_来丢弃不需要的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">_, err = io.Copy(dst, src) <span class="hljs-comment">// 丢弃字节数</span><br>_, ok = x.(T)              <span class="hljs-comment">// 只检测类型，忽略具体值</span><br></code></pre></td></tr></table></figure><h1 id="2-4-2-可赋值性"><a href="#2-4-2-可赋值性" class="headerlink" title="2.4.2. 可赋值性"></a>2.4.2. 可赋值性</h1><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句将隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量也会产生赋值行为。例如下面的语句：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">medals := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;gold&quot;</span>, <span class="hljs-string">&quot;silver&quot;</span>, <span class="hljs-string">&quot;bronze&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>隐式地对<code>slice</code>的每个元素进行赋值操作，类型这样写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">medals[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;gold&quot;</span> <br>medals[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;silver&quot;</span> <br>medals[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;bronze”</span><br></code></pre></td></tr></table></figure><p><code>map</code>和<code>chan</code>的元素，也有类似的隐式赋值行为。<br>无论是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。即，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</p><p>可赋值性的规则对于不同类型有着不同要求。<br>最简单地规则：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。<br>常量的可赋值性可见3.6。</p><p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系：<br>对应任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之依然。当然，每个类型都会有比较特殊的地方。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2. 声明</title>
    <link href="/posts/2628b27da087/"/>
    <url>/posts/2628b27da087/</url>
    
    <content type="html"><![CDATA[<p>声明语句定义了程序的各种实体对象以及部分或全部的属性。Go语言主要有四种类型的声明语句：</p><ul><li>var 变量</li><li>const 常量</li><li>type 类型</li><li>func 函数实体对象</li></ul><p>下面的例子中声明了一个常量、一个函数和两个变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Boiling prints the boiling point of water.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">const</span> boilingF = <span class="hljs-number">212.0</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = boilingF<br><span class="hljs-keyword">var</span> c = (f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span><br>fmt.Printf(<span class="hljs-string">&quot;boiling point = %g“°F or %g°C\n&quot;</span>, f, c)<br><span class="hljs-comment">// Output:</span><br><span class="hljs-comment">// boling point = 212°F or 100°C</span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面的fToC函数封装了温度转换的处理逻辑，这样函数只需要被定义一次，就可以在多个地方多次被使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Ftoc prints two Fahrenheit-to-Celsius conversions.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">const</span> freezingF, boilingF = <span class="hljs-number">32.0</span>, <span class="hljs-number">212.0</span><br>fmt.Printf(<span class="hljs-string">&quot;%g°F=%g°C\n&quot;</span>, freezingF, fToC(freezingF)) <span class="hljs-comment">// &quot;32°F=0°C&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%g°F=%g°C\n&quot;</span>, freezingF, fToC(boilingF))  <span class="hljs-comment">// &quot;212°F=100°C&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fToC</span><span class="hljs-params">(f <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> (f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span><br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1. 命名</title>
    <link href="/posts/feafd476469a/"/>
    <url>/posts/feafd476469a/</url>
    
    <content type="html"><![CDATA[<h1 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h1><p>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</p><p>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</p><p>如果一个命名是在函数内部定义，那么它只在函数内部有效。<br>如果定义在函数外部，那么将在当前包的所有文件中都可以访问。<br>命名的开头字母的大小写决定命名在包外的可见性，大写字母开头且在函数外部定义，那么它将是导出的，可以被外部的包访问。（包级函数名本身也是包级名字，如<code>fmt</code>包的<code>Printf</code>函数就是导出的，可以在<code>fmt</code>包外部访问）<br>包本身的名字一般总是小写字母。</p><p>命名长度没有逻辑限制，但Go语言的风格是尽量使用短小的命名，局部变量更应如此。当一个命名的作用域比较大，生命周期也比较长，那么使用长命名将更有意义。</p><p>习惯上，Go语言推荐使用<code>驼峰式</code>命名。</p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><p>Go语言中关键字有25个。</p><table><thead><tr><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th><th align="center"></th></tr></thead><tbody><tr><td align="center">break</td><td align="center">default</td><td align="center">func</td><td align="center">interface</td><td align="center">select</td></tr><tr><td align="center">case</td><td align="center">defer</td><td align="center">go</td><td align="center">map</td><td align="center">struct</td></tr><tr><td align="center">chan</td><td align="center">else</td><td align="center">goto</td><td align="center">package</td><td align="center">switch</td></tr><tr><td align="center">const</td><td align="center">fallthrough</td><td align="center">if</td><td align="center">range</td><td align="center">type</td></tr><tr><td align="center">continue</td><td align="center">for</td><td align="center">import</td><td align="center">return</td><td align="center">var</td></tr></tbody></table><h1 id="预定义"><a href="#预定义" class="headerlink" title="预定义"></a>预定义</h1><p>这些内部预定义的名字并不是关键字，可以再定义中重新使用。<br>在一些特殊的场景中重新定义它们是有意义的，但是要注意避免过度而引起语义混乱。</p><h2 id="内建常量"><a href="#内建常量" class="headerlink" title="内建常量"></a>内建常量</h2><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>true</td><td>false</td><td>iota</td><td>nill</td></tr></tbody></table><h2 id="内建类型"><a href="#内建类型" class="headerlink" title="内建类型"></a>内建类型</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>int</td><td>int8</td><td>int16</td><td>int32</td><td>int64</td><td></td></tr><tr><td>uint</td><td>uint8</td><td>uint16</td><td>uint32</td><td>uint64</td><td>uintptr</td></tr><tr><td>float32</td><td>float64</td><td>complex128</td><td>complex64</td><td></td><td></td></tr><tr><td>bool</td><td>byte</td><td>rune</td><td>string</td><td></td><td></td></tr></tbody></table><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><table><thead><tr><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>make</td><td>len</td><td>cap</td><td>new</td><td>append</td></tr><tr><td>copy</td><td>close</td><td>delete</td><td>complex</td><td>real</td></tr><tr><td>imag</td><td>panic</td><td>recover</td><td></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二章 程序结构</title>
    <link href="/posts/04348d4815af/"/>
    <url>/posts/04348d4815af/</url>
    
    <content type="html"><![CDATA[<p><a href="/posts/feafd476469a/">2.1. 命名</a></p><p><a href="/posts/2628b27da087/">2.2. 声明</a></p><p><a href="">2.3. 变量</a></p><p><a href="/posts/3bab4b966165/">2.4. 赋值</a></p><p><a href="/posts/9f13bfd0f9d8/">2.5. 类型</a></p><p><a href="/posts/4bd2d633ee16/">2.6. 包和文件</a></p><p><a href="/posts/5b89ef7a41d0/">2.7. 作用域</a></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.8. 本章要点</title>
    <link href="/posts/f529e3c31d9e/"/>
    <url>/posts/f529e3c31d9e/</url>
    
    <content type="html"><![CDATA[<h1 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h1><ul><li>if</li><li>for</li><li>switch<ul><li>Go语言并不需要显式地在每一个<code>case</code>后写<code>break</code>，语言默认执行完<code>case</code>后的逻辑语句会自动退出。</li><li><code>fallthrough</code>可以<code>case</code>穿透。</li><li>Go语言里的<code>switch</code>还可以不带操作对象，默认用<code>true</code>值代替，然后将每个case的表达式和true值进行比较。这种形式叫无tag switch(tagless switch)，与switch true等价。  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Signum</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> x &gt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> +<span class="hljs-number">1</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">case</span> x &lt; <span class="hljs-number">0</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="命名类型"><a href="#命名类型" class="headerlink" title="命名类型"></a>命名类型</h1><p>给予类型一个新名称。<br>如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> &#123;<br>    X, Y <span class="hljs-type">int</span><br>&#125;<br><span class="hljs-keyword">var</span> p Point<br></code></pre></td></tr></table></figure><h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><p> 指针是一种直接存储了变量的内存地址的数据类型。<br> 指针是可见的内存地址，<code>&amp;</code>操作符可以返回一个变量的内存地址，并且<code>*</code>操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。</p><h1 id="方法和接口"><a href="#方法和接口" class="headerlink" title="方法和接口"></a>方法和接口</h1><p> 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。<br> 接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</p><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p> 官方的标准库<br> <a href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a href="https://godoc.org/">https://godoc.org</a><br> <code>godoc</code>工具可以直接在本地命令行阅读标准库的文档，如：<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> $ </span><span class="language-bash">go doc http.ListenAndserve</span><br>package http // import &quot;net/http&quot;<br><br>func ListenAndServe(addr string, handler Handler) error<br>    ListenAndServe listens on the TCP network address addr and then calls<br>    Serve with handler to handle requests on incoming connections. Accepted<br>    connections are configured to enable TCP keep-alives.<br><br>    The handler is typically nil, in which case the DefaultServeMux is used.<br><br>    ListenAndServe always returns a non-nil error.<br></code></pre></td></tr></table></figure></p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p> 多行注释<code>/* ... */</code></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.7. Web服务</title>
    <link href="/posts/94de4df7cd79/"/>
    <url>/posts/94de4df7cd79/</url>
    
    <content type="html"><![CDATA[<p>Go语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 <a href="http://localhost:8000/hello">http://localhost:8000/hello</a> ，那么响应是URL.Path &#x3D; “hello”。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler) <span class="hljs-comment">// each request calls handler</span><br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8080&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the Path component of the request URL r.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果操作系统为Mac OS X或者Linux，可以在运行命令的末尾加上一个&amp;符号，可以在后台运行。</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">$ go <span class="hljs-keyword">run</span><span class="language-bash"> server1/main.go &amp;</span><br></code></pre></td></tr></table></figure><p>可以使用fetch进行发送客户端请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./fetch http://localhost:8000<br>URL.Path = <span class="hljs-string">&quot;/&quot;</span><br>$ ./fetch http://localhost:8000/help<br>URL.Path = <span class="hljs-string">&quot;/help&quot;</span><br></code></pre></td></tr></table></figure><p>也可以使用浏览器直接访问<code>http://localhost:8000</code>。<br>下面版本对请求次数继续计算，对URL的请求结果会包含各种URL被访问的总次数，直接对<code>/count</code>这个URL的访问要被排除。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Server2 is a minimal &quot;echo&quot; and counter server.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> mu sync.Mutex<br><span class="hljs-keyword">var</span> count <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>http.HandleFunc(<span class="hljs-string">&quot;/count&quot;</span>, counter)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// hanlder echoes the Path component of the requested URL.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>count++<br>mu.Unlock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;URL.Path = %q\n&quot;</span>, r.URL.Path)<br>&#125;<br><br><span class="hljs-comment">// counter echoes the number of calls so far.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>mu.Lock()<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Count %d\n&quot;</span>, count)<br>mu.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个更为丰富的例子，<code>handler</code>函数会把请求的http头和请求的form数据都打印出来，更便于检查和调试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, handler)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-comment">// handler echoes the HTTP request.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handler</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;%s %s %s\n&quot;</span>, r.Method, r.URL, r.Proto)<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Header &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Header[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Host = %q\n&quot;</span>, r.Host)<br>fmt.Fprintf(w, <span class="hljs-string">&quot;RemoteAddr = %q\n&quot;</span>, r.RemoteAddr)<br><span class="hljs-keyword">if</span> err := r.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Print(err)<br>&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> r.Form &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;Form[%q]=%q\n&quot;</span>, k, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行后会输出以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">GET / HTTP/1.1<br>Header[&quot;User-Agent&quot;]=[&quot;Go-http-client/1.1&quot;]<br>Header[&quot;Accept-Encoding&quot;]=[&quot;gzip&quot;]<br>Host = &quot;localhost:8000&quot;<br>RemoteAddr = &quot;127.0.0.1:51006&quot;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.12：</strong> 修改Lissajour服务，从URL读取变量，比如你可以访问 <a href="http://localhost:8000/?cycles=20">http://localhost:8000/?cycles=20</a> 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whileIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>cycles, _ := strconv.Atoi(r.FormValue(<span class="hljs-string">&quot;cycles&quot;</span>))<br><span class="hljs-keyword">if</span> cycles &gt; <span class="hljs-number">50</span> &#123;<br>fmt.Fprintf(w, <span class="hljs-string">&quot;The number of cycles cannot be greater than 50&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>lissajous(w, cycles)<br>&#125;)<br>log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(w http.ResponseWriter, cycles <span class="hljs-type">int</span>)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">//cycles = 5 // number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; <span class="hljs-type">float64</span>(cycles)*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(w, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.6. 并发获取多个URL</title>
    <link href="/posts/c84dc5dd7597/"/>
    <url>/posts/c84dc5dd7597/</url>
    
    <content type="html"><![CDATA[<p>下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elapsed\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>nbytes, err := io.Copy(io.Discard, resp.Body)<br>resp.Body.Close()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s&quot;</span>, secs, nbytes, url)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译并运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetchall.go</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetchall http://www.baidu.com http://qq.com http://gopl.io</span><br>0.03s  374152 http://www.baidu.com<br>0.05s     228 http://qq.com<br>1.42s    4154 http://gopl.io<br>1.42s elapsed<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.10：</strong> 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>start := time.Now()<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">string</span>)<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">go</span> fetch(url, ch)<br>&#125;<br><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Println(&lt;-ch)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%.2fs elased\n&quot;</span>, time.Since(start).Seconds())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-type">string</span>, ch <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-type">string</span>)</span></span> &#123;<br>start := time.Now()<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprint(err)<br><span class="hljs-keyword">return</span><br>&#125;<br>buf := <span class="hljs-built_in">new</span>(strings.Builder)<br>nbytes, err := io.Copy(buf, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;while reading %s:%v&quot;</span>, url, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>resp.Body.Close()<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(<span class="hljs-string">&quot;%.2fs %7d %s\n %s&quot;</span>, secs, nbytes, url, buf)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.11：</strong> 在fatchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。<br>解：<br>将输出响应错误信息，但不影响其他网站的访问。</p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5. 获取URL</title>
    <link href="/posts/8855378318a6/"/>
    <url>/posts/8855378318a6/</url>
    
    <content type="html"><![CDATA[<p>为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Fetch prints the content found at a URL.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>b, err := io.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:reading %s: %v\n&quot;</span>, url, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s&quot;</span>, b)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>编译运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build fetch</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./fetch http://gopl.io</span><br>&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;<br>  &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;<br>&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;<br>...<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.7：</strong> 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。<br>解：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus">package <span class="hljs-selector-tag">main</span><br><br>import (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br>func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-keyword">for</span> _, url := range os<span class="hljs-selector-class">.Args</span><span class="hljs-selector-attr">[1:]</span> &#123;<br>resp, err := http<span class="hljs-selector-class">.Get</span>(url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:%v\n&quot;</span>, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io<span class="hljs-selector-class">.Copy</span>(os<span class="hljs-selector-class">.Stdout</span>, resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br>fmt<span class="hljs-selector-class">.Fprintf</span>(os<span class="hljs-selector-class">.Stderr</span>, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>os<span class="hljs-selector-class">.Exit</span>(<span class="hljs-number">1</span>)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.8：</strong> 修改fetch这个范例，如果输入的url参数没有 http:&#x2F;&#x2F; 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br><span class="hljs-keyword">if</span> !strings.HasPrefix(url, <span class="hljs-string">&quot;http://&quot;</span>) &#123;<br>url = <span class="hljs-string">&quot;http://&quot;</span> + url<br>&#125;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>_, err = io.Copy(os.Stdout, resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:reading %s:%v&quot;</span>, url, err)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.9：</strong> 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>resp, err := http.Get(url)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stdout, <span class="hljs-string">&quot;fetch:%v&quot;</span>, err)<br>os.Exit(<span class="hljs-number">1</span>)<br>&#125;<br>fmt.Println(resp.Status)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4. GIF动画</title>
    <link href="/posts/d37e56e6ca24/"/>
    <url>/posts/d37e56e6ca24/</url>
    
    <content type="html"><![CDATA[<p>下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形(Lissajous figures)，这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Lissajous generates GIF animations of random Lissajous figures.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.White, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span> <span class="hljs-comment">// first color in palette</span><br>blackIndex = <span class="hljs-number">1</span> <span class="hljs-comment">// next color in palette</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span>     <span class="hljs-comment">// number of complete x oscillator revolutions</span><br>res     = <span class="hljs-number">0.001</span> <span class="hljs-comment">// angular resolution</span><br>size    = <span class="hljs-number">100</span>   <span class="hljs-comment">// image canvas covers[-size..size]</span><br>nframes = <span class="hljs-number">64</span>    <span class="hljs-comment">// number of animation frames</span><br>delay   = <span class="hljs-number">8</span>     <span class="hljs-comment">// delay between frames in 10ms units</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span> <span class="hljs-comment">// relative frequency of y oscillator</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span> <span class="hljs-comment">// phase difference</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; nframes; i++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring encoding errors</span><br>&#125;<br></code></pre></td></tr></table></figure><p>使用以下命令生成一个GIF动画。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build lissajous</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./lissajous &gt;out.gif</span><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/out.gif" alt="out"></p><p>练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。<br>解答：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0x1</span>&#125;, color.Black&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">1</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/out_1.gif" alt="out"></p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.6：</strong> 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;image&quot;</span><br><span class="hljs-string">&quot;image/color&quot;</span><br><span class="hljs-string">&quot;image/gif&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br><span class="hljs-string">&quot;math/rand&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> palette = []color.Color&#123;color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0xff</span>, <span class="hljs-number">0x1</span>&#125;, color.White&#125;<br><br><span class="hljs-keyword">const</span> (<br>whiteIndex = <span class="hljs-number">0</span><br>blackIndex = <span class="hljs-number">3</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>lissajous(os.Stdout)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lissajous</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<br><span class="hljs-keyword">const</span> (<br>cycles  = <span class="hljs-number">5</span><br>res     = <span class="hljs-number">0.001</span><br>size    = <span class="hljs-number">100</span><br>nframes = <span class="hljs-number">64</span><br>delay   = <span class="hljs-number">8</span><br>)<br>freq := rand.Float64() * <span class="hljs-number">3.0</span><br>anim := gif.GIF&#123;LoopCount: nframes&#125;<br>phase := <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> nf := <span class="hljs-number">0</span>; nf &lt; nframes; nf++ &#123;<br>rect := image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>, <span class="hljs-number">2</span>*size+<span class="hljs-number">1</span>)<br>img := image.NewPaletted(rect, palette)<br><span class="hljs-keyword">for</span> t := <span class="hljs-number">0.0</span>; t &lt; cycles*<span class="hljs-number">2</span>*math.Pi; t += res &#123;<br>x := math.Sin(t)<br>y := math.Sin(t*freq + phase)<br>img.SetColorIndex(size+<span class="hljs-type">int</span>(x*size+<span class="hljs-number">0.5</span>), size+<span class="hljs-type">int</span>(y*size+<span class="hljs-number">0.5</span>), blackIndex)<br>&#125;<br>phase += <span class="hljs-number">0.1</span><br>anim.Delay = <span class="hljs-built_in">append</span>(anim.Delay, delay)<br>anim.Image = <span class="hljs-built_in">append</span>(anim.Image, img)<br>&#125;<br>gif.EncodeAll(out, &amp;anim)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>效果图：</p><p><img src="/1.4.%20GIF%E5%8A%A8%E7%94%BB/lissajous2.gif" alt="lissajous2"></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3. 查找重复的行</title>
    <link href="/posts/c749b9e4bafd/"/>
    <url>/posts/c749b9e4bafd/</url>
    
    <content type="html"><![CDATA[<p>对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。</p><p>dup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，<code>map</code>数据类型以及<code>bufio</code>包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup1 prints the text of each line that appears more than</span><br><span class="hljs-comment">// once in the standard input, preceded by its count.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>input := bufio.NewScanner(os.Stdin)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> input.Text() == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span><br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。<br>if语句的else部分是可选的，在if的条件为false时执行。<br><code>map</code>存储了键&#x2F;值（key&#x2F;value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用<code>==</code>运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数<code>make</code>创建空<code>map</code>，此外，它还有别的作用。<br>从功能和实现上说，Go的<code>map</code>类似于Java语言中的<code>HashMap</code>，Python语言中的<code>dict</code>，Lua语言中的<code>table</code>，通常使用hash实现。遗憾的是，对于该词的翻译并不统一，数学界术语为映射，而计算机界众说纷纭莫衷一是。<br><code>counts[input.Text()]++</code>语句等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">line := input.Text()<br>counts[line] = counts[line] + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><code>Printf</code>部分格式字符</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">%d          十进制整数<br>%x, %o, %b  十六进制，八进制，二进制整数。<br>%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00<br>%t          布尔：true或false<br>%c          字符（rune） (Unicode码点)<br>%s          字符串<br>%q          带双引号的字符串&quot;abc&quot;或带单引号的字符&#x27;c&#x27;<br>%v          变量的自然形式（natural format）<br>%T          变量的类型<br>%%          字面上的百分号标志（无操作数）<br></code></pre></td></tr></table></figure><p>制表符<code>\t</code>和换行符<code>\n</code>,称为<code>转义字符</code>(escap sequences)。<br>按照惯例，以字母<code>f</code>结尾的格式化函数，如<code>log.Printf</code>和<code>fmt.Errof</code>,都采用了<code>fmt.Printf</code>的格式化准则。<br>以<code>ln</code>结尾的格式化函数，则遵循<code>Printlin</code>的方式，以跟<code>%v</code>差不多的方式格式化参数，并在最后添加一个换行符。<br>后缀<code>f</code>指<code>format</code>, <code>ln</code>指<code>line</code>。<br>很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。<code>dup</code>程序的下个版本读取标准输入或是使用<code>os.Open</code>打开各个具名文件，并操作它们。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Dup2 prints the count and text of lines that appear more than once</span><br><span class="hljs-comment">// in the input. It reads from stdin or from a list of named files.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p><code>dup</code>的前两个版本以”流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。下面这个版本，dup3，就是这么操作的。这个例子引入了<code>ReadFile</code>函数（来自于<code>io/ioutil</code>包），其读取指定文件的全部内容，<code>strings.Split</code>函数把字符串分割成子串的切片。（<code>Split</code>的作用与前文提到的<code>strings.Join</code>相反。）<br>我们略微简化了dup3。首先，由于<code>ReadFile</code>函数需要文件名作为参数，因此只读指定文件，不读标准输入。其次，由于行计数代码只在一处用到，故将其移回<code>main</code>函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> os.Args &#123;<br>data, err := os.ReadFile(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup3:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">for</span> _, line := <span class="hljs-keyword">range</span> strings.Split(<span class="hljs-type">string</span>(data), <span class="hljs-string">&quot;\n&quot;</span>) &#123;<br>counts[line]++<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.4：</strong> 修改dup2，出现重复的行时打印文件名称。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>counts := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)<br>files := os.Args[<span class="hljs-number">1</span>:]<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(files) == <span class="hljs-number">0</span> &#123;<br>countLines(os.Stdin, counts)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> files &#123;<br>f, err := os.Open(arg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;dup2:%v\n&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>countLines(f, counts)<br>f.Close()<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span> line, n := <span class="hljs-keyword">range</span> counts &#123;<br><span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d\t%s\n&quot;</span>, n, line)<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countLines</span><span class="hljs-params">(f *os.File, counts <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>)</span></span> &#123;<br>input := bufio.NewScanner(f)<br><span class="hljs-keyword">for</span> input.Scan() &#123;<br>counts[input.Text()]++<br><span class="hljs-keyword">if</span> counts[input.Text()] &gt; <span class="hljs-number">1</span> &#123;<br>fmt.Println(f.Name())<br>&#125;<br>&#125;<br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors form input.Err()</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2. 命令行参数</title>
    <link href="/posts/b7c6dc0a75aa/"/>
    <url>/posts/b7c6dc0a75aa/</url>
    
    <content type="html"><![CDATA[<p>大多数程序都是处理输入，产生输出，这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？<br>有以下几种获取输入数据：</p><ul><li>一些程序生成自己的数据</li><li>文件</li><li>网络连接</li><li>其它程序的输入</li><li>键盘，鼠标等</li><li>命令行参数</li><li>其它类似输入源</li></ul><p><code>os</code>包以跨平台的方式，提供了一些与操作系统交互的函数和变量。<br>程序的命令行参数可从<code>os</code>包的Args变量获取。<br><code>os</code>包外部使用<code>os.Args</code>访问该变量。</p><p><code>os.Args</code>变量是一个字符串切片（<code>string slice</code>）。<br><code>slice</code>是简化的动态数组。<br>可以把<code>slice</code>当做数组元素序列，序列的成长度动态变化，用<code>s[i]</code>访问单个元素，用<code>s[n:m]</code>获取子序列。<br>序列的元素数目为<code>len(s)</code>。<br>区间索引时，采用<code>左闭右开</code>形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。如<code>s[m:n]</code>这个切片，0 ≤ m ≤ n ≤ len(s)，包含n - m个元素。“比如a &#x3D; [1, 2, 3, 4, 5], a[0:3] &#x3D; [1, 2, 3]，不包含最后一个元素”</p><p><code>os.Args</code>的第一个元素，<code>os.Args[0]</code>是命令本身的名字。<br>其它元素则是程序启动时传给它的参数。即<code>os.Args[1:len(os.Args)]</code>,简化<code>os.Args[1:]</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo1 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s, sep <span class="hljs-type">string</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-built_in">len</span>(os.Args); i++ &#123;<br>s += sep + os.Args[i]<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ go <span class="hljs-built_in">run</span> echo1 1 2 3 4 5<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">12345<br></code></pre></td></tr></table></figure><p>Go语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> initialization; condition; post &#123;<br><span class="hljs-comment">// zero or more statements</span><br>&#125;<br></code></pre></td></tr></table></figure><p>for循环三个部分不需括号包围。<br>大括号强制要求, 左大括号必须和post语句在同一行。<br><code>initialization</code>语句是可选的，在循环开始前执行。<br><code>initalization</code>如果存在，必须是一条简单语句（<code>simple statement</code>），即，短变量声明、自增语句、赋值语句或函数调用。<br><code>condition</code>是一个布尔表达式（<code>boolean expression</code>），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。<br><code>post</code>语句在循环体执行结束后执行，之后再次对<code>conditon</code>求值。<code>condition</code>值为false时，循环结束。</p><p>for循环的这三个部分每个都可以省略，如果省略<code>initialization</code>和<code>post</code>，分号也可以省略：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional &quot;while&quot; loop</span><br><span class="hljs-keyword">for</span> condition &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果连<code>condition</code>也省略了，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// a traditional infinite loop</span><br><span class="hljs-keyword">for</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条<code>break</code>或<code>return</code>语句。</p><p>for循环的另一种形式, 在某种数据类型的区间（<code>range</code>）上遍历，如字符串或切片。echo的第二版本展示了这种形式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Echo2 prints its command-line arguments.</span><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>&#125;<br></code></pre></td></tr></table></figure><p>每次循环迭代，range产生一对值: 索引以及在该索引处的元素值。<br>这个例子不需要索引，但range的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量, 如temp, 然后忽略它的值，但Go语言不允许使用无用的局部变量（<code>local variables</code>），因为这会导致编译错误。Go语言中这种情况的解决方法是用空标识符（blank identifier），即_（也就是下划线）。</p><p>echo的这个版本使用一条短变量声明来声明并初始化s和seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span> = <span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。<br>第二种形式依赖于字符串的默认初始化零值机制，被初始化为””。<br>第三种形式用得很少，除非同时声明多个变量。<br>第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。<br>实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。</p><p>如前文所述，每次循环迭代字符串s的内容都会更新。<code>+=</code>连接原字符串、空格和下个参数，产生新字符串, 并把它赋值给s。s原来的内容已经不再使用，将在适当时机对它进行垃圾回收。</p><p>如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(os.Args[<span class="hljs-number">1</span>:])<br></code></pre></td></tr></table></figure><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p><strong>练习 1.1：</strong> 修改echo程序，使其能够打印os.Args[0]，即被执行命令本身的名字。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(os.Args[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.2：</strong> 修改echo程序，使其打印每个参数的索引和值，每个一行。<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> idx, sep := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>fmt.Print(idx)<br>fmt.Println(<span class="hljs-string">&quot;  &quot;</span> + sep)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>练习 1.3：</strong> 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）<br>解：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>startTime := time.Now()<br>s, sep := <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;<br>s += sep + arg<br>sep = <span class="hljs-string">&quot;&quot;</span><br>&#125;<br>fmt.Println(s)<br>secs := time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br><br>startTime = time.Now()<br>fmt.Println(strings.Join(os.Args[<span class="hljs-number">1</span>:], <span class="hljs-string">&quot;&quot;</span>))<br>secs = time.Since(startTime).Microseconds()<br>fmt.Println(secs)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1. Hello, World</title>
    <link href="/posts/02fc6779c7cd/"/>
    <url>/posts/02fc6779c7cd/</url>
    
    <content type="html"><![CDATA[<p>传统案例“hello world”</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello, world&quot;</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go run helloworld.go</span><br></code></pre></td></tr></table></figure><p>毫无疑问，这个命令会输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">hello, world<br></code></pre></td></tr></table></figure><p>Go语言原生支持Unicode, 可以处理全世界任何语言的文本。<br>如果不只是一次性实验，可以进行编译重新，并保留编译结果以备将来之用。<br>编译命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go build helloworld.go</span><br></code></pre></td></tr></table></figure><p>编译命令生成一个名为helloworld的可执行的二进制文件。<br>运行可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">./helloworld</span><br>hello,world<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一章 入门</title>
    <link href="/posts/b721eb61c1a0/"/>
    <url>/posts/b721eb61c1a0/</url>
    
    <content type="html"><![CDATA[<p>本章主要为Go语言的基础组件，及其示例程序等。</p><p><a href="/posts/02fc6779c7cd/">1.1. Hello, World</a></p><p><a href="/posts/b7c6dc0a75aa/">1.2. 命令行参数</a></p><p><a href="/posts/c749b9e4bafd/">1.3. 查找重复的行</a></p><p><a href="/posts/d37e56e6ca24/">1.4. GIF动画</a></p><p><a href="/posts/8855378318a6/">1.5. 获取URL</a></p><p><a href="/posts/c84dc5dd7597/">1.6. 并发获取多个URL</a></p><p><a href="/posts/94de4df7cd79/">1.7. Web服务</a></p><p><a href="/posts/f529e3c31d9e/">1.8. 本章要点</a></p>]]></content>
    
    
    <categories>
      
      <category>go</category>
      
      <category>Go语言圣经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
