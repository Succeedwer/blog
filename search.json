[{"title":"第一章 入门","url":"/2024/03/17/第一章 入门/","content":"\n\n本章主要为Go语言的基础组件，及其示例程序等。\n[1.1. Hello, World](/2024/03/16/1.1. Hello,World/)\n[1.2. 命令行参数](1231)\n[1.3. 查找重复的行](1231)\n[1.4. GIF动画](1231)\n[1.5. 获取URL](1231)\n[1.6. 并发获取多个URL](1231)\n[1.7. Web服务](1231)\n[1.8. 本章要点](1231)\n","tags":["go","Go语言圣经"]},{"title":"1.8. 本章要点","url":"/2024/03/17/1.8. 本章要点/","content":"\n# 控制流\n- if\n- for\n- switch\n\t- Go语言并不需要显式地在每一个`case`后写`break`，语言默认执行完`case`后的逻辑语句会自动退出。\n\t- `fallthrough`可以`case`穿透。\n\t- Go语言里的`switch`还可以不带操作对象，默认用`true`值代替，然后将每个case的表达式和true值进行比较。这种形式叫无tag switch(tagless switch)，与switch true等价。\n\t\t```go\n\t\tfunc Signum(x int) int {\n\t\t\tswitch {\n\t\t\tcase x > 0:\n\t\t\t\treturn +1\n\t\t\tdefault:\n\t\t\t\treturn 0\n\t\t\tcase x < 0:\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t\t```\n\t\t\n# 命名类型\n给予类型一个新名称。\n如：\n```go\ntype Point struct {\n    X, Y int\n}\nvar p Point\n```\n # 指针\n 指针是一种直接存储了变量的内存地址的数据类型。\n 指针是可见的内存地址，`&`操作符可以返回一个变量的内存地址，并且`*`操作符可以获取指针指向的变量内容，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作。\n \n # 方法和接口\n 方法是和命名类型关联的一类函数。Go语言里比较特殊的是方法可以被关联到任意一种命名类型。\n 接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。\n\n # 包\n 官方的标准库\n https://golang.org/pkg 和 https://godoc.org\n `godoc`工具可以直接在本地命令行阅读标准库的文档，如：\n ```shell\n $ go doc http.ListenAndserve\npackage http // import \"net/http\"\n\nfunc ListenAndServe(addr string, handler Handler) error\n    ListenAndServe listens on the TCP network address addr and then calls\n    Serve with handler to handle requests on incoming connections. Accepted\n    connections are configured to enable TCP keep-alives.\n\n    The handler is typically nil, in which case the DefaultServeMux is used.\n\n    ListenAndServe always returns a non-nil error.\n ```\n\n \n # 注释\n 多行注释`/* ... */`","tags":["go","Go语言圣经"]},{"title":"1.7. Web服务","url":"/2024/03/17/1.7. Web服务/","content":"\nGo语言的内置库使得写一个类似fetch的web服务器变得异常地简单。在本节中，我们会展示一个微型服务器，这个服务器的功能是返回当前用户正在访问的URL。比如用户访问的是 http://localhost:8000/hello ，那么响应是URL.Path = \"hello\"。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler) // each request calls handler\n\tlog.Fatal(http.ListenAndServe(\"localhost:8080\", nil))\n}\n\n// handler echoes the Path component of the request URL r.\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path)\n}\n```\n如果操作系统为Mac OS X或者Linux，可以在运行命令的末尾加上一个&符号，可以在后台运行。\n```\n$ go run server1/main.go &\n```\n可以使用fetch进行发送客户端请求。\n```\n$ ./fetch http://localhost:8000\nURL.Path = \"/\"\n$ ./fetch http://localhost:8000/help\nURL.Path = \"/help\"\n```\n也可以使用浏览器直接访问`http://localhost:8000`。\n下面版本对请求次数继续计算，对URL的请求结果会包含各种URL被访问的总次数，直接对`/count`这个URL的访问要被排除。\n```go\n// Server2 is a minimal \"echo\" and counter server.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n\t\"sync\"\n)\n\nvar mu sync.Mutex\nvar count int\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\thttp.HandleFunc(\"/count\", counter)\n\tlog.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n}\n\n// hanlder echoes the Path component of the requested URL.\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tmu.Lock()\n\tcount++\n\tmu.Unlock()\n\tfmt.Fprintf(w, \"URL.Path = %q\\n\", r.URL.Path)\n}\n\n// counter echoes the number of calls so far.\nfunc counter(w http.ResponseWriter, r *http.Request) {\n\tmu.Lock()\n\tfmt.Fprintf(w, \"Count %d\\n\", count)\n\tmu.Unlock()\n}\n```\n下面是一个更为丰富的例子，`handler`函数会把请求的http头和请求的form数据都打印出来，更便于检查和调试。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"log\"\n\t\"net/http\"\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", handler)\n\tlog.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n}\n\n// handler echoes the HTTP request.\nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintf(w, \"%s %s %s\\n\", r.Method, r.URL, r.Proto)\n\tfor k, v := range r.Header {\n\t\tfmt.Fprintf(w, \"Header[%q]=%q\\n\", k, v)\n\t}\n\tfmt.Fprintf(w, \"Host = %q\\n\", r.Host)\n\tfmt.Fprintf(w, \"RemoteAddr = %q\\n\", r.RemoteAddr)\n\tif err := r.ParseForm(); err != nil {\n\t\tlog.Print(err)\n\t}\n\tfor k, v := range r.Form {\n\t\tfmt.Fprintf(w, \"Form[%q]=%q\\n\", k, v)\n\t}\n}\n```\n运行后会输出以下内容：\n```text\nGET / HTTP/1.1\nHeader[\"User-Agent\"]=[\"Go-http-client/1.1\"]\nHeader[\"Accept-Encoding\"]=[\"gzip\"]\nHost = \"localhost:8000\"\nRemoteAddr = \"127.0.0.1:51006\"\n```\n\n# 练习\n**练习 1.12：** 修改Lissajour服务，从URL读取变量，比如你可以访问 http://localhost:8000/?cycles=20 这个URL，这样访问可以将程序里的cycles默认的5修改为20。字符串转换为数字可以调用strconv.Atoi函数。你可以在godoc里查看strconv.Atoi的详细说明。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"log\"\n\t\"math\"\n\t\"math/rand\"\n\t\"net/http\"\n\t\"strconv\"\n)\n\nvar palette = []color.Color{color.White, color.Black}\n\nconst (\n\twhileIndex = 0 // first color in palette\n\tblackIndex = 1 // next color in palette\n)\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\tcycles, _ := strconv.Atoi(r.FormValue(\"cycles\"))\n\t\tif cycles > 50 {\n\t\t\tfmt.Fprintf(w, \"The number of cycles cannot be greater than 50\")\n\t\t\treturn\n\t\t}\n\t\tlissajous(w, cycles)\n\t})\n\tlog.Fatal(http.ListenAndServe(\"localhost:8000\", nil))\n}\n\nfunc lissajous(w http.ResponseWriter, cycles int) {\n\tconst (\n\t\t//cycles = 5 // number of complete x oscillator revolutions\n\t\tres     = 0.001 // angular resolution\n\t\tsize    = 100   // image canvas covers[-size..size]\n\t\tnframes = 64    // number of animation frames\n\t\tdelay   = 8     // delay between frames in 10ms units\n\t)\n\tfreq := rand.Float64() * 3.0 // relative frequency of y oscillator\n\tanim := gif.GIF{LoopCount: nframes}\n\tphase := 0.0 // phase difference\n\tfor i := 0; i < nframes; i++ {\n\t\trect := image.Rect(0, 0, 2*size+1, 2*size+1)\n\t\timg := image.NewPaletted(rect, palette)\n\t\tfor t := 0.0; t < float64(cycles)*2*math.Pi; t += res {\n\t\t\tx := math.Sin(t)\n\t\t\ty := math.Sin(t*freq + phase)\n\t\t\timg.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)\n\t\t}\n\t\tphase += 0.1\n\t\tanim.Delay = append(anim.Delay, delay)\n\t\tanim.Image = append(anim.Image, img)\n\t}\n\tgif.EncodeAll(w, &anim) // NOTE: ignoring encoding errors\n}\n```","tags":["go","Go语言圣经"]},{"title":"1.6. 并发获取多个URL","url":"/2024/03/17/1.6. 并发获取多个URL/","content":"\n下面的例子fetchall，和前面小节的fetch程序所要做的工作基本一致，fetchall的特别之处在于它会同时去获取所有的URL，所以这个程序的总执行时间不会超过执行时间最长的那一个任务，前面的fetch程序执行时间则是所有任务执行时间之和。fetchall程序只会打印获取的内容大小和经过的时间，不会像之前那样打印获取的内容。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tch := make(chan string)\n\tfor _, url := range os.Args[1:] {\n\t\tgo fetch(url, ch)\n\t}\n\tfor range os.Args[1:] {\n\t\tfmt.Println(<-ch)\n\t}\n\tfmt.Printf(\"%.2fs elapsed\\n\", time.Since(start).Seconds())\n}\n\nfunc fetch(url string, ch chan<- string) {\n\tstart := time.Now()\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tch <- fmt.Sprint(err)\n\t\treturn\n\t}\n\tnbytes, err := io.Copy(io.Discard, resp.Body)\n\tresp.Body.Close()\n\tif err != nil {\n\t\tch <- fmt.Sprintf(\"while reading %s:%v\", url, err)\n\t\treturn\n\t}\n\tsecs := time.Since(start).Seconds()\n\tch <- fmt.Sprintf(\"%.2fs %7d %s\", secs, nbytes, url)\n}\n\n```\n编译并运行\n```shell\n$ go build fetchall.go\n$ ./fetchall http://www.baidu.com http://qq.com http://gopl.io\n0.03s  374152 http://www.baidu.com\n0.05s     228 http://qq.com\n1.42s    4154 http://gopl.io\n1.42s elapsed\n```\n\n# 练习\n**练习 1.10：** 找一个数据量比较大的网站，用本小节中的程序调研网站的缓存策略，对每个URL执行两遍请求，查看两次时间是否有较大的差别，并且每次获取到的响应内容是否一致，修改本节中的程序，将响应结果输出，以便于进行对比。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tstart := time.Now()\n\tch := make(chan string)\n\tfor _, url := range os.Args[1:] {\n\t\tgo fetch(url, ch)\n\t}\n\tfor range os.Args[1:] {\n\t\tfmt.Println(<-ch)\n\t}\n\tfmt.Printf(\"%.2fs elased\\n\", time.Since(start).Seconds())\n}\n\nfunc fetch(url string, ch chan<- string) {\n\tstart := time.Now()\n\tresp, err := http.Get(url)\n\tif err != nil {\n\t\tch <- fmt.Sprint(err)\n\t\treturn\n\t}\n\tbuf := new(strings.Builder)\n\tnbytes, err := io.Copy(buf, resp.Body)\n\tif err != nil {\n\t\tch <- fmt.Sprintf(\"while reading %s:%v\", url, err)\n\t\treturn\n\t}\n\tresp.Body.Close()\n\tsecs := time.Since(start).Seconds()\n\tch <- fmt.Sprintf(\"%.2fs %7d %s\\n %s\", secs, nbytes, url, buf)\n}\n```\n**练习 1.11：** 在fatchall中尝试使用长一些的参数列表，比如使用在alexa.com的上百万网站里排名靠前的。如果一个网站没有回应，程序将采取怎样的行为？（Section8.9 描述了在这种情况下的应对机制）。\n解：\n将输出响应错误信息，但不影响其他网站的访问。","tags":["go","Go语言圣经"]},{"title":"1.5. 获取URL","url":"/2024/03/17/1.5. 获取URL/","content":"\n为了最简单地展示基于HTTP获取信息的方式，下面给出一个示例程序fetch，这个程序将获取对应的url，并将其源文本打印出来；这个例子的灵感来源于curl工具（译注：unix下的一个用来发http请求的工具，具体可以man curl）。当然，curl提供的功能更为复杂丰富，这里只编写最简单的样例。这个样例之后还会多次被用到。\n```go\n// Fetch prints the content found at a URL.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor _, url := range os.Args[1:] {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"fetch:%v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tb, err := io.ReadAll(resp.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"fetch:reading %s: %v\\n\", url, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Printf(\"%s\", b)\n\t}\n}\n\n```\n编译运行\n```shell\n$ go build fetch\n$ ./fetch http://gopl.io\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n\t  \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n...\n```\n# 练习\n**练习 1.7：** 函数调用io.Copy(dst, src)会从src中读取内容，并将读到的结果写入到dst中，使用这个函数替代掉例子中的ioutil.ReadAll来拷贝响应结构体到os.Stdout，避免申请一个缓冲区（例子中的b）来存储。记得处理io.Copy返回结果中的错误。\n解：\n```\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor _, url := range os.Args[1:] {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"fetch:%v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t_, err = io.Copy(os.Stdout, resp.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"fetch:reading %s:%v\", url, err)\n\t\t\tos.Exit(1)\n\t\t}\n\t}\n}\n```\n**练习 1.8：** 修改fetch这个范例，如果输入的url参数没有 http:// 前缀的话，为这个url加上该前缀。你可能会用到strings.HasPrefix这个函数。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io\"\n\t\"net/http\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfor _, url := range os.Args[1:] {\n\t\tif !strings.HasPrefix(url, \"http://\") {\n\t\t\turl = \"http://\" + url\n\t\t}\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"fetch:%v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\t_, err = io.Copy(os.Stdout, resp.Body)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stdout, \"fetch:reading %s:%v\", url, err)\n\t\t}\n\t}\n}\n```\n**练习 1.9：** 修改fetch打印出HTTP协议的状态码，可以从resp.Status变量得到该状态码。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor _, url := range os.Args[1:] {\n\t\tresp, err := http.Get(url)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stdout, \"fetch:%v\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\tfmt.Println(resp.Status)\n\t}\n}\n```","tags":["go","Go语言圣经"]},{"title":"1.4. GIF动画","url":"/2024/03/17/1.4. GIF动画/","content":"下面的程序会演示Go语言标准库里的image这个package的用法，我们会用这个包来生成一系列的bit-mapped图，然后将这些图片编码为一个GIF动画。我们生成的图形名字叫利萨如图形(Lissajous figures)，这种效果是在1960年代的老电影里出现的一种视觉特效。它们是协振子在两个纬度上振动所产生的曲线，比如两个sin正弦波分别在x轴和y轴输入会产生的曲线。\n```go\n// Lissajous generates GIF animations of random Lissajous figures.\npackage main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n)\n\nvar palette = []color.Color{color.White, color.Black}\n\nconst (\n\twhiteIndex = 0 // first color in palette\n\tblackIndex = 1 // next color in palette\n)\n\nfunc main() {\n\tlissajous(os.Stdout)\n}\n\nfunc lissajous(out io.Writer) {\n\tconst (\n\t\tcycles  = 5     // number of complete x oscillator revolutions\n\t\tres     = 0.001 // angular resolution\n\t\tsize    = 100   // image canvas covers[-size..size]\n\t\tnframes = 64    // number of animation frames\n\t\tdelay   = 8     // delay between frames in 10ms units\n\t)\n\tfreq := rand.Float64() * 3.0 // relative frequency of y oscillator\n\tanim := gif.GIF{LoopCount: nframes}\n\tphase := 0.0 // phase difference\n\tfor i := 0; i < nframes; i++ {\n\t\trect := image.Rect(0, 0, 2*size+1, 2*size+1)\n\t\timg := image.NewPaletted(rect, palette)\n\t\tfor t := 0.0; t < cycles*2*math.Pi; t += res {\n\t\t\tx := math.Sin(t)\n\t\t\ty := math.Sin(t*freq + phase)\n\t\t\timg.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)\n\t\t}\n\t\tphase += 0.1\n\t\tanim.Delay = append(anim.Delay, delay)\n\t\tanim.Image = append(anim.Image, img)\n\t}\n\tgif.EncodeAll(out, &anim) // NOTE: ignoring encoding errors\n}\n```\n使用以下命令生成一个GIF动画。\n```shell\n$ go build lissajous\n$ ./lissajous >out.gif\n```\n效果图：\n\n![out](./images/out.gif)\n\n练习 1.5： 修改前面的Lissajous程序里的调色板，由黑色改为绿色。我们可以用color.RGBA{0xRR, 0xGG, 0xBB, 0xff}来得到#RRGGBB这个色值，三个十六进制的字符串分别代表红、绿、蓝像素。\n解答：\n```go\npackage main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n)\n\nvar palette = []color.Color{color.RGBA{0, 0xff, 0, 0x1}, color.Black}\n\nconst (\n\twhiteIndex = 0\n\tblackIndex = 1\n)\n\nfunc main() {\n\tlissajous(os.Stdout)\n}\n\nfunc lissajous(out io.Writer) {\n\tconst (\n\t\tcycles  = 5\n\t\tres     = 0.001\n\t\tsize    = 100\n\t\tnframes = 64\n\t\tdelay   = 8\n\t)\n\tfreq := rand.Float64() * 3.0\n\tanim := gif.GIF{LoopCount: nframes}\n\tphase := 0.0\n\tfor nf := 0; nf < nframes; nf++ {\n\t\trect := image.Rect(0, 0, 2*size+1, 2*size+1)\n\t\timg := image.NewPaletted(rect, palette)\n\t\tfor t := 0.0; t < cycles*2*math.Pi; t += res {\n\t\t\tx := math.Sin(t)\n\t\t\ty := math.Sin(t*freq + phase)\n\t\t\timg.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)\n\t\t}\n\t\tphase += 0.1\n\t\tanim.Delay = append(anim.Delay, delay)\n\t\tanim.Image = append(anim.Image, img)\n\t}\n\tgif.EncodeAll(out, &anim)\n}\n\n```\n效果图：\n\n![out](./images/out_1.gif)\n# 练习\n**练习 1.6：** 修改Lissajous程序，修改其调色板来生成更丰富的颜色，然后修改SetColorIndex的第三个参数，看看显示结果吧。\n解：\n```go\npackage main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/gif\"\n\t\"io\"\n\t\"math\"\n\t\"math/rand\"\n\t\"os\"\n)\n\nvar palette = []color.Color{color.RGBA{0, 0, 0xff, 0x1}, color.White}\n\nconst (\n\twhiteIndex = 0\n\tblackIndex = 3\n)\n\nfunc main() {\n\tlissajous(os.Stdout)\n}\n\nfunc lissajous(out io.Writer) {\n\tconst (\n\t\tcycles  = 5\n\t\tres     = 0.001\n\t\tsize    = 100\n\t\tnframes = 64\n\t\tdelay   = 8\n\t)\n\tfreq := rand.Float64() * 3.0\n\tanim := gif.GIF{LoopCount: nframes}\n\tphase := 0.0\n\tfor nf := 0; nf < nframes; nf++ {\n\t\trect := image.Rect(0, 0, 2*size+1, 2*size+1)\n\t\timg := image.NewPaletted(rect, palette)\n\t\tfor t := 0.0; t < cycles*2*math.Pi; t += res {\n\t\t\tx := math.Sin(t)\n\t\t\ty := math.Sin(t*freq + phase)\n\t\t\timg.SetColorIndex(size+int(x*size+0.5), size+int(y*size+0.5), blackIndex)\n\t\t}\n\t\tphase += 0.1\n\t\tanim.Delay = append(anim.Delay, delay)\n\t\tanim.Image = append(anim.Image, img)\n\t}\n\tgif.EncodeAll(out, &anim)\n}\n\n```\n效果图：\n\n![lissajous2](./images/lissajous2.gif)","tags":["go","Go语言圣经"]},{"title":"1.2. 命令行参数","url":"/2024/03/17/1.2. 命令行参数/","content":"\n大多数程序都是处理输入，产生输出，这也正是“计算”的定义。但是，程序如何获取要处理的输入数据呢？\n有以下几种获取输入数据：\n\n- 一些程序生成自己的数据\n- 文件\n- 网络连接\n- 其它程序的输入\n- 键盘，鼠标等\n- 命令行参数\n- 其它类似输入源\n\n`os`包以跨平台的方式，提供了一些与操作系统交互的函数和变量。\n程序的命令行参数可从`os`包的Args变量获取。\n`os`包外部使用`os.Args`访问该变量。\n\n`os.Args`变量是一个字符串切片（`string slice`）。\n`slice`是简化的动态数组。\n可以把`slice`当做数组元素序列，序列的成长度动态变化，用`s[i]`访问单个元素，用`s[n:m]`获取子序列。\n序列的元素数目为`len(s)`。\n区间索引时，采用`左闭右开`形式，即，区间包括第一个索引元素，不包括最后一个，因为这样可以简化逻辑。如`s[m:n]`这个切片，0 ≤ m ≤ n ≤ len(s)，包含n - m个元素。“比如a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]，不包含最后一个元素”\n\n`os.Args`的第一个元素，`os.Args[0]`是命令本身的名字。\n其它元素则是程序启动时传给它的参数。即`os.Args[1:len(os.Args)]`,简化`os.Args[1:]`。\n\n```go\n// Echo1 prints its command-line arguments.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tvar s, sep string\n\tfor i := 1; i < len(os.Args); i++ {\n\t\ts += sep + os.Args[i]\n\t\tsep = \"\"\n\t}\n\tfmt.Println(s)\n}\n\n```\n运行命令：\n```\n$ go run echo1 1 2 3 4 5\n```\n输出：\n```\n12345\n```\nGo语言只有for循环这一种循环语句。for循环有多种形式，其中一种如下所示：\n```go\nfor initialization; condition; post {\n\t// zero or more statements\n}\n```\nfor循环三个部分不需括号包围。\n大括号强制要求, 左大括号必须和post语句在同一行。\n`initialization`语句是可选的，在循环开始前执行。\n`initalization`如果存在，必须是一条简单语句（`simple statement`），即，短变量声明、自增语句、赋值语句或函数调用。\n`condition`是一个布尔表达式（`boolean expression`），其值在每次循环迭代开始时计算。如果为true则执行循环体语句。\n`post`语句在循环体执行结束后执行，之后再次对`conditon`求值。`condition`值为false时，循环结束。\n\nfor循环的这三个部分每个都可以省略，如果省略`initialization`和`post`，分号也可以省略：\n```go\n// a traditional \"while\" loop\nfor condition {\n    // ...\n}\n```\n如果连`condition`也省略了，像下面这样：\n```go\n// a traditional infinite loop\nfor {\n    // ...\n}\n```\n这就变成一个无限循环，尽管如此，还可以用其他方式终止循环, 如一条`break`或`return`语句。\n\nfor循环的另一种形式, 在某种数据类型的区间（`range`）上遍历，如字符串或切片。echo的第二版本展示了这种形式:\n```go\n// Echo2 prints its command-line arguments.\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\ts, sep := \"\", \"\"\n\tfor _, arg := range os.Args[1:] {\n\t\ts += sep + arg\n\t\tsep = \"\"\n\t}\n\tfmt.Println(s)\n}\n```\n每次循环迭代，range产生一对值: 索引以及在该索引处的元素值。\n这个例子不需要索引，但range的语法要求, 要处理元素, 必须处理索引。一种思路是把索引赋值给一个临时变量, 如temp, 然后忽略它的值，但Go语言不允许使用无用的局部变量（`local variables`），因为这会导致编译错误。Go语言中这种情况的解决方法是用空标识符（blank identifier），即_（也就是下划线）。\n\necho的这个版本使用一条短变量声明来声明并初始化s和seps，也可以将这两个变量分开声明，声明一个变量有好几种方式，下面这些都等价：\n```go\ns := \"\"\nvar s string\nvar s = \"\"\nvar s string = \"\"\n```\n第一种形式，是一条短变量声明，最简洁，但只能用在函数内部，而不能用于包变量。\n第二种形式依赖于字符串的默认初始化零值机制，被初始化为\"\"。\n第三种形式用得很少，除非同时声明多个变量。\n第四种形式显式地标明变量的类型，当变量类型与初值类型相同时，类型冗余，但如果两者类型不同，变量类型就必须了。\n实践中一般使用前两种形式中的某个，初始值重要的话就显式地指定变量的类型，否则使用隐式初始化。\n\n如前文所述，每次循环迭代字符串s的内容都会更新。`+=`连接原字符串、空格和下个参数，产生新字符串, 并把它赋值给s。s原来的内容已经不再使用，将在适当时机对它进行垃圾回收。\n\n如果连接涉及的数据量很大，这种方式代价高昂。一种简单且高效的解决方案是使用strings包的Join函数：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tfmt.Println(strings.Join(os.Args[1:], \"\"))\n}\n```\n最后，如果不关心输出格式，只想看看输出值，或许只是为了调试，可以用Println为我们格式化输出。\n```go\n\tfmt.Println(os.Args[1:])\n```\n\n# 练习\n**练习 1.1：** 修改echo程序，使其能够打印os.Args[0]，即被执行命令本身的名字。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfmt.Println(os.Args[0])\n}\n```\n**练习 1.2：** 修改echo程序，使其打印每个参数的索引和值，每个一行。\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor idx, sep := range os.Args[1:] {\n\t\tfmt.Print(idx)\n\t\tfmt.Println(\"  \" + sep)\n\t}\n}\n```\n\n**练习 1.3：** 做实验测量潜在低效的版本和使用了strings.Join的版本的运行时间差异。（1.6节讲解了部分time包，11.4节展示了如何写标准测试程序，以得到系统性的性能评测。）\n解：\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n\t\"time\"\n)\n\nfunc main() {\n\tstartTime := time.Now()\n\ts, sep := \"\", \"\"\n\tfor _, arg := range os.Args[1:] {\n\t\ts += sep + arg\n\t\tsep = \"\"\n\t}\n\tfmt.Println(s)\n\tsecs := time.Since(startTime).Microseconds()\n\tfmt.Println(secs)\n\n\tstartTime = time.Now()\n\tfmt.Println(strings.Join(os.Args[1:], \"\"))\n\tsecs = time.Since(startTime).Microseconds()\n\tfmt.Println(secs)\n}\n```","tags":["go","Go语言圣经"]},{"title":"1.3. 查找重复的行","url":"/2024/03/17/1.3. 查找重复的行/","content":"对文件做拷贝、打印、搜索、排序、统计或类似事情的程序都有一个差不多的程序结构：一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。我们会展示一个名为dup的程序的三个版本；灵感来自于Unix的uniq命令，其寻找相邻的重复行。该程序使用的结构和包是个参考范例，可以方便地修改。\n\ndup的第一个版本打印标准输入中多次出现的行，以重复次数开头。该程序将引入if语句，`map`数据类型以及`bufio`包。\n```go\n// Dup1 prints the text of each line that appears more than\n// once in the standard input, preceded by its count.\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tcounts := make(map[string]int)\n\tinput := bufio.NewScanner(os.Stdin)\n\tfor input.Scan() {\n\t\tcounts[input.Text()]++\n\t\tif input.Text() == \"\" {\n\t\t\tbreak\n\t\t}\n\t}\n\t// NOTE: ignoring potential errors from input.Err()\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tfmt.Printf(\"%d\\t%s\\n\", n, line)\n\t\t}\n\t}\n}\n\n```\n正如for循环一样，if语句条件两边也不加括号，但是主体部分需要加。\nif语句的else部分是可选的，在if的条件为false时执行。\n`map`存储了键/值（key/value）的集合，对集合元素，提供常数时间的存、取或测试操作。键可以是任意类型，只要其值能用`==`运算符比较，最常见的例子是字符串；值则可以是任意类型。这个例子中的键是字符串，值是整数。内置函数`make`创建空`map`，此外，它还有别的作用。\n从功能和实现上说，Go的`map`类似于Java语言中的`HashMap`，Python语言中的`dict`，Lua语言中的`table`，通常使用hash实现。遗憾的是，对于该词的翻译并不统一，数学界术语为映射，而计算机界众说纷纭莫衷一是。\n`counts[input.Text()]++`语句等价于：\n```go\nline := input.Text()\ncounts[line] = counts[line] + 1\n```\n`Printf`部分格式字符\n```text\n%d          十进制整数\n%x, %o, %b  十六进制，八进制，二进制整数。\n%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00\n%t          布尔：true或false\n%c          字符（rune） (Unicode码点)\n%s          字符串\n%q          带双引号的字符串\"abc\"或带单引号的字符'c'\n%v          变量的自然形式（natural format）\n%T          变量的类型\n%%          字面上的百分号标志（无操作数）\n```\n\n制表符`\\t`和换行符`\\n`,称为`转义字符`(escap sequences)。\n按照惯例，以字母`f`结尾的格式化函数，如`log.Printf`和`fmt.Errof`,都采用了`fmt.Printf`的格式化准则。\n以`ln`结尾的格式化函数，则遵循`Printlin`的方式，以跟`%v`差不多的方式格式化参数，并在最后添加一个换行符。\n后缀`f`指`format`, `ln`指`line`。\n很多程序要么从标准输入中读取数据，如上面的例子所示，要么从一系列具名文件中读取数据。`dup`程序的下个版本读取标准输入或是使用`os.Open`打开各个具名文件，并操作它们。\n```go\n// Dup2 prints the count and text of lines that appear more than once\n// in the input. It reads from stdin or from a list of named files.\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tcounts := make(map[string]int)\n\tfiles := os.Args[1:]\n\tif len(files) == 0 {\n\t\tcountLines(os.Stdin, counts)\n\t} else {\n\t\tfor _, arg := range files {\n\t\t\tf, err := os.Open(arg)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"dup2:%v\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcountLines(f, counts)\n\t\t\tf.Close()\n\t\t}\n\t}\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tfmt.Printf(\"%d\\t%s\\n\", n, line)\n\t\t}\n\t}\n}\n\nfunc countLines(f *os.File, counts map[string]int) {\n\tinput := bufio.NewScanner(f)\n\tfor input.Scan() {\n\t\tcounts[input.Text()]++\n\t}\n\t// NOTE: ignoring potential errors form input.Err()\n}\n\n```\n\n`dup`的前两个版本以\"流”模式读取输入，并根据需要拆分成多个行。理论上，这些程序可以处理任意数量的输入数据。还有另一个方法，就是一口气把全部输入数据读到内存中，一次分割为多行，然后处理它们。下面这个版本，dup3，就是这么操作的。这个例子引入了`ReadFile`函数（来自于`io/ioutil`包），其读取指定文件的全部内容，`strings.Split`函数把字符串分割成子串的切片。（`Split`的作用与前文提到的`strings.Join`相反。）\n我们略微简化了dup3。首先，由于`ReadFile`函数需要文件名作为参数，因此只读指定文件，不读标准输入。其次，由于行计数代码只在一处用到，故将其移回`main`函数。\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"strings\"\n)\n\nfunc main() {\n\tcounts := make(map[string]int)\n\tfor _, filename := range os.Args {\n\t\tdata, err := os.ReadFile(filename)\n\t\tif err != nil {\n\t\t\tfmt.Fprintf(os.Stderr, \"dup3:%v\\n\", err)\n\t\t\tcontinue\n\t\t}\n\t\tfor _, line := range strings.Split(string(data), \"\\n\") {\n\t\t\tcounts[line]++\n\t\t}\n\t}\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tfmt.Printf(\"%d\\t%s\\n\", n, line)\n\t\t}\n\t}\n}\n```\n# 练习\n**练习 1.4：** 修改dup2，出现重复的行时打印文件名称。\n解：\n```go\npackage main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tcounts := make(map[string]int)\n\tfiles := os.Args[1:]\n\tif len(files) == 0 {\n\t\tcountLines(os.Stdin, counts)\n\t} else {\n\t\tfor _, arg := range files {\n\t\t\tf, err := os.Open(arg)\n\t\t\tif err != nil {\n\t\t\t\tfmt.Fprintf(os.Stderr, \"dup2:%v\\n\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tcountLines(f, counts)\n\t\t\tf.Close()\n\t\t}\n\t}\n\tfor line, n := range counts {\n\t\tif n > 1 {\n\t\t\tfmt.Printf(\"%d\\t%s\\n\", n, line)\n\t\t}\n\t}\n}\n\nfunc countLines(f *os.File, counts map[string]int) {\n\tinput := bufio.NewScanner(f)\n\tfor input.Scan() {\n\t\tcounts[input.Text()]++\n\t\tif counts[input.Text()] > 1 {\n\t\t\tfmt.Println(f.Name())\n\t\t}\n\t}\n\t// NOTE: ignoring potential errors form input.Err()\n}\n```\n","tags":["go","Go语言圣经"]},{"title":"1.1. Hello,World","url":"/2024/03/17/1.1. Hello,World/","content":"\n传统案例“hello world”\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Println(\"hello, world\")\n}\n\n```\n运行指令\n```shell\n$ go run helloworld.go\n```\n毫无疑问，这个命令会输出：\n```text\nhello, world\n```\nGo语言原生支持Unicode, 可以处理全世界任何语言的文本。\n如果不只是一次性实验，可以进行编译重新，并保留编译结果以备将来之用。\n编译命令\n```shell\n$ go build helloworld.go\n```\n编译命令生成一个名为helloworld的可执行的二进制文件。\n运行可执行文件：\n```shell\n$ ./helloworld\nhello,world\n```\n\n\n","tags":["go","Go语言圣经"]}]